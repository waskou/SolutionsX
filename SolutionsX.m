(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
SolutionsX`SolutionsX`$FieldsXVersionExpected={"1.1.3",{2021,5,27}};
SolutionsX`SolutionsX`$Version={"0.0.1",{2022,3,28}};


(* ::Input::Initialization:: *)
(****************************** 1. Initialization for SolutionsX *****************************)


(* ::Input::Initialization:: *)
(* SolutionsX: Database of supegravity solutions *)

(* Copyright (C) 2022 Vasil Dimitrov *)

(* This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License,or (at your option) any later version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place-Suite 330, Boston, MA 02111-1307, USA. 
*)


(* ::Input::Initialization:: *)
(* :Title: SolutionsX *)

(* :Author: Vasil Dimitrov *)

(* :Summary: Database of supergravity solutions *)

(* :Brief Discussion: *)
  
(* :Context: SolutionsX`SolutionsX` *)

(* :Package Version: 0.0.1 *)

(* :Copyright: Vasil Dimitrov (2022) *)

(* :History: TODO *)

(* :Keywords: TODO *)

(* :Source: SolutionsX.nb *)

(* :Warning: TODO *)

(* :Mathematica Version: 8.0 and later *)

(* :Limitations: *)
	
(* :Acknowledgements: *)


(* ::Input::Initialization:: *)
If[Unevaluated[xAct`xCore`Private`$LastPackage]===xAct`xCore`Private`$LastPackage,xAct`xCore`Private`$LastPackage="SolutionsX`SolutionsX`"];


(* ::Input::Initialization:: *)
BeginPackage["SolutionsX`SolutionsX`",{"xAct`FieldsX`","xAct`xTerior`","xAct`xCoba`","xAct`xTensor`","xAct`xCore`"}];


(* ::Input::Initialization:: *)
If[Not@OrderedQ@Map[Last,{$FieldsXVersionExpected,xAct`FieldsX`$Version}],Throw@Message[General::versions,"FieldsX",xAct`FieldsX`$Version,$FieldsXVersionExpected]]


(* ::Input::Initialization:: *)
Print[xAct`xCore`Private`bars]
Print["Package SolutionsX`SolutionsX`  version ",SolutionsX`SolutionsX`$Version[[1]],", ",SolutionsX`SolutionsX`$Version[[2]] ];
Print["Copyright (C) 2022, Vasil Dimitrov, under the General Public License."];


(* ::Input::Initialization:: *)
Off[General::shdw]
xAct`xForm`Disclaimer[]:=Print["These are points 11 and 12 of the General Public License:\n\nBECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM `AS IS\.b4 WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\nIN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES."]
On[General::shdw]


(* ::Input::Initialization:: *)
If[xAct`xCore`Private`$LastPackage==="SolutionsX`SolutionsX`",
Unset[xAct`xCore`Private`$LastPackage];
Print[xAct`xCore`Private`bars];
Print["These packages come with ABSOLUTELY NO WARRANTY; for details type Disclaimer[]. This is free software, and you are welcome to redistribute it under certain conditions. See the General Public License for details."];
Print[xAct`xCore`Private`bars]]


(* ::Input::Initialization:: *)
(*get keys and values from the internal variables*)
(*GetValues::usage="(GetValues[$ymbol,IncludeCoordinatesQ\[Rule]boolean]||GetValues[key1,key2]||GetValues[key1,key2,key3]) is a function that returns a list of values from $olution depending on certain allowed key specifications";
GetKeys::usage="GetKeys[$form,$tensorQ\[Rule](boolean||Null)] is a function that returns the keys of all forms | The options {$tensorQ\[Rule]Null,$tensorQ\[Rule]True,$tensorQ\[Rule]False} return the keys of {all forms,forms that have tensors associated with them,forms that do not have a tensor associated to them}";*)
(*rules to move back and forth between xAct scalars and ordinary variables*)

(*ToXForm::usage="ToXForm (Rule) converts an ordinary symbol form to an xAct type form (eg. form1\[Rule]form1[])";
ToForm::usage="ToCoord (Rule) converts xAct type forms to ordinary symbol forms (eg. form1[]\[Rule]form1)";*)
(*set functions*)
(*SetConstantSymbols::usage="SetConstantSymbols[] defines the constant symbols using the data from $olution";
SetScalarFunctions::usage="SetScalarFunctions[] defines the scalar functions using the data from $olution";
SetChart::usage="SetChart[] defines the chart using the data from $olution";
SetForms::usage="SetForms[] defines the forms using the data from $olution";
SetTensors::usage="SetTensors[] defines the tensors using the data from $olution";
SetupMetric::usage="SetMetric[] defines the metric using the data from $solution";
SetFrameBundle::usage="SetFrameBundle[] defines the frame bundle using the data from $olution";
SetSpinStructure::usage="SetSpinStructure[] defines the spin structure using the data from $olution";
SetSpinConnection::usage="SetSpinConnection[] defines the spin connection using the data from $olution";
SetFrameForms::usage="SetFrameForms[] defines the frame forms using the data from $olution";
SetSpinors::usage="SetSpinors[] defines the spinors using the data from $olution";
SetBases::usage="SetBases[] defines the bases (except the coordinated curved chart that should be defined with SetChart[]) using the data from $olution";*)
(*set environment: calls the other set functions in the correct order*)
(*SetSolution::usage="SetSolution[SetForSusyQ\[Rule]boolean] calls all the set functions in the correct order | The option {SetForSusyQ\[Rule]True,SetForSusyQ\[Rule]False} calls set functions {including,excluding} supersymmetric quantities";*)
(*generate matrices corresponding to various tensors from raw object to be fed in the calculation functions*)

(*calculate functions*)

(*save and load function*)
(*PrintSolutions::usage="PrintSolutions[]";
GetSolution::usage="GetSolution[solutionNameString,SolutionType\[Rule](Initial||Raw||Final)]";
CleanSolution::usage="CleanSolution[]";
*)
(*append functions*)
(*AppendConstantSymbols::usage="Explain the usage here...";
AppendRules::usage="Explain the usage here...";
AppendTensors::usage="Explain the usage here...";
*)
(*miscellenous*)


(*GenChangeContextRule::usage="GenChangeContextRule[newContext,IncludeCoordintesQ\[Rule]boolean]";*)


(*options*)
(*SetForSusyQ::usage="Explain the usage here...";
SetSolutionQ::usage="Explain the usage here...";
SimplificationMethod::usage="Explain the usage here...";
CalculateRiemannQ::usage="Explain the usage here...";
AllQ::usage="Explain the usage here...";
ParallelQ::usage="Explain the usage here...";
SolutionType::usage="Explain the usage here...";
$tensorQ::usage="Explain the usage here...";
IncludeCoordinatesQ::usage="Explain the usage here...";
PrintContextQ::usage="Explain the usage here...";
*)(*option values*)
(*Initial::usage="Explain the usage here...";
Raw::usage="Explain the usage here...";
Final::usage="Explain the usage here...";
*)
(*Internal variables*)
$infinity::usage="$infinity is an internal variable that can be used to set the range of a non-compact coordinate";
(*$startMonitoring::usage="$startMonitoring is an internal variable that is used to determine in seconds when to start monitoring a calculation | The default values is 1";*)
$blueprint::usage="$blueprint is an internal association that can be used as a template when populating $olution";
$olution::usage="$olution is an internal association that stores the data for the current working solution";
$FieldsXVersionExpected::usage="Explain the usage here...";
$Version::usage="Explain the usage here...";
$prefix::usage="Explain the usage here...";

(*Internal keys*)
$info::usage="Explain the usage here...";
$name::usage="Explain the usage here...";
$identifier::usage="Explain the usage here...";
$coordinateSystem::usage="Expalin the usage here...";
$ignature::usage="Explain the usage here...";
$reference::usage="Explain the usage here...";
$comment::usage="Explain the usage here...";
$context::usage="Explain the usage here...";
$usyQ::usage="Explain the usage here...";
$manifold::usage="Explain the usage here...";
$ymbol::usage="Explain the usage here...";
$dimension::usage="Explain the usage here...";
$index::usage="Explain the usage here...";
$basis::usage="Explain the usage here...";
$flat::usage="Explain the usage here...";
$curved::usage="Explain the usage here...";
$spin::usage="Explain the usage here...";
$internal::usage="Explain the usage here...";
$coordinate::usage="Explain the usage here...";
$color::usage="Explain the usage here...";
$constant::usage="Explain the usage here...";
$function::usage="Explain the usage here...";
$assumption::usage="Explain the usage here...";
$scalar::usage="Explain the usage here...";
$print::usage="Explain the usage here...";
$internalRank::usage="Explain the usage here...";
$form::usage="Explain the usage here...";
$rank::usage="Explain the usage here...";
$expression::usage="Explain the usage here...";
$tensor::usage="Explain the usage here...";
$value::usage="Explain the usage here...";
$ymmetry::usage="Explain the usage here...";
$metric::usage="Explain the usage here...";
$igndet::usage="Explain the usage here...";
$covd::usage="Explain the usage here...";
$ds2::usage="Explain the usage here...";
$christoffel::usage="Explain the usage here...";
$riemann::usage="Explain the usage here...";
$ricci::usage="Explain the usage here...";
$ricciScalar::usage="Explain the usage here...";
$det::usage="Explain the usage here...";
$epsilon::usage="Explain the usage here...";
$frame::usage="Explain the usage here...";
$vielbein::usage="Explain the usage here...";
$spinConnection::usage="Explain the usage here...";
$gamma::usage="Explain the usage here...";
$flatGammaU::usage="Explain the usage here...";
$pinor::usage="Explain the usage here...";
$type::usage="Explain the usage here...";
$rule::usage="Explain the usage here...";

(*Reserved words*)
Euclidean::usage="Explain the usage here...";
Lorentzian::usage="Explain the usage here...";
ChangeContextQ::usage="Explain the usage here...";
ChangeCoordQ::usage="Explain the usage here...";
ParallelSimplify::usage="Explain the usage here...";

(*Miscellaneous functions*)
ToXCoord::usage="ToXCoord converts ordinary symbol coordinates to xAct type coordinates, for example coord1\[Rule]coord1[]";
ToCoord::usage="ToCoord converts xAct type coordinates to ordinary symbol coordinates, for example coord1[]\[Rule]coord1";
(*GenRandomRealRule::usage="GenRandomRealRule[assumption]";*)
GenFunctionRule::usage="GenFunctionRule[funcionAndVariables,expression]";
GenContext::usage="GenContext[solutionNameString]";
ToValues2::usage="Explain the usage here...";
GetCNumber::usage="Explain the usage here...";
TTensor::usage="Explain the usage here...";
PrintRule::usage="Explain the usage here...";
ListMap::usage="Explain the usage here...";
ExtractPrefactor::usage="Explain the usage here...";
PlusSimplify::usage="Explain the usage here...";
PlusSeries::usage="Explain the usage here...";

(*Validate functions*)
ValidateInfo::usage="ValidateInfo[] validates the user input in $olution[$info]";
ValidateManifold::usage="ValidateManifold[] validates the user input in $olution[$manifold]";
ValidateBasis::usage="ValidateBasis[] validates the user input in $olution[$basis]";
ValidateConstant::usage="ValidateConstant[] validates the user input in $olution[$constant]";
ValidateFunction::usage="ValidateFunction[] validates the user input in $olution[$function]";
ValidateAssumption::usage="ValidateAssumption[] validates the user input in $olution[$assumption]";
ValidateScalar::usage="ValidateAssumption[] validates the user input in $olution[$scalar]";
ValidateForm::usage="ValidateAssumption[] validates the user input in $olution[$form]";
ValidateTensor::usage="ValidateAssumption[] validates the user input in $olution[$tensor]";
ValidateMetric::usage="ValidateAssumption[] validates the user input in $olution[$metric]";
ValidateFrame::usage="ValidateAssumption[] validates the user input in $olution[$frame]";
ValidateGamma::usage="ValidateAssumption[] validates the user input in $olution[$gamma]";
ValidateSpinor::usage="ValidateAssumption[] validates the user input in $olution[$pinor]";

(*Set functions*)
SetInfo::usage=
"SetInfo[name,identifier,coordinateSystem,Lorentzian||Euclidean,dimension] sets and validates $olution[$info], without setting references and comment\n"<>
"SetInfo[name,identifier,coordinateSystem,Lorentzian||Euclidean,dimension,{{refName,refLink},...},comment] sets and validates $olution[$info]";
SetManifold::usage=
"SetManifold[symbol] sets and validates $olution[$manifold], using the default index list, and fetching the dimension from $olution[$info,$dimension]. Validation will fail if $olution[$info] has not been set beforehand\n"<>
"SetManifold[symbol,{index1,index2,...}] sets and validates $olution[$manifold], fetching the dimension from $olution[$info,$dimension]. Validation will fail if $olution[$info] has not been set beforehand\n"<>
"SetManifold[symbol,dimension,{index1,index2,...}] sets and validates $olution[$manifold]. Validation will fail if $olution[$info] has not been set beforehand";
SetBasis::usage=
"SetBasis[curved,{coord1,coord2,...}] sets and validates the curved basis in $olution[$basis], using the default color and cnumbers. Fetches the curved index list from $olution[$manifold,$index]. Doesn't set flat, spin and internal bases. Validation will fail if $olution[$manifold] has not been set beforehand\n"<>
"SetBasis[curved,{coord1,coord2,...},flat,spin] sets and validates the curved, flat and spin bases in $olution[$basis], using the default colors, cnumbers and indices. Fetches the curved index list from $olution[$manifold,$index]. Doesn't set internal basis. Validation will fail if $olution[$manifold] has ot been set beforehand\n"<>
"SetBasis[curved,{coord1,coord2,...},flat,spin,internal] sets and validates the {curved,flat,spin,internal} bases in $olution[$basis], using the default colors, cnumbers and indices. Fetches the curved index list from $olution[$manifold,$index]. Validation will fail if $olution[$manifold] has ot been set beforehand";
SetConstant::usage=
"SetConstant[{constant1,constant2,...}] sets and validates $olution[$constant]";
SetFunction::usage=
"SetFunction[{function1[argument1,argument2,...],...}] sets and validates $olution[$function]";
SetAssumption::usage=
"SetAssumption[{coordAsump1,coordAsump2,...},{constAsump1,constAsump2,...},{funcAsump1,funcAsump2,...}] sets and validates $olution[$assumption]. Function assumptions are inputed without arguments for the function, for example f \[Element] Reals, instead of f[coord1,coord2,...] \[Element] Reals";
SetScalar::usage=
"SetScalar[{key1,key2,...},{internalRank1,internalRank2,...}] sets and validates $olution[$scalar] using the default scalar symbols and printing options\n"<>
"SetScalar[{key1,key2,...},{symbol1,symbol2,...},{print1,print2,...},{internalRank1,internalRank2,...}] sets and validates $olution[$scalar]";
SetForm::usage=
"SetForm[{key1,key2,...},{rank1,rank2,...},{internalRank1,internalRank2,...}] sets and validates $olution[$form] using the default form symbols and printing options\n"<>
"SetForm[{key1,key2,...},{symbol1,symbol2,...},{print1,print2,...},{rank1,rank2,...},{internalRank1,internalRank2,...}] sets and validates $olution[$form]";
SetTensor::usage=
"SetTensor[] sets and validates $olution[$tensor]. Fetches the keys, ranks, internal ranks and symmetries from $olution[$form]. Uses the default tensor symbols and printing options\n"<>
"SetTensor[{symbol1,symbol2,...},{print1,print2,...}] sets and validates $olution[$tensor]. Fetches the keys, ranks, internal ranks and symmetries from $olution[$form]\n"<>
"SetTensor[{key1,key2,...},{rank1,rank2,...},{internalRank1,internalRank2,...},{symmetry1,symmetry2,...}] sets and validates $olution[$tensor] using the default tensor symbols and printing options\n"<>
"SetTensor[{key1,key2,...},{symbol1,symbol2,...},{print1,print2,...},{rank1,rank2,...},{internalRank1,internalRank2,...},{symmetry1,symmetry2,...}] sets and validates $olution[$tensor]";
SetMetric::usage=
"SetMetric[{curvedSymbol,curvedPrint,curvedCovD}] sets and validates $olution[$metric]. Leaves $olution[$metric,{$flat,$internal}] = $blueprint[$metric,{$flat,$internal}]. TODO: Validation of internal metric\n"<>
"SetMetric[{curvedSymbol,curvedPrint,curvedCovD},{flatSymbol,flatPrint}] sets and validates $olution[$metric]. Leaves $olution[$metric,$internal] = $blueprint[$metric,$internal]. TODO: Validation of internal metric";
SetFrame::usage=
"SetFrame[{{frameSymbol1,frameSymbol2,...},{framePrint1,framePirnt2,...}},{vielbeinSymbol,vielbeinPrint},{spinConnectionSymbol,spinConnectionPrint}] sets $olution[$frame]. TODO: Validation";
SetGamma::usage=
"SetGamma[] sets $olution[$gamma] in 5 dimensions, using the 5 4x4 Lorentzian gamma matrices presented in Freedman and van-Proyen's Supergravity book. Prepares composite gamma matrices up to rank 3. TODO: Include dimensions and user setup options and provide validation";
SetSpinor::usage=
"SetSpinor[{key1,key2,...},{symbol1,symbol2,...},{print1,print2,...},{type1,type2,...},{internalRank1,internalRank2,...}] sets $olution[$pinor]. TODO: Validation";

(*Load functions*)
ContextMergeSymbol::usage="Explain...";
LoadManifold::usage="Explain...";
LoadChart::usage="Explain...";
LoadConstant::usage="Explain...";
LoadFunction::usage="Explain...";
LoadScalar::usage="Explain...";
LoadForm::usage="Explain...";
LoadTensor::usage="Explain...";
LoadMetric::usage="Explain...";
LoadFrameBundle::usage="Explain...";
LoadSpinStructure::usage="Explain...";
LoadSpinConnection::usage="Explain...";
LoadFrameForm::usage="Explain...";
LoadSpinor::usage="Explain...";
LoadBasis::usage="Explain...";

(*LoadAppend functions*)
LoadAppendConstant::usage="Explain...";
LoadAppendFunction::usage="Explain...";
LoadAppendScalar::usage="Explain...";
LoadAppendForm::usage="Explain...";
LoadAppendTensor::usage="Explain...";
LoadAppendSpinor::usage="Explain...";
LoadAppendRule::usage="Explain...";
LoadAppendAssumption::usage="Explain...";

(*UnloadDelete functions*)
UnloadDeleteConstant::usage="Explain...";
UnloadDeleteFunction::usage="Explain...";
UnloadDeleteScalar::usage="Explain...";
UnloadDeleteForm::usage="Explain...";
UnloadDeleteTensor::usage="Explain...";
UnloadDeleteSpinor::usage="Explain...";
UnloadDeleteRule::usage="Explain...";
UnloadDeleteAssumption::usage="Explain...";

(*Database functions*)
ValidateSaveSolution::usage="Explain...";
SaveSolution::usage="Explain...";
SaveCoordinateTransformation::usage="Explain...";
ChangeContext::usage="Explain...";
Load$olution::usage="Explain...";
LoadSolution::usage="Explain...";
ButtonLoadSolution::usage="Explain...";
ValidateSolution::usage="Explain...";
DeleteSolution::usage="Explain...";
ButtonDeleteSolution::usage="Explain...";
SaveGenerator::usage="Explain...";
SaveExample::usage="Explain...";
ToInitial::usage="Explain...";
AttachTVs::usage="Explain...";
Solution::usage="Explain...";
AllSolutions::usage="Explain...";
Print$olution::usage="Explain...";
PrintSolution::usage="Explain...";
ChangeCoord::usage="Explain...";
ChangeXCoord::usage="Explain...";

(*Gen tensor table functions*)
GenerateMetric::usage="Explain...";
GenerateFormTensor::usage="Explain...";
GenerateVielbein::usage="Explain...";
Set$metric::usage="Explain...";

(*Print compute functions*)
PrintComputeMetric::usage="Explain...";
PrintComputeTensor::usage="Explain...";

(*Compute functions*)
MapSimplify::usage="Explain...";
ParallelMapSimplify::usage="Explain...";
PrintMapSimplify::usage="Explain...";
PrintParallelMapSimplify::usage="Explain...";
PrintParallelMapSimplify2::usage="Explain...";
PlusParallelMapSimplify::usage="Explain...";
Compute::usage="Explain...";

(*Prep tensor functions*)
(*PrepareMetric::usage="Explain...";
PrepareChristoffel::usage="Explain...";
PrepareRiemann::usage="Explain...";
PrepareRicci::usage="Explain...";
PrepareTensor1::usage="Explain...";
PrepareTensor2::usage="Explain...";
PrepareTensor3::usage="Explain...";
PrepareSpinConnection::usage="Explain...";
PrepareTensor::usage="Explain...";*)

(*Calculate tensor functions*)
(*ApplySimplify::usage="Explain...";
ApplyParallelSimplify::usage="Explain...";
CalculateMetric::usage="Explain...";
CalculateChristoffel::usage="Explain...";
CalculateRiemann::usage="Explain...";
CalculateRicci::usage="Explain...";
CalculateTensor1::usage="Explain...";
CalculateTensor2::usage="Explain...";
CalculateTensor3::usage="Explain...";
CalculateVielbein::usage="Explain...";
CalculateSpinConnection::usage="Explain...";
CalculateTensor::usage="Explain...";

CalculateFormTensor::usage="Explain...";
CalculateFrame::usage="Expliain...";
CalculateGamma::usage="Explain...";
CalculateRank2Tensor::usage="Explain...";*)

(*Equations*)
Eom5DN2Spin2::usage="Eom5DN2Spin2[metric,fieldStrength,params,chart]";
Eom5DN2Spin1::usage="Eom5DN2Spin1[metric,fieldStrength,params,chart]";
Bps5DN2Spin32::usage="Bps5DN2Spin32[{metric,flatMetric,spinConnection},{gaugeField,fieldStrength},params,spinor,{chart,flatBasis,spinBasis}]";
Eom4DN0Spin2::usage="Explain the usage here...";
Eom4DN0Spin1::usage="Explain the usage here...";


(* ::Input::Initialization:: *)
$blueprint=<|
$info-><|$name->String,$identifier->String,$coordinateSystem->String,$ignature->(Lorentzian||Euclidean),$dimension->Integer,$reference-><|String->Hyperlink|>,$comment->String|>,
$manifold-><|$ymbol->Symbol,$dimension->Integer,$index->List[Symbol]|>,
$basis-><|
$curved-><|$ymbol->Symbol,$color->RGBColor,$index->List[Symbol],$coordinate-><|Integer->Symbol|>|>,
$flat-><|$ymbol->Symbol,$color->RGBColor,$index->List[Symbol]|>,
$spin-><|$ymbol->Symbol,$color->RGBColor,$index->List[Symbol]|>,
$internal-><|$ymbol->Symbol,$color->RGBColor,$index->List[Symbol]|>
|>,
$constant-><|$ymbol->List[Symbol]|>,
$function-><|$ymbol->List[Symbol]|>,
$assumption-><|
$coordinate->List[(Less||LessEqual||Greater||GreaterEqual||Inequality||Element)],
$constant->List[(Less||LessEqual||Greater||GreaterEqual||Inequality||Element)],
$function->List[(Less||LessEqual||Greater||GreaterEqual||Inequality||Element)]
|>,
$scalar-><|Symbol-><|$ymbol->Symbol,$print->String,$internalRank->Integer,$value->Rule|>|>,
$form-><|Symbol-><|$ymbol->Symbol,$print->String,$rank->Integer,$internalRank->Integer,$expression->(Plus||Times||Power||Diff)|>|>,
$tensor-><|Symbol-><|$ymbol->Symbol,$print->String,$rank->Integer,$internalRank->Integer,$ymmetry->(Symmetric||Antisymmetric||Null),$value->Association|>|>,
$metric-><|
$curved-><|
$ignature->(1||-1),$covd->Symbol,$ds2->Plus,
$tensor-><|$ymbol->Symbol,$print->String,$value->Association|>,
$christoffel-><|$ymbol->Symbol,$value->Association|>,
$riemann-><|$ymbol->Symbol,$value->Association|>,
$ricci-><|$ymbol->Symbol,$value->Association|>,
$ricciScalar-><|$ymbol->Symbol,$value->Rule|>,
$det-><|$ymbol->Symbol,$value->Rule|>
|>,
$flat-><|
$tensor-><|$ymbol->Symbol,$print->String,$value->Association|>
|>,
$internal-><|
$ignature->(1||-1),$covd->Symbol,$ds2->Plus,
$tensor-><|$ymbol->Symbol,$print->String,$value->Association|>,
$christoffel-><|$ymbol->Symbol,$value->Association|>,
$riemann-><|$ymbol->Symbol,$value->Association|>,
$ricci-><|$ymbol->Symbol,$value->Association|>,
$ricciScalar-><|$ymbol->Symbol,$value->Rule|>,
$det-><|$ymbol->Symbol,$value->Rule|>
|>
|>,
$frame-><|
$form-><|Integer-><|$ymbol->Symbol,$print->String,$expression->(Plus||Times||Power||Diff)|>|>,
$vielbein-><|$ymbol->Symbol,$print->String,$value->Association|>,
$spinConnection-><|$ymbol->Symbol,$print->String,$value->Association|>
|>,
$gamma-><|
$flatGammaU-><|Integer->List[List[(Integer||Real||Rational||Complex)]]|>,
$flat-><|Integer-><|$ymbol->Symbol,$value->Association|>|>,
$curved-><|Integer-><|$ymbol->Symbol,$value->Association|>|>,
$internal-><|Integer-><|$ymbol->Symbol,$value->Association|>|>
|>,
$pinor-><|Symbol-><|$ymbol->Symbol,$print->String,$type->(Dirac||Majorana),$internalRank->Integer,$value->Association|>|>,
$rule-><||>
|>;

$olution=$blueprint;


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
$DefInfoQ=$UndefInfoQ=$CVVerbose=False;
$CVSimplify=Simplify;
$PrePrint=ScreenDollarIndices;
$PrecomputeGammaMatrixProducts=False;
SetDirectory[FileNameJoin[{$UserBaseDirectory,"Applications","SolutionsX","Data"} ] ];
(*$startMonitoring=1;*)
Off[Attributes::ssle];
UseDimensionStart[ ];
CommutativityOfProduct[CircleTimes ]^="Commutative";
Off[PrintAsCharacter::argx];
Off[ToCanonical::cmods];
SetOptions[Simplify,TimeConstraint->Infinity];
Needs["TypeSystem`"];
Needs["Dataset`"];
Dataset`$DatasetTargetRowCount=10000;
Dataset`$DatasetDefaultOptions={Alignment->{Left,Baseline},Background->None,DatasetDisplayPanel->{},DatasetTheme->Automatic,HeaderAlignment->{Left,Baseline},HeaderBackground->Automatic,HeaderDisplayFunction->Automatic,HeaderSize->Automatic,HeaderStyle->None,HiddenItems->None,ItemDisplayFunction->Automatic,ItemSize->10000,ItemStyle->None,MaxItems->Automatic,Method->Automatic,ScrollPosition->{1,1}};
$prefix=Default;


(* ::Input::Initialization:: *)
(****************************** 2. Main code for SolutionsX *****************************)


(* ::Input::Initialization:: *)
GenRandomRealRule[assumption_ ]:=Module[{as=assumption,ls},
ls=Level[as,1 ];
Return[ls[[(Length@ls+1)/2]]->RandomReal[{ls[[1]],ls[[-1]]} ] ] ]


(* ::Input::Initialization:: *)
GenFunctionRule[fn_,expr_ ]:=Head@fn->Function[Evaluate@Level[fn,1 ],Evaluate@expr ]


GenContext[]:=Module[{
name=$olution[$info,$name],
identifier=$olution[$info,$identifier],
coordinateSystem=$olution[$info,$coordinateSystem],
signature=ToString[$olution[$info,$ignature]]},
Return[name<>"`"<>identifier<>"`"<>coordinateSystem<>"`"<>signature<>"`"]
]


(* ::Input::Initialization:: *)
FS[expr_ ]:=Style[ToString@TraditionalForm@expr,FontColor->Purple ]
FB[expr_ ]:=Style[ToString@expr,FontFamily->"Source Code Pro Semibold"]


(* ::Input::Initialization:: *)
CTensor[tensorAndInd_ ]:=Module[{ts=Head@tensorAndInd,
ti=Level[tensorAndInd,1 ],
curved=$olution[$basis,$curved,$ymbol ],
flat=$olution[$basis,$flat,$ymbol ],
spin=$olution[$basis,$spin,$ymbol ],
cT,fT,sT},
If[BasisQ/@{curved,flat,spin}=={True,True,True},
cT=Table[$olution[$basis,$curved,$index ][[ii]]->$olution[$basis,$curved,$ymbol ],{ii,1,Length@$olution[$basis,$curved,$index ]} ];
fT=Table[$olution[$basis,$flat,$index ][[ii]]->$olution[$basis,$flat,$ymbol ],{ii,1,Length@$olution[$basis,$flat,$index ]} ];
sT=Table[$olution[$basis,$spin,$index ][[ii]]->$olution[$basis,$spin,$ymbol ],{ii,1,Length@$olution[$basis,$spin,$index ]} ];
Return[CTensor[ToValues@ComponentArray@ToBasis[curved ]@ToBasis[flat ]@ToBasis[spin ]@tensorAndInd,ti/.cT/.fT/.sT ]@@ti ] ];
If[BasisQ/@{curved,flat,spin}=={True,False,False},
cT=Table[$olution[$basis,$curved,$index ][[ii]]->$olution[$basis,$curved,$ymbol ],{ii,1,Length@$olution[$basis,$curved,$index ]} ];
Return[CTensor[ToValues@ComponentArray@ToBasis[curved ]@tensorAndInd,ti/.cT,0 ]@@ti ] ]; ]


ToValues2[expr_]:=Module[{e=expr},Return[ToValues[e]/.$olution[$metric,$curved,$det,$value]/.$olution[$metric,$curved,$ricciScalar,$value]];]


TTensor[tensorAndInd_]:=CTensor[tensorAndInd][[0,1]];


GetCNumber[basis_]:=(
If[TrueQ[basis==$olution[$basis,$curved,$ymbol]],
Return[
Keys@$olution[$basis,$curved,$coordinate]
]
];
If[TrueQ[basis==$olution[$basis,$flat,$ymbol]],
Return[
Keys@$olution[$frame,$form]
]
];
If[TrueQ[basis==$olution[$basis,$spin,$ymbol]],
Return[
Table[jj,{jj,1,DimOfVBundle[Symbol@@{"Spin"<>ToString[$olution[$manifold,$ymbol]]}]}]
]
];
)


(* ::Input::Initialization:: *)
ToXCoord:=Join[
Table[(Values@$olution[$basis,$curved,$coordinate])[[ii]]->(Values@$olution[$basis,$curved,$coordinate])[[ii]][],{ii,1,Length@(Values@$olution[$basis,$curved,$coordinate])}],
Table[(Values@$olution[$basis,$curved,$coordinate])[[ii]][]->(Values@$olution[$basis,$curved,$coordinate])[[ii]][],{ii,1,Length@(Values@$olution[$basis,$curved,$coordinate])}],
Table[(Values@$olution[$basis,$curved,$coordinate])[[ii]][][]->(Values@$olution[$basis,$curved,$coordinate])[[ii]][],{ii,1,Length@(Values@$olution[$basis,$curved,$coordinate])}]
]
ToCoord:=Table[(Values@$olution[$basis,$curved,$coordinate])[[ii]][]->(Values@$olution[$basis,$curved,$coordinate])[[ii]],{ii,1,Length@(Values@$olution[$basis,$curved,$coordinate])}]


PrintRule[]:=TableForm[Map[TableForm,$olution[$rule]]/.Association[x__]:>List[x],TableSpacing->{10,10}]


ListMap[function_,list_]:=Module[{
tmp
},
tmp=list/.List[x__]:>Association[x];
tmp=AssociationMap[Reverse,tmp];
tmp=KeyMap[function,tmp];
tmp=AssociationMap[Reverse,tmp];
tmp=tmp/.Association[x__]:>List[x];
Return[tmp];
]


ExtractPrefactor[expr_]:=Module[{
timesList,
plusList,
leafList,
maxLeaf
},
If[TrueQ[Head@expr==Plus],
Return[{1,expr}];
,
If[TrueQ[Head@expr==Times],
timesList=Level[expr,1];
leafList=LeafCount/@timesList;
maxLeaf=First@Position[leafList,Max[leafList]];
plusList=Take[timesList,maxLeaf][[1]];
Return[{Times@@Delete[timesList,maxLeaf],plusList}];
,
Return[{1,expr}];
];
];
]


PlusSimplify[expr_,{ps1_,ps2_},{s1_,s2_}]:=Module[{
f1=ExtractPrefactor[expr][[1]],
f2=ExtractPrefactor[expr][[2]],
li,
tot,
max=10
},
If[TrueQ[Head@f2==Plus],
li=Level[f2,1];
If[Length@li>max,
li=ParallelMap[ps1,li,Method->Automatic,ProgressReporting->True];
li=ParallelMap[ps2,li,Method->Automatic,ProgressReporting->True];
,
li=Map[ps1,li];
li=Map[ps2,li];
];
tot=f1 Total[li];
tot=s1@tot;
tot=s2@tot;
Return[tot];
,
Return[expr//s1//s2];
]
]


PlusSeries[expr_,arg_,simplify_,max_]:=Module[{
f1=ExtractPrefactor[expr][[1]],
f2=ExtractPrefactor[expr][[2]],
li,
tot
},
If[TrueQ[Head@f2==Plus],
li=Level[f2,1];
If[Length@li>max,
li=ParallelMap[Normal@simplify@Series[#,arg]&,li,Method->Automatic,ProgressReporting->True];
,
li=Map[Normal@simplify@Series[#,arg]&,li];
];
tot=f1 Total[li];
tot=(Normal@simplify@Series[#,arg]&)@tot;
Return[tot];
,
Return[expr];
]
]


ValidateInfo::basic="`1` should be `2`";
ValidateInfo::keys="The keys of `1` should be `2`";
ValidateInfo::elementsOrSame="The elements of the association `1` should be of the type `2` or `3` should be the same as `4`";
ValidateInfo::basicOrSame="`1` should be `2` or `3` should be the same as `4`";


ValidateInfo[]:=Module[{
s=$olution[$info],
b=$blueprint[$info]
},
If[TrueQ[Head@s==Head@b]==False,
Catch@Throw@Message[ValidateInfo::basic,FB@"$olution[$info]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s==Keys@b]==False,
Catch@Throw@Message[ValidateInfo::keys,FB@"$olution[$info]",FB@Keys@b];,
If[TrueQ[Head@s[$name]==b[$name]]==False,
Catch@Throw@Message[ValidateInfo::basic,FB@"$olution[$info,$name]",FB@"String"];Abort[];,
If[True![Head@s[$identifier]==b[$identifier]]==False,
Catch@Throw@Message[ValidateInfo::basic,FB@"$olution[$info,$identifier]",FB@"String"];Abort[];,
If[TrueQ[Head@s[$coordinateSystem]==b[$coordinateSystem]]==False,
Catch@Throw@Message[ValidateInfo::basic,FB@"$olution[$info,$coordinateSystem]",FB@"String"];Abort[];,
If[TrueQ[MemberQ[Level[b[$ignature],1],s[$ignature]]]==False,
Catch@Throw@Message[ValidateInfo::basic,FB@"$olution[$info,$ignature]",FB@"(Euclidean||Lorentizan)"];Abort[];,
If[TrueQ[Head@s[$dimension]==b[$dimension]]==False,
Catch@Throw@Message[ValidateInfo::basic,FB@"$olution[$info,$dimension]",FB@"Integer"];Abort[];,
If[TrueQ[Head@s[$reference]==Head@b[$reference]]==False,
Catch@Throw@Message[ValidateInfo::basic,FB@"$olution[$info,$reference]",FB@"Association"];Abort[];,
If[TrueQ[Table[Head/@(s[$reference]/.Association[x__]->List[x])[[ii]],{ii,1, Length@(s[$reference]/.Association[x__]->List[x])}]==Table[(b[$reference]/.Association[x__]->List[x])[[1]],{ii,1,Length@(s[$reference]/.Association[x__]->List[x])}]||s[$reference]==b[$reference]]==False,
Catch@Throw@Message[ValidateInfo::elementsOrSame,FB@"$olution[$info,$reference]",FB@"String \[Rule] Hyperlink",FB@"$olution[$info,$reference]",FB@"$blueprint[$info,$reference]"];Abort[];,
If[TrueQ[Head@s[$comment]==b[$comment]||s[$comment]==b[$comment]]==False,
Catch@Throw@Message[ValidateInfo::basicOrSame,FB@"$olution[$info,$comment]",FB@"String",FB@"$olution[$info,$comment]",FB@"$blueprint[$info,$comment]"];Abort[];
];
];
];
];
];
];
];
];
];
];
]


ValidateManifold::before="`1` should be set before `2`";
ValidateManifold::basic="`1` should be `2`";
ValidateManifold::same="`1` should be the same as `2`";
ValidateManifold::elements="The elements of the list `1` should be of the type `2`";
ValidateManifold::keys="The keys of `1` should be `2`";


ValidateManifold[]:=Module[{
s=$olution[$manifold],
b=$blueprint[$manifold]
},
If[TrueQ[$olution[$info]==$blueprint[$info]]==True,
Catch@Throw@Message[ValidateManifold::before,FB@"$olution[$info]",FB@"$olution[$manifold]"];Abort[];,
If[TrueQ[Head@s==Head@b]==False,
Catch@Throw@Message[ValidateManifold::basic,FB@"$olution[$manifold]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s==Keys@b]==False,
Catch@Throw@Message[ValidateManifold::keys,FB@"$olution[$manifold]",FB@Keys@b];Abort[];,
If[TrueQ[Head@s[$ymbol]==b[$ymbol]]==False,
Catch@Throw@Message[ValidateManifold::basic,FB@"$olution[$manifold,$ymbol]",FB@"Symbol"];Abort[];,
If[TrueQ[Head@s[$dimension]==b[$dimension]]==False,
Catch@Throw@Message[ValidateManifold::basic,FB@"$olution[$manifold,$dimension]",FB@"Integer"];Abort[];,
If[TrueQ[s[$dimension]==$olution[$info,$dimension]]==False,
Catch@Throw@Message[ValidateManifold::same,FB@"$olution[$manifold,$dimension]",FB@"$olution[$info,$dimension]"];Abort[];,
If[TrueQ[Head/@s[$index]==Table[b[$index][[1]],{ii,1,Length@s[$index]}]]==False,
Catch@Throw@Message[ValidateManifold::elements,FB@"$olution[$manifold,$index]",FB@"Symbol"];Abort[];
];
];
];
];
];
];
];
]


ValidateBasis::basic="`1` should be `2`";
ValidateBasis::before="`1` should be set before `2`";
ValidateBasis::keys="The keys of `1` should be `2`";
ValidateBasis::elements="The elements of the list `1` should be of the type `2`";
ValidateBasis::same="`1` should be the same as `2`";
ValidateBasis::values="The values of `1` should be `2`";
ValidateBasis::length="The length of `1` should be the same as `2`";
ValidateBasis::successive="The keys of `1` should be succesive `2`'s";
ValidateBasis::basicOrSame="`1` should be `2` or `3` should be the same as `4`";
ValidateBasis::elementsOrSame="The elements of the list `1` should be of the type `2` or `3` should be the same as `4`";


ValidateBasis[]:=Module[{
s=$olution[$basis],
b=$blueprint[$basis],
kc=Keys@$olution[$basis,$curved,$coordinate]
},
If[TrueQ[$olution[$manifold]==$blueprint[$manifold]]==True,
Catch@Throw@Message[ValidateBasis::before,FB@"$olution[$manifold]",FB@"$olution[$basis]"];Abort[];,
If[TrueQ[Head@s==Head@b]==False,
Catch@Throw@Message[ValidateBasis::basic,FB@"$olution[$basis]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s==Keys@b]==False,
Catch@Throw@Message[ValidateBasis::keys,FB@"$olution[$basis]",FB@Keys@b];Abort[];,
If[TrueQ[Head@s[$curved]==Head@b[$curved]]==False,
Catch@Throw@Message[ValidateBasis::basic,FB@"$olution[$basis,$curved]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s[$curved]==Keys@b[$curved]]==False,
Catch@Throw@Message[ValidateBasis::keys,FB@"$olution[$basis,$curved]",FB@Keys@b[$curved]];Abort[];,
If[TrueQ[Head@s[$curved,$ymbol]==b[$curved,$ymbol]]==False,
Catch@Throw@Message[ValidateBasis::basic,FB@"$olution[$basis,$curved,$ymbol]",FB@"Symbol"];Abort[];,
If[TrueQ[Head@s[$curved,$color]==b[$curved,$color]]==False,
Catch@Throw@Message[ValidateBasis::basic,FB@"$olution[$basis,$curved,$color]",FB@"RGBColor"];Abort[];,
If[TrueQ[Head/@s[$curved,$index]==Table[b[$curved,$index][[1]],{ii,1,Length@s[$curved,$index]}]]==False,
Catch@Throw@Message[ValidateManifold::elements,FB@"$olution[$basis,$curved,$index]",FB@"Symbol"];Abort[];,
If[TrueQ[s[$curved,$index]==$olution[$manifold,$index]]==False,
Catch@Throw@Message[ValidateManifold::same,FB@"$olution[$basis,$curved,$index]",FB@"$olution[$manifold,$index]"];Abort[];,
If[TrueQ[Head@s[$curved,$coordinate]==Head@b[$curved,$coordinate]]==False,
Catch@Throw@Message[ValidateBasis::basic,FB@"$olution[$basis,$curved,$coordinate]",FB@"Association"];Abort[];,
If[TrueQ[Head/@Keys@s[$curved,$coordinate]==Table[(Keys@b[$curved,$coordinate])[[1]],{ii,1,Length@Keys@s[$curved,$coordinate]}]]==False,
Catch@Throw@Message[ValidateBasis::keys,FB@"$olution[$basis,$curved,$coordinate]",FB@"Integer"];Abort[];,
If[TrueQ[Table[(Keys@$olution[$basis,$curved,$coordinate])[[ii+1]]-(Keys@$olution[$basis,$curved,$coordinate])[[ii]],{ii,1,Length@(Keys@$olution[$basis,$curved,$coordinate])-1}]==Table[1,Length@(Keys@$olution[$basis,$curved,$coordinate])-1]]==False,
Catch@Throw@Message[ValidateBasis::successive,FB@"$olution[$basis,$curved,$coordinate]",FB@"Integer"];Abort[];,
If[TrueQ[Head/@Values@s[$curved,$coordinate]==Table[(Values@b[$curved,$coordinate])[[1]],{ii,1,Length@Values@s[$curved,$coordinate]}]]==False,
Catch@Throw@Message[ValidateBasis::values,FB@"$olution[$basis,$curved,$coordinate]",FB@"Symbol"];Abort[];,
If[TrueQ[Length@s[$curved,$coordinate]==$olution[$manifold,$dimension]]==False,
Catch@Throw@Message[ValidateBasis::length,FB@"$olution[$basis,$curved,$coordinate]",FB@"$olution[$manifold,$dimension]"];Abort[];,
If[TrueQ[Head@s[$flat]==Head@b[$flat]]==False,
Catch@Throw@Message[ValidateBasis::basic,FB@"$olution[$basis,$flat]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s[$flat]==Keys@b[$flat]]==False,
Catch@Throw@Message[ValidateBasis::keys,FB@"$olution[$basis,$flat]",FB@Keys@b[$flat]];Abort[];,
If[TrueQ[Head@s[$flat,$ymbol]==b[$flat,$ymbol]||s[$flat,$ymbol]==b[$flat,$ymbol]]==False,
Catch@Throw@Message[ValidateBasis::basicOrSame,FB@"$olution[$basis,$flat,$ymbol]",FB@"Symbol",FB@"$olution[$basis,$flat,$ymbol]",FB@"$blueprint[$basis,$flat,$ymbol]"];Abort[];,
If[TrueQ[Head@s[$flat,$color]==b[$flat,$color]||s[$flat,$color]==b[$flat,$color]]==False,
Catch@Throw@Message[ValidateBasis::basicOrSame,FB@"$olution[$basis,$flat,$color]",FB@"RGBColor",FB@"$olution[$basis,$flat,$color]",FB@"$blueprint[$basis,$flat,$color]"];Abort[];,
If[TrueQ[Head/@s[$flat,$index]==Table[b[$flat,$index][[1]],{ii,1,Length@s[$flat,$index]}]||s[$flat,$index]==b[$flat,$index]]==False,
Catch@Throw@Message[ValidateManifold::elementsOrSame,FB@"$olution[$basis,$flat,$index]",FB@"Symbol",FB@"Symbol",FB@"$olution[$basis,$flat,$index]",FB@"$blueprint[$basis,$flat,$index]"];Abort[];,
If[TrueQ[Head@s[$spin]==Head@b[$spin]]==False,
Catch@Throw@Message[ValidateBasis::basic,FB@"$olution[$basis,$spin]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s[$spin]==Keys@b[$spin]]==False,
Catch@Throw@Message[ValidateBasis::keys,FB@"$olution[$basis,$spin]",FB@Keys@b[$spin]];Abort[];,
If[TrueQ[Head@s[$spin,$ymbol]==b[$spin,$ymbol]||s[$spin,$ymbol]==b[$spin,$ymbol]]==False,
Catch@Throw@Message[ValidateBasis::basicOrSame,FB@"$olution[$basis,$spin,$ymbol]",FB@"Symbol",FB@"$olution[$basis,$spin,$ymbol]",FB@"$blueprint[$basis,$spin,$ymbol]"];Abort[];,
If[TrueQ[Head@s[$spin,$color]==b[$spin,$color]||s[$spin,$color]==b[$spin,$color]]==False,
Catch@Throw@Message[ValidateBasis::basicOrSame,FB@"$olution[$basis,$spin,$color]",FB@"RGBColor",FB@"$olution[$basis,$spin,$color]",FB@"$blueprint[$basis,$spin,$color]"];Abort[];,
If[TrueQ[Head/@s[$spin,$index]==Table[b[$spin,$index][[1]],{ii,1,Length@s[$spin,$index]}]||s[$spin,$index]==b[$spin,$index]]==False,
Catch@Throw@Message[ValidateManifold::elementsOrSame,FB@"$olution[$basis,$spin,$index]",FB@"Symbol",FB@"$olution[$basis,$spin,$index]",FB@"$blueprint[$basis,$spin,$index]"];Abort[];,
If[TrueQ[Head@s[$internal]==Head@b[$internal]]==False,
Catch@Throw@Message[ValidateBasis::basic,FB@"$olution[$basis,$internal]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s[$internal]==Keys@b[$internal]]==False,
Catch@Throw@Message[ValidateBasis::keys,FB@"$olution[$basis,$internal]",FB@Keys@b[$internal]];Abort[];,
If[TrueQ[Head@s[$internal,$ymbol]==b[$internal,$ymbol]||s[$internal,$ymbol]==b[$internal,$ymbol]]==False,
Catch@Throw@Message[ValidateBasis::basicOrSame,FB@"$olution[$basis,$internal,$ymbol]",FB@"Symbol",FB@"$olution[$basis,$internal,$ymbol]",FB@"$blueprint[$basis,$internal,$ymbol]"];Abort[];,
If[TrueQ[Head@s[$internal,$color]==b[$internal,$color]||s[$internal,$color]==b[$internal,$color]]==False,
Catch@Throw@Message[ValidateBasis::basicOrSame,FB@"$olution[$basis,$internal,$color]",FB@"RGBColor",FB@"$olution[$basis,$internal,$color]",FB@"$blueprint[$basis,$internal,$color]"];Abort[];,
If[TrueQ[Head/@s[$internal,$index]==Table[b[$internal,$index][[1]],{ii,1,Length@s[$internal,$index]}]||s[$internal,$index]==b[$internal,$index]]==False,
Catch@Throw@Message[ValidateBasis::elementsOrSame,FB@"$olution[$basis,$internal,$index]",FB@"Symbol",FB@"$olution[$basis,$internal,$index]",FB@"$blueprint[$basis,$internal,$index]"];Abort[];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
]


ValidateConstant::basic="`1` should be `2`";
ValidateConstant::keys="The keys of `1` should be `2`";
ValidateConstant::elementsOrSame="The elements of the list `1` should be of the type `2`, or `3` should be the same as `4`";


ValidateConstant[]:=Module[{
s=$olution[$constant],
b=$blueprint[$constant]
},
If[TrueQ[Head@s==Head@b]==False,
Catch@Throw@Message[ValidateConstant::basic,FB@"$olution[$constant]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s==Keys@b]==False,
Catch@Throw@Message[ValidateConstant::keys,FB@"$olution[$constant]",FB@Keys@b];Abort[];,
If[TrueQ[Head/@s[$ymbol]==Table[b[$ymbol][[1]],{ii,1,Length@s[$ymbol]}]||s[$ymbol]==b[$ymbol]]==False,
Catch@Throw@Message[ValidateConstant::elementsOrSame,FB@"$olution[$constant,$ymbol]",FB@"Symbol",FB@"$olution[$constant,$ymbol]",FB@"$blueprint[$constant,$ymbol]"];Abort[];
];
];
];
]


ValidateFunction::basic="`1` should be `2`";
ValidateFunction::keys="The keys of `1` should be `2`";
ValidateFunction::elementsOrSame="The elements of the list `1` should be of the type `2`, or `3` should be the same as `4`";
ValidateFunction::before="`1` should be set before `2`";
ValidateFunction::arguments="The arguments of the functions `1` should be among `2`";


ValidateFunction[]:=Module[{
s=$olution[$function],
b=$blueprint[$function]
},
If[TrueQ[$olution[$basis]==$blueprint[$basis]]==True,
Catch@Throw@Message[ValidateBasis::before,FB@"$olution[$basis]",FB@"$olution[$function]"];Abort[];,
If[TrueQ[Head@s==Head@b]==False,
Catch@Throw@Message[ValidateFunction::basic,FB@"$olution[$function]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s==Keys@b]==False,
Catch@Throw@Message[ValidateFunction::keys,FB@"$olution[$function]",FB@Keys@b];Abort[];,
If[TrueQ[Head/@Head/@s[$ymbol]==Table[b[$ymbol][[1]],{ii,1,Length@s[$ymbol]}]||s[$ymbol]==b[$ymbol]]==False,
Catch@Throw@Message[ValidateFunction::elementsOrSame,FB@"$olution[$function,$ymbol]",FB@"Symbol",FB@"$olution[$function,$ymbol]",FB@"$blueprint[$function,$ymbol]"];Abort[];,
If[TrueQ[(Map[MemberQ[Values@$olution[$basis,$curved,$coordinate],#]&,Flatten@Table[Level[s[$ymbol][[ii]],-1],{ii,1,Length@s[$ymbol]}]])==Table[True,Length@Flatten@Table[Level[s[$ymbol][[ii]],-1],{ii,1,Length@s[$ymbol]}]]]==False,
Catch@Throw@Message[ValidateFunction::arguments,FB@"$olution[$function,$ymbol]",FB@Values@$olution[$basis,$curved,$coordinate]];Abort[];
];
];
];
];
];
]


ValidateAssumption::basic="`1` should be `2`";
ValidateAssumption::keys="The keys of `1` should be `2`";
ValidateAssumption::heads="The heads of `1` should be among `2`";
ValidateAssumption::involve="`1` should only involve assumptions over `2`";


ValidateAssumption[]:=Module[{
s=$olution[$assumption],
b=$blueprint[$assumption]
},
If[TrueQ[Head@s==Head@b]==False,
Catch@Throw@Message[ValidateAssumption::basic,FB@"$olution[$assumption]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s==Keys@b]==False,
Catch@Throw@Message[ValidateAssumption::keys,FB@"$olution[$assumption]",FB@Keys@b];Abort[];,
If[TrueQ[Map[MemberQ[Level[b[$coordinate][[1]],-1],#]&,Head/@s[$coordinate]]==Table[True,Length@s[$coordinate]]]==False,
Catch@Throw@Message[ValidateAssumption::heads,FB@"$olution[$assumption,$constant]",FB@Level[b[$coordinate][[1]],-1]];Abort[];,
If[TrueQ[Map[MemberQ[Values@$olution[$basis,$curved,$coordinate],#]&,Cases[x_Symbol/;And[Context[x]!="System`",Context[x]!="SolutionsX`SolutionsX`"]]@DeleteDuplicates@Flatten@Table[Level[s[$coordinate][[ii]],{-1}],{ii,1,Length@s[$coordinate]}]]==Table[True,Length@Cases[x_Symbol/;And[Context[x]!="System`",Context[x]!="SolutionsX`SolutionsX`"]]@DeleteDuplicates@Flatten@Table[Level[s[$coordinate][[ii]],{-1}],{ii,1,Length@s[$coordinate]}]]]==True(*False*),
(*Catch@Throw@Message[ValidateAssumption::involve,FB@"$olution[$assumption,$coordinate]",FB@Values@$olution[$basis,$curved,$coordinate]];Abort[];,*)
If[TrueQ[Map[MemberQ[Level[b[$constant][[1]],-1],#]&,Head/@s[$constant]]==Table[True,Length@s[$constant]]]==False,
Catch@Throw@Message[ValidateAssumption::heads,FB@"$olution[$assumption,$constant]",FB@Level[b[$constant][[1]],-1]];Abort[];,
If[TrueQ[Map[MemberQ[$olution[$constant,$ymbol],#]&,Cases[x_Symbol/;And[Context[x]!="System`",Context[x]!="SolutionsX`SolutionsX`"]]@DeleteDuplicates@Flatten@Table[Level[$olution[$assumption,$constant][[ii]],{-1}],{ii,1,Length@$olution[$assumption,$constant]}]]==Table[True,Length@(Cases[x_Symbol/;And[Context[x]!="System`",Context[x]!="SolutionsX`SolutionsX`"]]@DeleteDuplicates@Flatten@Table[Level[$olution[$assumption,$constant][[ii]],{-1}],{ii,1,Length@$olution[$assumption,$constant]}])]]==False,
Catch@Throw@Message[ValidateAssumption::involve,FB@"$olution[$assumption,$constant]",FB@$olution[$constant,$ymbol]];Abort[];,
If[TrueQ[Map[MemberQ[Level[b[$function][[1]],-1],#]&,Head/@s[$function]]==Table[True,Length@s[$function]]]==False,
Catch@Throw@Message[ValidateAssumption::heads,FB@"$olution[$assumption,$function]",FB@Level[b[$function][[1]],-1]];Abort[];,
If[TrueQ[Map[MemberQ[Head/@$olution[$function,$ymbol],#]&,Cases[x_Symbol/;And[Context[x]!="System`",Context[x]!="SolutionsX`SolutionsX`"]]@DeleteDuplicates@Level[$olution[$assumption,$function],-1]]==Table[True,Length@Cases[x_Symbol/;And[Context[x]!="System`",Context[x]!="SolutionsX`SolutionsX`"]]@DeleteDuplicates@Level[$olution[$assumption,$function],-1]]]==False,
Catch@Throw@Message[ValidateAssumption::involve,FB@"$olution[$assumption,$function]",FB@(Head/@$olution[$function,$ymbol])];Abort[];
];
];
];
];
];
];
];
];
]


ValidateScalar::basic="`1` should be `2`";
ValidateScalar::key="The key of `1` should be `2`";
ValidateScalar::keys="The keys of `1` should be `2`";
ValidateScalar::basicOrSame="`1` should be `2` or `3` should be the same as `4`";


ValidateScalar[]:=Module[{
s=$olution[$scalar],
b=$blueprint[$scalar]
},
If[TrueQ[Head@s==Head@b]==False,
Catch@Throw@Message[ValidateScalar::basic,FB@"$olution[$scalar]",FB@"Association"];Abort[];,
If[TrueQ[Head/@Keys@s==Table[(Keys@b)[[1]],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateScalar::key,FB@"$olution[$scalar,_]",FB@"Symbol"];Abort[];,
If[TrueQ[Head/@(Values@s)==Table[(Head/@Values@b)[[1]],Length@s]]==False,
Catch@Throw@Message[ValidateScalar::basic,FB@"$olution[$scalar,_]",FB@"Association"];Abort[];,
If[TrueQ[Table[Keys@s[[ii]],{ii,1,Length@s}]==Table[Keys@b[Symbol],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateScalar::keys,FB@"$olution[$scalar,_]",FB@Keys@b[Symbol]];Abort[];,
If[TrueQ[Head/@Table[(s[[ii]])[$ymbol],{ii,1,Length@s}]==Table[b[Symbol,$ymbol],{ii,1,Length@s}]||Table[(s[[ii]])[$ymbol],{ii,1,Length@s}]==Table[b[Symbol,$ymbol],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateScalar::basicOrSame,FB@"$olution[$scalar,_,$ymbol]",FB@"Symbol",FB@"$olution[$scalar,_$ymbol]",FB@"$blueprint[Symbol,$ymbol]"];Abort[];,
If[TrueQ[Head/@Table[(s[[ii]])[$print],{ii,1,Length@s}]==Table[b[Symbol,$print],{ii,1,Length@s}]||Table[(s[[ii]])[$print],{ii,1,Length@s}]==Table[b[Symbol,$print],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateScalar::basicOrSame,FB@"$olution[$scalar,_,$print]",FB@"String",FB@"$olution[$scalar,_,$print]",FB@"$blueprint[Symbol,$print]"];Abort[];,
If[TrueQ[Head/@Table[(s[[ii]])[$internalRank],{ii,1,Length@s}]==Table[b[Symbol,$internalRank],{ii,1,Length@s}]||Table[(s[[ii]])[$internalRank],{ii,1,Length@s}]==Table[b[Symbol,$internalRank],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateScalar::basicOrSame,FB@"$olution[$scalar,_,$internalRank]",FB@"Integer",FB@"$olution[$scalar,_,$internalRank]",FB@"$blueprint[Symbol,$internalRank]"];Abort[];,
If[TrueQ[Head/@Table[(s[[ii]])[$value],{ii,1,Length@s}]==Table[b[Symbol,$value],{ii,1,Length@s}]||Table[(s[[ii]])[$value],{ii,1,Length@s}]==Table[b[Symbol,$value],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateScalar::basicOrSame,FB@"$olution[$scalar,_,$value]",FB@"Rule",FB@"$olution[$scalar,_,$value]",FB@"$blueprint[Symbol,$value]"];Abort[];
];
];
];
];
];
];
];
];
]


ValidateForm::basic="`1` should be `2`";
ValidateForm::key="The key of `1` should be `2`";
ValidateForm::keys="The keys of `1` should be `2`";
ValidateForm::basicOrSame="`1` should be `2` or `3` should be the same as `4`";


ValidateForm[]:=Module[{
s=$olution[$form],
b=$blueprint[$form]
},
If[TrueQ[Head@s==Head@b]==False,
Catch@Throw@Message[ValidateForm::basic,FB@"$olution[$form]",FB@"Association"];Abort[];,
If[TrueQ[Head/@Keys@s==Table[(Keys@b)[[1]],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateForm::key,FB@"$olution[$form,_]",FB@"Symbol"];Abort[];,
If[TrueQ[Head/@(Values@s)==Table[(Head/@Values@b)[[1]],Length@s]]==False,
Catch@Throw@Message[ValidateForm::basic,FB@"$olution[$form,_]",FB@"Association"];Abort[];,
If[TrueQ[Table[Keys@s[[ii]],{ii,1,Length@s}]==Table[Keys@b[Symbol],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateForm::keys,FB@"$olution[$form,_]",FB@Keys@b[Symbol]];Abort[];,
If[TrueQ[Head/@Table[(s[[ii]])[$ymbol],{ii,1,Length@s}]==Table[b[Symbol,$ymbol],{ii,1,Length@s}]||Table[(s[[ii]])[$ymbol],{ii,1,Length@s}]==Table[b[Symbol,$ymbol],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateForm::basicOrSame,FB@"$olution[$form,_,$ymbol]",FB@"Symbol",FB@"$olution[$form,_$ymbol]",FB@"$blueprint[Symbol,$ymbol]"];Abort[];,
If[TrueQ[Head/@Table[(s[[ii]])[$print],{ii,1,Length@s}]==Table[b[Symbol,$print],{ii,1,Length@s}]||Table[(s[[ii]])[$print],{ii,1,Length@s}]==Table[b[Symbol,$print],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateForm::basicOrSame,FB@"$olution[$form,_,$print]",FB@"String",FB@"$olution[$form,_,$print]",FB@"$blueprint[Symbol,$print]"];Abort[];,
If[TrueQ[Head/@Table[(s[[ii]])[$rank],{ii,1,Length@s}]==Table[b[Symbol,$rank],{ii,1,Length@s}]||Table[(s[[ii]])[$rank],{ii,1,Length@s}]==Table[b[Symbol,$rank],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateForm::basicOrSame,FB@"$olution[$form,_,$rank]",FB@"Integer",FB@"$olution[$form,_,$rank]",FB@"$blueprint[Symbol,$rank]"];Abort[];,
If[TrueQ[Head/@Table[(s[[ii]])[$internalRank],{ii,1,Length@s}]==Table[b[Symbol,$internalRank],{ii,1,Length@s}]||Table[(s[[ii]])[$internalRank],{ii,1,Length@s}]==Table[b[Symbol,$internalRank],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateForm::basicOrSame,FB@"$olution[$form,_,$internalRank]",FB@"Integer",FB@"$olution[$form,_,$internalRank]",FB@"$blueprint[Symbol,$internalRank]"];Abort[];,
If[TrueQ[Table[MemberQ[Level[b[Symbol,$expression],-1],Head@(s[[ii]])[$expression]],{ii,1,Length@s}]==Table[True,{ii,1,Length@s}]||Table[(s[[ii]])[$expression],{ii,1,Length@s}]==Table[b[Symbol,$expression],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateForm::basicOrSame,FB@"$olution[$form,_,$expression]",FB@"Rule",FB@"$olution[$form,_,$value]",FB@"$blueprint[Symbol,$expression]"];Abort[];
];
];
];
];
];
];
];
];
];
]


ValidateTensor::basic="`1` should be `2`";
ValidateTensor::before="`1` should be set before `2`";
ValidateTensor::key="The key of `1` should be `2`";
ValidateTensor::keys="The keys of `1` should be `2`";
ValidateTensor::subset="The keys `1` should be a subset of the keys of `2`";
ValidateTensor::basicOrSame="`1` should be `2` or `3` should be the same as `4`";
ValidateTensor::rank="Tensor with key `1` should have rank `2`";
ValidateTensor::internalRank="Tensor with key `1` should have internalRank `2`";
ValidateTensor::symmetry="The symmetry of the form-tensor `1` should be `2`";


ValidateTensor[]:=Module[{
s=$olution[$tensor],
b=$blueprint[$tensor]
},
If[TrueQ[$olution[$form]==$blueprint[$form]]==True,
Catch@Throw@Message[ValidateTensor::before,FB@"$olution[$form]",FB@"$olution[$tensor]"];Abort[];,
If[TrueQ[Head@s==Head@b]==False,
Catch@Throw@Message[ValidateTensor::basic,FB@"$olution[$tensor]",FB@"Association"];Abort[];,
If[TrueQ[Head/@Keys@s==Table[(Keys@b)[[1]],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateTensor::key,FB@"$olution[$tensor,_]",FB@"Symbol"];Abort[];,
If[TrueQ[Head/@(Values@s)==Table[(Head/@Values@b)[[1]],Length@s]]==False,
Catch@Throw@Message[ValidateForm::basic,FB@"$olution[$tensor,_]",FB@"Association"];Abort[];,
If[TrueQ[Table[Keys@s[[ii]],{ii,1,Length@s}]==Table[Keys@b[Symbol],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateTensor::keys,FB@"$olution[$tensor,_]",FB@Keys@b[Symbol]];Abort[];,
If[TrueQ[SubsetQ[Keys@s,Keys@$olution[$form]]]==False,
Catch@Throw@Message[ValidateTensor::subset,FB@Keys@$olution[$form],FB@"$olution[$tensor]"];Abort[];,
If[TrueQ[Head/@Table[(s[[ii]])[$ymbol],{ii,1,Length@s}]==Table[b[Symbol,$ymbol],{ii,1,Length@s}]||Table[(s[[ii]])[$ymbol],{ii,1,Length@s}]==Table[b[Symbol,$ymbol],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateTensor::basicOrSame,FB@"$olution[$tensor,_,$ymbol]",FB@"Symbol",FB@"$olution[$tensor,_$ymbol]",FB@"$blueprint[Symbol,$ymbol]"];Abort[];,
If[TrueQ[Head/@Table[(s[[ii]])[$print],{ii,1,Length@s}]==Table[b[Symbol,$print],{ii,1,Length@s}]||Table[(s[[ii]])[$print],{ii,1,Length@s}]==Table[b[Symbol,$print],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateTensor::basicOrSame,FB@"$olution[$tensor,_,$print]",FB@"String",FB@"$olution[$tensor,_,$print]",FB@"$blueprint[Symbol,$print]"];Abort[];,
If[TrueQ[Head/@Table[(s[[ii]])[$rank],{ii,1,Length@s}]==Table[b[Symbol,$rank],{ii,1,Length@s}]||Table[(s[[ii]])[$rank],{ii,1,Length@s}]==Table[b[Symbol,$rank],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateTensor::basicOrSame,FB@"$olution[$tensor,_,$rank]",FB@"Integer",FB@"$olution[$tensor,_,$rank]",FB@"$blueprint[Symbol,$rank]"];Abort[];,
If[TrueQ[Head/@Table[(s[[ii]])[$internalRank],{ii,1,Length@s}]==Table[b[Symbol,$internalRank],{ii,1,Length@s}]||Table[(s[[ii]])[$internalRank],{ii,1,Length@s}]==Table[b[Symbol,$internalRank],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateTensor::basicOrSame,FB@"$olution[$tensor,_,$internalRank]",FB@"Integer",FB@"$olution[$tensor,_,$internalRank]",FB@"$blueprint[Symbol,$internalRank]"];Abort[];,
If[TrueQ[Table[MemberQ[Level[b[Symbol,$ymmetry],-1]/.Null:>Symbol,Head@(s[[ii]])[$ymmetry]],{ii,1,Length@s}]==Table[True,{ii,1,Length@s}]||Table[(s[[ii]])[$ymmetry],{ii,1,Length@s}]==Table[b[Symbol,$ymmetry],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateTensor::basicOrSame,FB@"$olution[$tensor,_,$ymmetry]",FB@"(Symmetric || Antisymmetric || Null)",FB@"$olution[$tensor,_,$ymmetry]",FB@"$blueprint[$tensor,_,$ymmetry]"];Abort[];,
Do[
(*If[TrueQ[Head/@Table[(s\[LeftDoubleBracket]ii\[RightDoubleBracket])[$value],{ii,1,Length@s}]==Table[b[Symbol,$value],{ii,1,Length@s}]||Table[(s\[LeftDoubleBracket]ii\[RightDoubleBracket])[$value],{ii,1,Length@s}]==Table[b[Symbol,$value],{ii,1,Length@s}]]==False,
Catch@Throw@Message[ValidateTensor::basicOrSame,FB@"$olution[$tensor,_,$value]",FB@"Association",FB@"$olution[$tensor,_,$value]",FB@"$blueprint[$tensor,Symbol,$value]"];Abort[];
];,*)
If[TrueQ[Head@((s[[ii]])[$value])==b[Symbol,$value]||(s[[ii]])[$value]==b[Symbol,$value]]==False,
Catch@Throw@Message[ValidateTensor::basicOrSame,FB@"$olution[$tensor,_,$value]",FB@"Association",FB@"$olution[$tensor,_,$value]",FB@"$blueprint[$tensor,Symbol,$value]"];Abort[];
];,
{ii,1,Length@s}
];
];
];
];
];
];
];
];
];
];
];
];
Do[
If[TrueQ[MemberQ[Keys@$olution[$form],(Keys@$olution[$tensor])[[ii]]]]==True,
If[TrueQ[$olution[$form,(Keys@$olution[$tensor])[[ii]],$rank]==s[(Keys@$olution[$tensor])[[ii]],$rank]]==False,
Catch@Throw@Message[ValidateTensor::rank,FB@(Keys@$olution[$tensor])[[ii]],FB@$olution[$form,(Keys@$olution[$tensor])[[ii]],$rank]];Abort[];
]
],{ii,1,Length@s}
];
Do[
If[TrueQ[MemberQ[Keys@$olution[$form],(Keys@$olution[$tensor])[[ii]]]]==True,
If[TrueQ[$olution[$form,(Keys@$olution[$tensor])[[ii]],$internalRank]==s[(Keys@$olution[$tensor])[[ii]],$internalRank]]==False,
Catch@Throw@Message[ValidateTensor::internalRank,FB@(Keys@$olution[$tensor])[[ii]],FB@$olution[$form,(Keys@$olution[$tensor])[[ii]],$internalRank]];Abort[];
]
],{ii,1,Length@s}
];
Do[
If[TrueQ[MemberQ[Keys@$olution[$form],(Keys@$olution[$tensor])[[ii]]]&&$olution[$tensor,(Keys@$olution[$tensor])[[ii]],$rank]==1]==True,
If[TrueQ[$olution[$tensor,(Keys@$olution[$tensor])[[ii]],$ymmetry]==Null]==False,
Catch@Throw@Message[ValidateTensor::symmetry,FB@(Keys@$olution[$tensor])[[ii]],FB@"Null"];Abort[];
];
],{ii,1,Length@s}
];
Do[
If[TrueQ[MemberQ[Keys@$olution[$form],(Keys@$olution[$tensor])[[ii]]]&&$olution[$tensor,(Keys@$olution[$tensor])[[ii]],$rank]!=1]==True,
If[TrueQ[$olution[$tensor,(Keys@$olution[$tensor])[[ii]],$ymmetry]==Antisymmetric[Table[jj,{jj,1,$olution[$tensor,(Keys@$olution[$tensor])[[ii]],$rank]}]]]==False,
Catch@Throw@Message[ValidateTensor::symmetry,FB@(Keys@$olution[$tensor])[[ii]],FB@Antisymmetric[Table[jj,{jj,1,$olution[$tensor,(Keys@$olution[$tensor])[[ii]],$rank]}]]];Abort[];
];
],{ii,1,Length@s}
];
]


ValidateMetric::before="`1` should be set before `2`";
ValidateMetric::basic="`1` should be `2`";
ValidateMetric::keys="The keys of `1` should be `2`";
ValidateMetric::signature="A `1` curved metric should have signature `2`";
ValidateMetric::basicOrSame="`1` should be `2` or `3` should be the same as `4`";


ValidateMetric[]:=Module[{
s=$olution[$metric],
b=$blueprint[$metric]
},
If[TrueQ[$olution[$info]==$blueprint[$info]]==True,
Catch@Throw@Message[ValidateMetric::before,FB@"$olution[$info]",FB@"$olution[$metric]"];Abort[];,
If[TrueQ[$olution[$basis]==$blueprint[$basis]]==True,
Catch@Throw@Message[ValidateMetric::before,FB@"$olution[$basis]",FB@"$olution[$metric]"];Abort[];,
If[TrueQ[Head@s==Head@b]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s==Keys@b]==False,
Catch@Throw@Message[ValidateBasis::keys,FB@"$olution[$metric]",FB@Keys@b];Abort[];,
If[TrueQ[Head@s[$curved]==Head@b[$curved]]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric,$curved]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s[$curved]==Keys@b[$curved]]==False,
Catch@Throw@Message[ValidateBasis::keys,FB@"$olution[$metric,$curved]",FB@Keys@b[$curved]];Abort[];,
If[TrueQ[($olution[$info,$ignature]==Lorentzian&&s[$curved,$ignature]==-1)||($olution[$info,$ignature]==Euclidean&&s[$curved,$ignature]==1)]==False,
Catch@Throw@Message[ValidateMetric::signature,FB@"(Lorentizan || Euclidean)",FB@"(-1 || 1)"];Abort[];,
If[TrueQ[Head@s[$curved,$covd]==b[$curved,$covd]]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric,$curved,$covd]",FB@"Symbol"];Abort[];,
If[TrueQ[Head@s[$curved,$ds2]==b[$curved,$ds2]||s[$curved,$ds2]==b[$curved,$ds2]]==False,
Catch@Throw@Message[ValidateMetric::basicOrSame,FB@"$olution[$metric,$curved,$ds2]",FB@"Plus",FB@"$olution[$metric,$curved,$ds2]",FB@"$blueprint[$metric,$curved,$ds2]"];Abort[];,
If[TrueQ[Head@s[$curved,$tensor]==Head@b[$curved,$tensor]]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric,$curved,$tensor]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s[$curved,$tensor]==Keys@b[$curved,$tensor]]==False,
Catch@Throw@Message[ValidateBasis::keys,FB@"$olution[$metric,$curved,$tensor]",FB@Keys@b[$curved,$tensor]];Abort[];,
If[TrueQ[Head@s[$curved,$tensor,$ymbol]==b[$curved,$tensor,$ymbol]]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric,$curved,$tensor,$ymbol]",FB@"Symbol"];Abort[];,
If[TrueQ[Head@s[$curved,$tensor,$print]==b[$curved,$tensor,$print]]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric,$curved,$tensor,$print]",FB@"String"];Abort[];,
If[TrueQ[Head@s[$curved,$tensor,$value]==b[$curved,$tensor,$value]||s[$curved,$tensor,$value]==b[$curved,$tensor,$value]]==False,
Catch@Throw@Message[ValidateMetric::basicOrSame,FB@"$olution[$metric,$curved,$tensor,$value]",FB@"FoldedRule",FB@"$olution[$metric,$curved,$tensor,$value]",FB@"$blueprint[$metric,$curved,$tensor,$value]"];Abort[];,
If[TrueQ[Head@s[$curved,$christoffel]==Head@b[$curved,$christoffel]]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric,$curved,$christoffel]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s[$curved,$christoffel]==Keys@b[$curved,$christoffel]]==False,
Catch@Throw@Message[ValidateBasis::keys,FB@"$olution[$metric,$curved,$christoffel]",FB@Keys@b[$curved,$christoffel]];Abort[];,
If[TrueQ[s[$curved,$christoffel,$ymbol]==Symbol["Christoffel"<>ToString[s[$curved,$covd]]]]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric,$curved,$christoffel,$ymbol]",FB@Symbol["Christoffel"<>ToString[s[$curved,$covd]]]];Abort[];,
If[TrueQ[Head@s[$curved,$christoffel,$value]==b[$curved,$christoffel,$value]||s[$curved,$christoffel,$value]==b[$curved,$christoffel,$value]]==False,
Catch@Throw@Message[ValidateMetric::basicOrSame,FB@"$olution[$metric,$curved,$christoffel,$value]",FB@"FoldedRule",FB@"$olution[$metric,$curved,$christoffel,$value]",FB@"$blueprint[$metric,$curved,$christoffel,$value]"];Abort[];,
If[TrueQ[Head@s[$curved,$riemann]==Head@b[$curved,$riemann]]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric,$curved,$riemann]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s[$curved,$riemann]==Keys@b[$curved,$riemann]]==False,
Catch@Throw@Message[ValidateBasis::keys,FB@"$olution[$metric,$curved,$riemann]",FB@Keys@b[$curved,$riemann]];Abort[];,
If[TrueQ[s[$curved,$riemann,$ymbol]==Symbol["Riemann"<>ToString[s[$curved,$covd]]]]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric,$curved,$riemann,$ymbol]",FB@Symbol["Riemann"<>ToString[s[$curved,$covd]]]];Abort[];,
If[TrueQ[Head@s[$curved,$riemann,$value]==b[$curved,$riemann,$value]||s[$curved,$riemann,$value]==b[$curved,$riemann,$value]]==False,
Catch@Throw@Message[ValidateMetric::basicOrSame,FB@"$olution[$metric,$curved,$riemann,$value]",FB@"FoldedRule",FB@"$olution[$metric,$curved,$riemann,$value]",FB@"$blueprint[$metric,$curved,$riemann,$value]"];Abort[];,
If[TrueQ[Head@s[$curved,$ricci]==Head@b[$curved,$ricci]]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric,$curved,$ricci]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s[$curved,$ricci]==Keys@b[$curved,$ricci]]==False,
Catch@Throw@Message[ValidateBasis::keys,FB@"$olution[$metric,$curved,$ricci]",FB@Keys@b[$curved,$ricci]];Abort[];,
If[TrueQ[s[$curved,$ricci,$ymbol]==Symbol["Ricci"<>ToString[s[$curved,$covd]]]]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric,$curved,$ricci,$ymbol]",FB@Symbol["Ricci"<>ToString[s[$curved,$covd]]]];Abort[];,
If[TrueQ[Head@s[$curved,$ricci,$value]==b[$curved,$ricci,$value]||s[$curved,$ricci,$value]==b[$curved,$ricci,$value]]==False,
Catch@Throw@Message[ValidateMetric::basicOrSame,FB@"$olution[$metric,$curved,$ricci,$value]",FB@"FoldedRule",FB@"$olution[$metric,$curved,$ricci,$value]",FB@"$blueprint[$metric,$curved,$ricci,$value]"];Abort[];,
If[TrueQ[Head@s[$curved,$ricciScalar]==Head@b[$curved,$ricciScalar]]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric,$curved,$ricciScalar]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s[$curved,$ricciScalar]==Keys@b[$curved,$ricciScalar]]==False,
Catch@Throw@Message[ValidateBasis::keys,FB@"$olution[$metric,$curved,$ricciScalar]",FB@Keys@b[$curved,$ricciScalar]];Abort[];,
If[TrueQ[s[$curved,$ricciScalar,$ymbol]==Symbol["RicciScalar"<>ToString[s[$curved,$covd]]]]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric,$curved,$ricciScalar,$ymbol]",FB@Symbol["RicciScalar"<>ToString[s[$curved,$covd]]]];Abort[];,
If[TrueQ[Head@s[$curved,$ricciScalar,$value]==b[$curved,$ricciScalar,$value]||s[$curved,$ricciScalar,$value]==b[$curved,$ricciScalar,$value]]==False,
Catch@Throw@Message[ValidateMetric::basicOrSame,FB@"$olution[$metric,$curved,$ricciScalar,$value]",FB@"Rule",FB@"$olution[$metric,$curved,$ricciScalar,$value]",FB@"$blueprint[$metric,$curved,$ricciScalar,$value]"];Abort[];,
If[TrueQ[Head@s[$curved,$det]==Head@b[$curved,$det]]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric,$curved,$det]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s[$curved,$det]==Keys@b[$curved,$det]]==False,
Catch@Throw@Message[ValidateBasis::keys,FB@"$olution[$metric,$curved,$det]",FB@Keys@b[$curved,$det]];Abort[];,
If[TrueQ[s[$curved,$det,$ymbol]==Symbol["Det"<>ToString[s[$curved,$tensor,$ymbol]]<>ToString[$olution[$basis,$curved,$ymbol]]]]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric,$curved,$det,$ymbol]",FB@Symbol["Det"<>ToString[s[$curved,$tensor,$ymbol]]<>ToString[$olution[$basis,$curved,$ymbol]]]];Abort[];,
If[TrueQ[Head@s[$curved,$det,$value]==b[$curved,$det,$value]||s[$curved,$det,$value]==b[$curved,$det,$value]]==False,
Catch@Throw@Message[ValidateMetric::basicOrSame,FB@"$olution[$metric,$curved,$det,$value]",FB@"Rule",FB@"$olution[$metric,$curved,$det,$value]",FB@"$blueprint[$metric,$curved,$det,$value]"];Abort[];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
];
If[TrueQ[Head@s[$flat]==Head@b[$flat]]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric,$flat]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s[$flat]==Keys@b[$flat]]==False,
Catch@Throw@Message[ValidateMetric::keys,FB@"$olution[$metric,$flat]",FB@Keys@b[$flat]];Abort[];,
If[TrueQ[Head@s[$flat,$tensor]==Head@b[$flat,$tensor]]==False,
Catch@Throw@Message[ValidateMetric::basic,FB@"$olution[$metric,$flat,$tensor]",FB@"Association"];Abort[];,
If[TrueQ[Keys@s[$flat,$tensor]==Keys@b[$flat,$tensor]]==False,
Catch@Throw@Message[ValidateMetric::keys,FB@"$olution[$metric,$flat,$tensor]",FB@Keys@b[$flat,$tensor]];Abort[];,
If[TrueQ[Head@s[$flat,$tensor,$ymbol]==b[$flat,$tensor,$ymbol]||s[$flat,$tensor,$ymbol]==b[$flat,$tensor,$ymbol]]==False,
Catch@Throw@Message[ValidateMetric::basicOrSame,FB@"$olution[$metric,$flat,$tensor,$ymbol]",FB@"Symbol",FB@"$olution[$metric,$flat,$tensor,$ymbol]",FB@"$blueprint[$metric,$flat,$tensor,$ymbol]"];Abort[];,
If[TrueQ[Head@s[$flat,$tensor,$print]==b[$flat,$tensor,$print]||s[$flat,$tensor,$print]==b[$flat,$tensor,$print]]==False,
Catch@Throw@Message[ValidateMetric::basicOrSame,FB@"$olution[$metric,$flat,$tensor,$print]",FB@"String",FB@"$olution[$metric,$flat,$tensor,$print]",FB@"$blueprint[$metric,$flat,$tensor,$print]"];Abort[];,
If[TrueQ[Head@s[$flat,$tensor,$value]==b[$flat,$tensor,$value]||s[$flat,$tensor,$value]==b[$flat,$tensor,$value]]==False,
Catch@Throw@Message[ValidateMetric::basicOrSame,FB@"$olution[$metric,$flat,$tensor,$value]",FB@"FoldedRule",FB@"$olution[$metric,$flat,$tensor,$value]",FB@"$blueprint[$metric,$flat,$tensor,$value]"];Abort[];
];
];
];
];
];
];
];
];
];
];
];
]


SetInfo[name_,identifier_,coordinateSystem_,signature_,dimension_,referenceMatrix_,comment_]:=Module[{
n=name,
i=identifier,
cs=coordinateSystem,
s=signature,
d=dimension,
rm=referenceMatrix,
c=comment},
$olution[$info]=<|
$name->n,
$identifier->i,
$coordinateSystem->cs,
$ignature->s,
$dimension->d,
$reference->(Table[rm[[ii,1]]->Hyperlink[rm[[ii,2]]],{ii,1,Length@rm}]/.List[x__]:>Association[x]),
$comment->c
|>;
ValidateInfo[];
System`$Context=GenContext[];
]


SetInfo[name_,identifier_,coordinateSystem_,signature_,dimension_]:=Module[{
n=name,
i=identifier,
cs=coordinateSystem,
s=signature,
d=dimension
},
$olution[$info]=<|
$name->n,
$identifier->i,
$coordinateSystem->cs,
$ignature->s,
$dimension->d,
$reference->$blueprint[$info,$reference],
$comment->$blueprint[$info,$comment]
|>;
ValidateInfo[];
System`$Context=GenContext[];
]


SetManifold[symbol_,dimension_,indexList_]:=Module[{
s=symbol,
d=dimension,
il=indexList
},
$olution[$manifold]=<|
$ymbol->s,
$dimension->d,
$index->il
|>;
ValidateManifold[];
]


SetManifold[symbol_,indexList_]:=Module[{
s=symbol,
d=$olution[$info,$dimension],
il=indexList
},
SetManifold[s,d,il];
ValidateManifold[];
]


SetManifold[symbol_]:=Module[{
s=symbol,
il=Symbol/@{GenContext[]<>"\[ScriptA]",GenContext[]<>"\[ScriptB]",GenContext[]<>"\[ScriptC]",GenContext[]<>"\[ScriptD]",GenContext[]<>"\[ScriptE]",GenContext[]<>"\[ScriptF]",GenContext[]<>"\[ScriptG]",GenContext[]<>"\[ScriptH]",GenContext[]<>"\[ScriptI]",GenContext[]<>"\[ScriptJ]",GenContext[]<>"\[ScriptK]",GenContext[]<>"\[ScriptL]",GenContext[]<>"\[ScriptM]",GenContext[]<>"\[ScriptN]",GenContext[]<>"\[ScriptO]",GenContext[]<>"\[ScriptP]" ,GenContext[]<>"\[ScriptQ]",GenContext[]<>"\[ScriptR]",GenContext[]<>"\[ScriptS]",GenContext[]<>"\[ScriptT]",GenContext[]<>"\[ScriptU]",GenContext[]<>"\[ScriptV]",GenContext[]<>"\[ScriptW]",GenContext[]<>"\[ScriptX]",GenContext[]<>"\[ScriptY]",GenContext[]<>"\[ScriptZ]"}
},
SetManifold[s,il];
ValidateManifold[];
]


SetBasis[{curved_,curvedColor_,curvedIndexList_},{cnumberList_,coordinateList_},{flat_,flatColor_,flatIndexList_},{spin_,spinColor_,spinIndexList_},{internal_,internalColor_,internalIndexList_}]:=Module[{
c=curved,
cc=curvedColor,
cil=curvedIndexList,
nl=cnumberList,
cl=coordinateList,
f=flat,
fc=flatColor,
fil=flatIndexList,
s=spin,
sc=spinColor,
sil=spinIndexList,
i=internal,
ic=internalColor,
iil=internalIndexList
},
$olution[$basis]=<|
$curved-><|$ymbol->c,$color->cc,$index->cil,$coordinate->(Table[nl[[ii]]->cl[[ii]],{ii,1,Length@nl}]/.List[x__]:>Association[x])|>,
$flat-><|$ymbol->f,$color->fc,$index->fil|>,
$spin-><|$ymbol->s,$color->sc,$index->sil|>,
$internal-><|$ymbol->i,$color->ic,$index->iil|>
|>;
ValidateBasis[];
]


SetBasis[curved_,coordinateList_,flat_,spin_,internal_]:=Module[{
c=curved,
cc=Red,
cil=$olution[$manifold,$index],
nl=Table[ii,{ii,0,$olution[$manifold,$dimension]-1}],
cl=coordinateList,
f=flat,
fc=Blue,
fil=Symbol/@{GenContext[]<>"\[GothicA]",GenContext[]<>"\[GothicB]",GenContext[]<>"\[GothicC]",GenContext[]<>"\[GothicD]",GenContext[]<>"\[GothicE]",GenContext[]<>"\[GothicF]",GenContext[]<>"\[GothicG]",GenContext[]<>"\[GothicH]",GenContext[]<>"\[GothicI]",GenContext[]<>"\[GothicJ]",GenContext[]<>"\[GothicK]",GenContext[]<>"\[GothicL]",GenContext[]<>"\[GothicM]",GenContext[]<>"\[GothicN]",GenContext[]<>"\[GothicO]",GenContext[]<>"\[GothicP]",GenContext[]<>"\[GothicQ]",GenContext[]<>"\[GothicR]",GenContext[]<>"\[GothicS]",GenContext[]<>"\[GothicT]",GenContext[]<>"\[GothicU]",GenContext[]<>"\[GothicV]",GenContext[]<>"\[GothicW]",GenContext[]<>"\[GothicX]",GenContext[]<>"\[GothicY]",GenContext[]<>"\[GothicZ]"},
s=spin,
sc=Green,
sil=Symbol/@{GenContext[]<>"\[DoubleStruckCapitalA]",GenContext[]<>"\[DoubleStruckCapitalB]",GenContext[]<>"\[DoubleStruckCapitalC]",GenContext[]<>"\[DoubleStruckCapitalD]",GenContext[]<>"\[DoubleStruckCapitalE]",GenContext[]<>"\[DoubleStruckCapitalF]",GenContext[]<>"\[DoubleStruckCapitalG]",GenContext[]<>"\[DoubleStruckCapitalH]",GenContext[]<>"\[DoubleStruckCapitalI]",GenContext[]<>"\[DoubleStruckCapitalJ]",GenContext[]<>"\[DoubleStruckCapitalK]",GenContext[]<>"\[DoubleStruckCapitalL]",GenContext[]<>"\[DoubleStruckCapitalM]",GenContext[]<>"\[DoubleStruckCapitalN]",GenContext[]<>"\[DoubleStruckCapitalO]",GenContext[]<>"\[DoubleStruckCapitalP]",GenContext[]<>"\[DoubleStruckCapitalQ]",GenContext[]<>"\[DoubleStruckCapitalR]",GenContext[]<>"\[DoubleStruckCapitalS]",GenContext[]<>"\[DoubleStruckCapitalT]",GenContext[]<>"\[DoubleStruckCapitalU]",GenContext[]<>"\[DoubleStruckCapitalV]",GenContext[]<>"\[DoubleStruckCapitalX]",GenContext[]<>"\[DoubleStruckCapitalW]",GenContext[]<>"\[DoubleStruckCapitalY]",GenContext[]<>"\[DoubleStruckCapitalZ]"},
i=internal,
ic=Brown,
iil=Symbol/@{GenContext[]<>"\[ScriptCapitalA]",GenContext[]<>"\[ScriptCapitalB]",GenContext[]<>"\[ScriptCapitalC]",GenContext[]<>"\[ScriptCapitalD]",GenContext[]<>"\[ScriptCapitalE]",GenContext[]<>"\[ScriptCapitalF]",GenContext[]<>"\[ScriptCapitalG]",GenContext[]<>"\[ScriptCapitalH]",GenContext[]<>"\[ScriptCapitalI]",GenContext[]<>"\[ScriptCapitalJ]",GenContext[]<>"\[ScriptCapitalK]",GenContext[]<>"\[ScriptCapitalL]",GenContext[]<>"\[ScriptCapitalM]",GenContext[]<>"\[ScriptCapitalN]",GenContext[]<>"\[ScriptCapitalO]",GenContext[]<>"\[ScriptCapitalP]",GenContext[]<>"\[ScriptCapitalQ]",GenContext[]<>"\[ScriptCapitalR]",GenContext[]<>"\[ScriptCapitalS]",GenContext[]<>"\[ScriptCapitalT]",GenContext[]<>"\[ScriptCapitalU]",GenContext[]<>"\[ScriptCapitalV]",GenContext[]<>"\[ScriptCapitalW]",GenContext[]<>"\[ScriptCapitalX]",GenContext[]<>"\[ScriptCapitalY]",GenContext[]<>"\[ScriptCapitalZ]"}
},
SetBasis[{c,cc,cil},{nl,cl},{f,fc,fil},{s,sc,sil},{i,ic,iil}];
ValidateBasis[];
]


SetBasis[curved_,coordinateList_,flat_,spin_]:=Module[{
c=curved,
cc=Red,
cil=$olution[$manifold,$index],
nl=Table[ii,{ii,0,$olution[$manifold,$dimension]-1}],
cl=coordinateList,
f=flat,
fc=Blue,
fil=Symbol/@{GenContext[]<>"\[GothicA]",GenContext[]<>"\[GothicB]",GenContext[]<>"\[GothicC]",GenContext[]<>"\[GothicD]",GenContext[]<>"\[GothicE]",GenContext[]<>"\[GothicF]",GenContext[]<>"\[GothicG]",GenContext[]<>"\[GothicH]",GenContext[]<>"\[GothicI]",GenContext[]<>"\[GothicJ]",GenContext[]<>"\[GothicK]",GenContext[]<>"\[GothicL]",GenContext[]<>"\[GothicM]",GenContext[]<>"\[GothicN]",GenContext[]<>"\[GothicO]",GenContext[]<>"\[GothicP]",GenContext[]<>"\[GothicQ]",GenContext[]<>"\[GothicR]",GenContext[]<>"\[GothicS]",GenContext[]<>"\[GothicT]",GenContext[]<>"\[GothicU]",GenContext[]<>"\[GothicV]",GenContext[]<>"\[GothicW]",GenContext[]<>"\[GothicX]",GenContext[]<>"\[GothicY]",GenContext[]<>"\[GothicZ]"},
s=spin,
sc=Green,
sil=Symbol/@{GenContext[]<>"\[DoubleStruckCapitalA]",GenContext[]<>"\[DoubleStruckCapitalB]",GenContext[]<>"\[DoubleStruckCapitalC]",GenContext[]<>"\[DoubleStruckCapitalD]",GenContext[]<>"\[DoubleStruckCapitalE]",GenContext[]<>"\[DoubleStruckCapitalF]",GenContext[]<>"\[DoubleStruckCapitalG]",GenContext[]<>"\[DoubleStruckCapitalH]",GenContext[]<>"\[DoubleStruckCapitalI]",GenContext[]<>"\[DoubleStruckCapitalJ]",GenContext[]<>"\[DoubleStruckCapitalK]",GenContext[]<>"\[DoubleStruckCapitalL]",GenContext[]<>"\[DoubleStruckCapitalM]",GenContext[]<>"\[DoubleStruckCapitalN]",GenContext[]<>"\[DoubleStruckCapitalO]",GenContext[]<>"\[DoubleStruckCapitalP]",GenContext[]<>"\[DoubleStruckCapitalQ]",GenContext[]<>"\[DoubleStruckCapitalR]",GenContext[]<>"\[DoubleStruckCapitalS]",GenContext[]<>"\[DoubleStruckCapitalT]",GenContext[]<>"\[DoubleStruckCapitalU]",GenContext[]<>"\[DoubleStruckCapitalV]",GenContext[]<>"\[DoubleStruckCapitalX]",GenContext[]<>"\[DoubleStruckCapitalW]",GenContext[]<>"\[DoubleStruckCapitalY]",GenContext[]<>"\[DoubleStruckCapitalZ]"},
i=$blueprint[$basis,$internal,$ymbol],
ic=$blueprint[$basis,$internal,$color],
iil=$blueprint[$basis,$internal,$index]
},
SetBasis[{c,cc,cil},{nl,cl},{f,fc,fil},{s,sc,sil},{i,ic,iil}];
ValidateBasis[];
]


SetBasis[curved_,coordinateList_]:=Module[{
c=curved,
cc=Red,
cil=$olution[$manifold,$index],
nl=Table[ii,{ii,0,$olution[$manifold,$dimension]-1}],
cl=coordinateList,
f=$blueprint[$basis,$flat,$ymbol],
fc=$blueprint[$basis,$flat,$color],
fil=$blueprint[$basis,$flat,$index],
s=$blueprint[$basis,$spin,$ymbol],
sc=$blueprint[$basis,$spin,$color],
sil=$blueprint[$basis,$spin,$index],
i=$blueprint[$basis,$internal,$ymbol],
ic=$blueprint[$basis,$internal,$color],
iil=$blueprint[$basis,$internal,$index]
},
SetBasis[{c,cc,cil},{nl,cl},{f,fc,fil},{s,sc,sil},{i,ic,iil}];
ValidateBasis[];
]


SetConstant[constantList_]:=Module[{
cl=constantList
},
$olution[$constant]=<|$ymbol->cl|>;
ValidateConstant[];
]


SetFunction[functionList_]:=Module[{
fl=functionList
},
$olution[$function]=<|$ymbol->fl|>;
ValidateFunction[];
]


SetAssumption[coordinateList_,constantList_,functionList_]:=Module[{
col=coordinateList,
ctl=constantList,
ful=functionList
},
$olution[$assumption]=<|
$coordinate->col,
$constant->ctl,
$function->ful
|>;
ValidateAssumption[];
System`$Assumptions =And@@DeleteDuplicates@Join[
{0<$infinity},
$olution[$assumption,$coordinate],
$olution[$assumption,$coordinate]/.ToXCoord,
$olution[$assumption,$constant],
$olution[$assumption,$function]/.Table[(Head/@$olution[$function,$ymbol])[[ii]]->($olution[$function,$ymbol])[[ii]],{ii,1,Length@$olution[$function,$ymbol]}],
$olution[$assumption,$function]/.Table[(Head/@$olution[$function,$ymbol])[[ii]]->($olution[$function,$ymbol])[[ii]],{ii,1,Length@$olution[$function,$ymbol]}]/.ToXCoord
];
]


SetScalar[keyList_,symbolList_,printList_,internalRankList_]:=Module[{
kl=keyList,
sl=symbolList,
pl=printList,
irl=internalRankList
},
$olution[$scalar]=Table[kl[[ii]]-><|$ymbol->sl[[ii]],$print->pl[[ii]],$internalRank->irl[[ii]],$value->$blueprint[$scalar,Symbol,$value]|>,{ii,1,Length@kl}]/.List[x__]:>Association[x];
ValidateScalar[];
]


SetScalar[keyList_,internalRankList_]:=Module[{
kl=keyList,
irl=internalRankList
},
$olution[$scalar]=Table[kl[[ii]]-><|$ymbol->Symbol[ToString[kl[[ii]]]<>ToString[kl[[ii]]]],$print->ToString[kl[[ii]]],$internalRank->irl[[ii]],$value->$blueprint[$scalar,Symbol,$value]|>,{ii,1,Length@kl}]/.List[x__]:>Association[x];
ValidateScalar[];
]


SetForm[keyList_,symbolList_,printList_,rankList_,internalRankList_]:=Module[{
kl=keyList,
sl=symbolList,
pl=printList,
rl=rankList,
irl=internalRankList
},
$olution[$form]=Table[kl[[ii]]-><|$ymbol->sl[[ii]],$print->pl[[ii]],$rank->rl[[ii]],$internalRank->irl[[ii]],$expression->$blueprint[$form,Symbol,$expression]|>,{ii,1,Length@kl}]/.List[x__]:>Association[x];
ValidateForm[];
]


SetForm[keyList_,rankList_,internalRankList_]:=Module[{
kl=keyList,
rl=rankList,
irl=internalRankList
},
$olution[$form]=Table[kl[[ii]]-><|$ymbol->Symbol["f"<>ToString[kl[[ii]]]],$print->ToString[kl[[ii]]],$rank->rl[[ii]],$internalRank->irl[[ii]],$expression->$blueprint[$form,Symbol,$expression]|>,{ii,1,Length@kl}]/.List[x__]:>Association[x];
ValidateForm[];
]


SetTensor[keyList_,symbolList_,printList_,rankList_,internalRankList_,symmetryList_]:=Module[{
kl=keyList,
sl=symbolList,
pl=printList,
rl=rankList,
irl=internalRankList,
syl=symmetryList
},
$olution[$tensor]=Table[kl[[ii]]-><|$ymbol->sl[[ii]],$print->pl[[ii]],$rank->rl[[ii]],$internalRank->irl[[ii]],$ymmetry->syl[[ii]],$value->$blueprint[$tensor,Symbol,$value]|>,{ii,1,Length@kl}]/.List[x__]:>Association[x];
ValidateTensor[];
]


SetTensor[keyList_,rankList_,internalRankList_,symmetryList_]:=Module[{
kl=keyList,
rl=rankList,
irl=internalRankList,
syl=symmetryList
},
$olution[$tensor]=Table[kl[[ii]]-><|$ymbol->Symbol[ToString[kl[[ii]]]<>ToString[kl[[ii]]]],$print->ToString[kl[[ii]]],$rank->rl[[ii]],$internalRank->irl[[ii]],$ymmetry->syl[[ii]],$value->$blueprint[$tensor,Symbol,$value]|>,{ii,1,Length@kl}]/.List[x__]:>Association[x];
ValidateTensor[];
]


SetTensor[symbolList_,printList_]:=Module[{
kl=Keys@$olution[$form],
sl=symbolList,
pl=printList,
rl=Table[$olution[$form,(Keys@$olution[$form])[[ii]],$rank],{ii,1,Length@$olution[$form]}],
irl=Table[$olution[$form,(Keys@$olution[$form])[[ii]],$internalRank],{ii,1,Length@$olution[$form]}],
syl=Table[Antisymmetric[Table[jj,{jj,1,$olution[$form,(Keys@$olution[$form])[[ii]],$rank]}]],{ii,1,Length@$olution[$form]}]/.Antisymmetric[{1}]:>Null
},
$olution[$tensor]=Table[kl[[ii]]-><|$ymbol->sl[[ii]],$print->pl[[ii]],$rank->rl[[ii]],$internalRank->irl[[ii]],$ymmetry->syl[[ii]],$value->$blueprint[$tensor,Symbol,$value]|>,{ii,1,Length@kl}]/.List[x__]:>Association[x];
ValidateTensor[];
]


SetTensor[]:=Module[{
kl=Keys@$olution[$form],
rl=Table[$olution[$form,(Keys@$olution[$form])[[ii]],$rank],{ii,1,Length@$olution[$form]}],
irl=Table[$olution[$form,(Keys@$olution[$form])[[ii]],$internalRank],{ii,1,Length@$olution[$form]}],
syl=Table[Antisymmetric[Table[jj,{jj,1,$olution[$form,(Keys@$olution[$form])[[ii]],$rank]}]],{ii,1,Length@$olution[$form]}]/.Antisymmetric[{1}]:>Null
},
$olution[$tensor]=Table[kl[[ii]]-><|$ymbol->Symbol[ToString[kl[[ii]]]<>ToString[kl[[ii]]]],$print->ToString[kl[[ii]]],$rank->rl[[ii]],$internalRank->irl[[ii]],$ymmetry->syl[[ii]],$value->$blueprint[$tensor,Symbol,$value]|>,{ii,1,Length@kl}]/.List[x__]:>Association[x];
ValidateTensor[];
]


SetMetric[{curvedSymbol_,curvedPrint_,curvedCovD_},{flatSymbol_,flatPrint_}]:=Module[{
gg=curvedSymbol,
gp=curvedPrint,
cd=curvedCovD,
\[Eta]\[Eta]=flatSymbol,
\[Eta]p=flatPrint,
s=(If[$olution[$info,$ignature]==Lorentzian,Return[-1];];If[$olution[$info,$ignature]==Euclidean,Return[1]])
},
$olution[$metric,$curved]=<|
$ignature->s,
$covd->cd,
$ds2->$blueprint[$metric,$curved,$ds2],
$tensor-><|$ymbol->gg,$print->gp,$value->$blueprint[$metric,$curved,$tensor,$value]|>,
$christoffel-><|$ymbol->Symbol["Christoffel"<>ToString[cd]],$value->$blueprint[$metric,$curved,$christoffel,$value]|>,
$riemann-><|$ymbol->Symbol["Riemann"<>ToString[cd]],$value->$blueprint[$metric,$curved,$riemann,$value]|>,
$ricci-><|$ymbol->Symbol["Ricci"<>ToString[cd]],$value->$blueprint[$metric,$curved,$ricci,$value]|>,
$ricciScalar-><|$ymbol->Symbol["RicciScalar"<>ToString[cd]],$value->$blueprint[$metric,$curved,$ricciScalar,$value]|>,
$det-><|$ymbol->Symbol["Det"<>ToString[gg]<>ToString[$olution[$basis,$curved,$ymbol]]],$value->$blueprint[$metric,$curved,$det,$value]|>
|>;
$olution[$metric,$flat]=<|
$tensor-><|$ymbol->\[Eta]\[Eta],$print->\[Eta]p,$value->$blueprint[$metric,$flat,$tensor,$value]|>
|>;
$olution[$metric,$internal]=$blueprint[$metric,$internal];
ValidateMetric[];
]


SetMetric[{curvedSymbol_,curvedPrint_,curvedCovD_}]:=Module[{
gg=curvedSymbol,
gp=curvedPrint,
cd=curvedCovD,
s=(If[$olution[$info,$ignature]==Lorentzian,Return[-1];];If[$olution[$info,$ignature]==Euclidean,Return[1]])
},
$olution[$metric,$curved]=<|
$ignature->s,
$covd->cd,
$ds2->$blueprint[$metric,$curved,$ds2],
$tensor-><|$ymbol->gg,$print->gp,$value->$blueprint[$metric,$curved,$tensor,$value]|>,
$christoffel-><|$ymbol->Symbol["Christoffel"<>ToString[cd]],$value->$blueprint[$metric,$curved,$christoffel,$value]|>,
$riemann-><|$ymbol->Symbol["Riemann"<>ToString[cd]],$value->$blueprint[$metric,$curved,$riemann,$value]|>,
$ricci-><|$ymbol->Symbol["Ricci"<>ToString[cd]],$value->$blueprint[$metric,$curved,$ricci,$value]|>,
$ricciScalar-><|$ymbol->Symbol["RicciScalar"<>ToString[cd]],$value->$blueprint[$metric,$curved,$ricciScalar,$value]|>,
$det-><|$ymbol->Symbol["Det"<>ToString[gg]<>ToString[$olution[$basis,$curved,$ymbol]]],$value->$blueprint[$metric,$curved,$det,$value]|>
|>;
$olution[$metric,$flat]=$blueprint[$metric,$flat];
$olution[$metric,$internal]=$blueprint[$metric,$internal];
ValidateMetric[];
]


SetFrame[{frameSymbolList_,framePrintList_},{vielbeinSymbol_,vielbeinPrint_},{spinConnectionSymbol_,spinConnectionPrint_}]:=Module[{
el=frameSymbolList,
epl=framePrintList,
v=vielbeinSymbol,
vp=vielbeinPrint,
s=spinConnectionSymbol,
sp=spinConnectionPrint
},
$olution[$frame,$form]=Table[(Keys@$olution[$basis,$curved,$coordinate])[[ii]]-><|$ymbol->el[[ii]],$print->epl[[ii]],$expression->$blueprint[$frame,$form,Integer,$expression]|>,{ii,1,Length@$olution[$basis,$curved,$coordinate]}]/.List[x__]:>Association[x];
$olution[$frame,$vielbein]=<|$ymbol->v,$print->vp,$value->$blueprint[$frame,$vielbein,$value]|>;
$olution[$frame,$spinConnection]=<|$ymbol->s,$print->sp,$value->$blueprint[$frame,$spinConnection,$value]|>;
]


SetGamma[]:=Module[{
\[Eta]\[Eta]=$olution[$metric,$flat,$tensor,$ymbol],
gg=$olution[$metric,$curved,$tensor,$ymbol],
dim=$olution[$manifold,$dimension],
cn=Keys@$olution[$basis,$curved,$coordinate]
},
If[dim==5,
$olution[$gamma,$flatGammaU]=<|
cn[[1]]->I KroneckerProduct[PauliMatrix@1,IdentityMatrix@2],
cn[[2]]->KroneckerProduct[PauliMatrix@2,IdentityMatrix@2],
cn[[3]]->KroneckerProduct[PauliMatrix@3,PauliMatrix@1],
cn[[4]]->KroneckerProduct[PauliMatrix@3,PauliMatrix@2],
cn[[5]]->KroneckerProduct[PauliMatrix@3,PauliMatrix@3]
|>;
$olution[$gamma,$flat]=<|
1-><|$ymbol->Symbol["Gamma"<>ToString[\[Eta]\[Eta]]<>"1"],$value->$blueprint[$gamma,$flat,Integer,$value]|>,
2-><|$ymbol->Symbol["Gamma"<>ToString[\[Eta]\[Eta]]<>"2"],$value->$blueprint[$gamma,$flat,Integer,$value]|>,
3-><|$ymbol->Symbol["Gamma"<>ToString[\[Eta]\[Eta]]<>"3"],$value->$blueprint[$gamma,$flat,Integer,$value]|>
|>;
$olution[$gamma,$curved]=<|
1-><|$ymbol->Symbol["Gamma"<>ToString[gg]<>"1"],$value->$blueprint[$gamma,$curved,Integer,$value]|>,
2-><|$ymbol->Symbol["Gamma"<>ToString[gg]<>"2"],$value->$blueprint[$gamma,$curved,Integer,$value]|>,
3-><|$ymbol->Symbol["Gamma"<>ToString[gg]<>"3"],$value->$blueprint[$gamma,$curved,Integer,$value]|>
|>;,
Print["Dimensions different than 5 are still in construction"];
]
]


SetSpinor[keyList_,symbolList_,printList_,typeList_,internalRankList_]:=Module[{
kl=keyList,
sl=symbolList,
pl=printList,
tl=typeList,
irl=internalRankList
},
$olution[$pinor]=Table[kl[[ii]]-><|$ymbol->sl[[ii]],$print->pl[[ii]],$type->tl[[ii]],$internalRank->irl[[ii]],$value->$blueprint[$pinor,Symbol,$value]|>,{ii,1,Length@kl}]/.List[x__]:>Association[x];
]


ContextMergeSymbol[preSymbol_,symbol_]:=Module[{
sys=ToString[symbol],
psys=preSymbol,
context,
bsys
},
If[StringContainsQ[sys,"`"]==True,
bsys=StringDrop[sys,StringPosition[sys,"`"][[-1,-1]]];
context=StringDrop[sys,-(StringLength@sys-StringPosition[sys,"`"][[-1,-1]])];
Return[Symbol[context<>psys<>bsys]];
,
Return[Symbol[psys<>sys]];
]
]


Options[LoadManifold]={Verbose->True};
LoadManifold[OptionsPattern[]]:=Module[{
m=$olution[$manifold,$ymbol],
d=$olution[$manifold,$dimension],
i=$olution[$manifold,$index]
},
If[TrueQ[$olution[$manifold]==$blueprint[$manifold]]==False,
If[ManifoldQ[m]==True,
If[OptionValue[Verbose]==True,Print@@{"Manifold ",FS@m," is already defined"};];
 ];
If[ManifoldQ[m]==False,
DefManifold[m,d,i];
If[OptionValue[Verbose]==True,Print@@{"Defined manifold ",FS@m," of dimension ",FS@d, " with indices ",FS@i};];
]; 
]
]


Options[LoadChart]={Verbose->True};
LoadChart[OptionsPattern[]]:=Module[{
man=$olution[$manifold,$ymbol],
cn=Keys@$olution[$basis,$curved,$coordinate],
xc=Values@$olution[$basis,$curved,$coordinate]//.ToXCoord,
curved=$olution[$basis,$curved,$ymbol],
cc=$olution[$basis,$curved,$color],
(*ChristoffelPDcurved=ContextMergeSymbol["ChristoffelPD",$olution[$basis,$curved,$ymbol]]*)
ChristoffelPDcurved=Symbol@@{"ChristoffelPD"<>ToString[$olution[$basis,$curved,$ymbol]]}
},
If[TrueQ[$olution[$manifold]==$blueprint[$manifold]]==False,
If[TrueQ[$olution[$basis,$curved]==$blueprint[$basis,$curved]]==False,
If[ChartQ[curved]==True,
If[OptionValue[Verbose]==True,Print["Chart ",FS@curved," is already defined"];];
];
If[ChartQ[curved]==False,
DefChart[curved,man,cn,xc,FormatBasis->{"Partials","Differentials"},ChartColor->cc ];
ChristoffelPDcurved[__]:=0;
If[OptionValue[Verbose]==True,Print["Defined ",cc," chart ",FS@curved," with coordinates ",FS@xc," on the manifold ",FS@man," | Set ",FS@ChristoffelPDcurved," to zero" ];];
];
]
]
]


Options[LoadConstant]={Verbose->True};
LoadConstant[OptionsPattern[]]:=Module[{
pcs=$olution[$constant,$ymbol],
cs,
ncs
},
If[TrueQ[$olution[$constant]==$blueprint[$constant]]==False,
If[pcs!={},
cs=Select[pcs,ConstantSymbolQ[#]==True & ];
ncs=Select[pcs,ConstantSymbolQ[#]==False & ];
If[cs=={},
DefConstantSymbol@pcs;
If[OptionValue[Verbose]==True,Print["Defined constant symbols ",FS@pcs ];];
];
If[ncs=={},
If[OptionValue[Verbose]==True,Print["Constant symbols ",FS@pcs," are already defined"];];
];
If[TrueQ[cs!={}]==True&&TrueQ[ncs!={}]==True,
DefConstantSymbol@ncs;
If[OptionValue[Verbose]==True,Print["Defined constant symbols ",FS@ncs," | Constant symbols ",FS@cs," are already defined"];];
];
]
]
]


Options[LoadFunction]={Verbose->True};
LoadFunction[OptionsPattern[]]:=Module[{
psf=Head/@$olution[$function,$ymbol],
sf,
nsf
},
If[TrueQ[$olution[$function]==$blueprint[$function]]==False,
If[psf!={},
sf=Select[psf,ScalarFunctionQ[#]==True &];
nsf=Select[psf,ScalarFunctionQ[#]==False &];
If[sf=={},
DefScalarFunction@psf;
If[OptionValue[Verbose]==True,Print["Defined scalar functions ",FS@psf];];
];
If[nsf=={},
If[OptionValue[Verbose]==True,Print["Scalar functions ",FS@psf," are already defined"];];
];
If[TrueQ[sf!={}]==True&&TrueQ[nsf!={}]==True,
DefScalarFunction@nsf;
If[OptionValue[Verbose]==True,Print["Defined scalar functions ",FS@nsf," | Scalar functions ",FS@sf," are already defined"];];
]; 
] 
]
]


Options[LoadForm]={Verbose->True};
LoadForm[OptionsPattern[]]:=Module[{
man=$olution[$manifold,$ymbol],
pfs=Table[((Values@$olution[$form])[[ii]])[$ymbol],{ii,1,Length@$olution[$form]}],
pfp=Table[((Values@$olution[$form])[[ii]])[$print],{ii,1,Length@$olution[$form]}],
pfr=Table[((Values@$olution[$form])[[ii]])[$rank],{ii,1,Length@$olution[$form]}],
fs,fp,fr,nfs,nfp,nfr,newpos
},
If[TrueQ[$olution[$manifold]==$blueprint[$manifold]]==False,
If[TrueQ[$olution[$form]==$blueprint[$form]]==False,
If[Length@pfs!=0,
fs=Select[pfs,xTensorQ[#]==True &];
nfs=Select[pfs,xTensorQ[#]==False &];
If[fs=={},
Do[
DefDiffForm[pfs[[\[Alpha]\[Alpha]]][],man,pfr[[\[Alpha]\[Alpha]]],PrintAs->pfp[[\[Alpha]\[Alpha]]]];,
{\[Alpha]\[Alpha],1,Length@pfs}
];
If[OptionValue[Verbose]==True,Print["Defined forms ",FS@pfs," of ranks ",FS@pfr," on the manifold ",FS@man ];];
];
If[nfs=={},
If[OptionValue[Verbose]==True,Print["Forms ",FS@fs, " are already defined"];];
];
If[TrueQ[fs!={}]==True&&TrueQ[nfs!={}]==True,
newpos=Flatten@Table[Position[pfs,nfs[[\[Alpha]\[Alpha]]] ],{\[Alpha]\[Alpha],1,Length@nfs}];
nfs=Table[pfs[[newpos[[\[Alpha]\[Alpha]]]]],{\[Alpha]\[Alpha],1,Length@newpos}];
nfr=Table[pfr[[newpos[[\[Alpha]\[Alpha]]]]],{\[Alpha]\[Alpha],1,Length@newpos}];
nfp=Table[pfp[[newpos[[\[Alpha]\[Alpha]]]]],{\[Alpha]\[Alpha],1,Length@newpos}];
Do[
DefDiffForm[nfs[[\[Alpha]\[Alpha]]][],man,nfr[[\[Alpha]\[Alpha]]],PrintAs->nfp[[\[Alpha]\[Alpha]]]];,
{\[Alpha]\[Alpha],1,Length@nfs}
];
If[OptionValue[Verbose]==True,Print["Defined forms ",FS@nfs," of ranks ",FS@nfr," on the manifold ",FS@man," | Forms ",FS@fs," are already defined"];];
];
]
]
] 
]


Options[LoadTensor]={Verbose->True};
LoadTensor[OptionsPattern[]]:=Module[{
man=$olution[$manifold,$ymbol],
pfts=Table[((Values@$olution[$tensor])[[ii]])[$ymbol],{ii,1,Length@$olution[$tensor]}],
pftp=Table[((Values@$olution[$tensor])[[ii]])[$print],{ii,1,Length@$olution[$tensor]}],
pftr=Table[((Values@$olution[$tensor])[[ii]])[$rank],{ii,1,Length@$olution[$tensor]}],
pftsy=Table[((Values@$olution[$tensor])[[ii]])[$ymmetry],{ii,1,Length@$olution[$tensor]}],
fts,ftp,ftr,ftsy,nfts,nftp,nftr,nftsy,newpos
},
If[TrueQ[$olution[$manifold]==$blueprint[$manifold]]==False,
If[TrueQ[$olution[$tensor]==$blueprint[$tensor]]==False,
If[Length@pfts!=0,
fts=Select[pfts,xTensorQ[#]==True &];
nfts=Select[pfts,xTensorQ[#]==False &];
If[fts=={},
Do[
If[TrueQ[pftsy[[\[Alpha]\[Alpha]]]==Null]==True,
DefTensor[pfts[[\[Alpha]\[Alpha]]]@@(-GetIndicesOfVBundle[TangentBundleOfManifold[man],pftr[[\[Alpha]\[Alpha]]]]),man,PrintAs->pftp[[\[Alpha]\[Alpha]]]];,
DefTensor[pfts[[\[Alpha]\[Alpha]]]@@(-GetIndicesOfVBundle[TangentBundleOfManifold[man],pftr[[\[Alpha]\[Alpha]]]]),man,pftsy[[\[Alpha]\[Alpha]]],PrintAs->pftp[[\[Alpha]\[Alpha]]]];
];
,{\[Alpha]\[Alpha],1,Length@pfts}];
If[OptionValue[Verbose]==True,Print["Defined tensors ",FS@pfts," of ranks ",FS@pftr," and symmetries ",FS@pftsy," on the manifold ",FS@man ];];
];
If[nfts=={},
If[OptionValue[Verbose]==True,Print["Tensors ",FS@fts, " are already defined"];];
];
If[TrueQ[fts!={}]==True&&TrueQ[nfts!={}]==True,
newpos=Flatten@Table[Position[pfts,nfts[[\[Alpha]\[Alpha]]] ],{\[Alpha]\[Alpha],1,Length@nfts}];
nfts=Table[pfts[[newpos[[\[Alpha]\[Alpha]]]]],{\[Alpha]\[Alpha],1,Length@newpos}];
nftp=Table[pftp[[newpos[[\[Alpha]\[Alpha]]]]],{\[Alpha]\[Alpha],1,Length@newpos}];
nftr=Table[pftr[[newpos[[\[Alpha]\[Alpha]]]]],{\[Alpha]\[Alpha],1,Length@newpos}];
nftsy=Table[pftsy[[newpos[[\[Alpha]\[Alpha]]]]],{\[Alpha]\[Alpha],1,Length@newpos}];
Do[
If[TrueQ[nftsy[[\[Alpha]\[Alpha]]]==Null]==True,
DefTensor[nfts[[\[Alpha]\[Alpha]]]@@(-GetIndicesOfVBundle[TangentBundleOfManifold[man ],nftr[[\[Alpha]\[Alpha]]]]),man,PrintAs->nftp[[\[Alpha]\[Alpha]]]];,
DefTensor[nfts[[\[Alpha]\[Alpha]]]@@(-GetIndicesOfVBundle[TangentBundleOfManifold[man ],nftr[[\[Alpha]\[Alpha]]]]),man,nftsy[[\[Alpha]\[Alpha]]],PrintAs->nftp[[\[Alpha]\[Alpha]]]];
];
,{\[Alpha]\[Alpha],1,Length@nfts}];
If[OptionValue[Verbose]==True,Print["Defined tensors ",FS@nfts," of ranks ",FS@nftr," and symmetries ",FS@nftsy," on the manifold ",FS@man," | Tensors ",FS@fts," are already defined"];];
];
]; 
]
]
]


Options[LoadMetric]={Verbose->True};
LoadMetric[OptionsPattern[]]:=Module[{
man=$olution[$manifold,$ymbol],
gs=$olution[$metric,$curved,$tensor,$ymbol],
gp=$olution[$metric,$curved,$tensor,$print],
sd=$olution[$metric,$curved,$ignature],
cd=$olution[$metric,$curved,$covd],
ind=GetIndicesOfVBundle[TangentBundleOfManifold[$olution[$manifold,$ymbol]],Length@$olution[$basis,$curved,$index]]
},
If[TrueQ[$olution[$manifold]==$blueprint[$manifold]]==False,
If[TrueQ[$olution[$metric,$curved]==$blueprint[$metric,$curved]]==False,
If[MetricQ[gs ]==True,
If[OptionValue[Verbose]==True,Print["Metric ",FS@gs, " is already defined"];];
];
If[MetricQ[gs ]==False,
DefMetric[sd,gs@@{-ind[[1]],-ind[[2]]},cd,{";","\[Del]"},PrintAs->gp,SymCovDQ->True ];
If[OptionValue[Verbose]==True,Print["Defined metric ",FS@gs, " of signature ",FS@sd," and covariant derivative ",FS@cd," on the manifold ",FS@man];];
]
]
]
]


Options[LoadFrameBundle]={Verbose->True};
LoadFrameBundle[OptionsPattern[]]:=Module[{
ee=$olution[$frame,$vielbein,$ymbol],
ep=$olution[$frame,$vielbein,$print],
eta=$olution[$metric,$flat,$tensor,$ymbol],
etap=$olution[$metric,$flat,$tensor,$print],
ci=$olution[$basis,$curved,$index],
fi=$olution[$basis,$flat,$index]
},
If[TrueQ[$olution[$basis,$curved]==$blueprint[$basis,$curved]]==False,
If[TrueQ[$olution[$basis,$flat]==$blueprint[$basis,$flat]]==False,
If[TrueQ[$olution[$metric,$flat]==$blueprint[$metric,$flat]]==False,
If[TrueQ[$olution[$frame]==$blueprint[$frame]]==False,
If[xTensorQ[ee]==True,
If[OptionValue[Verbose]==True,Print["Vielbein ",FS@ee," with flat metric ",FS@eta," is already defined"];];
];
If[xTensorQ[ee]==False,
DefFrameBundle[ee[-ci[[1]],fi[[1]] ],eta[-fi[[1]],-fi[[2]]],fi,PrintAs->{ep,etap}];
If[OptionValue[Verbose]==True,Print["Defined vielbein ",FS@ee," with flat metric ",FS@eta," and flat indices ",FS@fi ];];
]
]
]
]
]
]


Options[LoadSpinStructure]={Verbose->True};
LoadSpinStructure[OptionsPattern[]]:=Module[{
gg=$olution[$metric,$curved,$tensor,$ymbol],
si=$olution[$basis,$spin,$index],
Gammagg1=(Values@$olution[$gamma,$curved ][[1]])[[1]]
},
If[TrueQ[$olution[$metric,$curved]==$blueprint[$metric,$curved]]==False,
If[TrueQ[$olution[$basis,$spin]==$blueprint[$basis,$spin]]==False,
If[TrueQ[$olution[$gamma]==$blueprint[$gamma]]==False,
If[xTensorQ[Gammagg1]==True,
If[OptionValue[Verbose]==True,Print["Spin structure on the metric ",FS@gg," is already defined"];];
];
If[xTensorQ[Gammagg1]==False,
DefSpinStructure[gg,si];
If[OptionValue[Verbose]==True,Print["Defined spin structure on the metric ",FS@gg," with spin indices ",FS@si ];];
]
]
]
]
]


Options[LoadSpinConnection]={Verbose->True};
LoadSpinConnection[OptionsPattern[]]:=Module[{
\[Omega]=$olution[$frame,$spinConnection,$ymbol],
\[Omega]p=$olution[$frame,$spinConnection,$print],
ci=$olution[$basis,$curved,$index],
fi=$olution[$basis,$flat,$index],
cd=$olution[$metric,$curved,$covd]
},
If[TrueQ[$olution[$metric,$curved]==$blueprint[$metric,$curved]]==False,
If[TrueQ[$olution[$basis,$curved]==$blueprint[$basis,$curved]]==False,
If[TrueQ[$olution[$basis,$flat]==$blueprint[$basis,$flat]]==False,
If[TrueQ[$olution[$frame]==$blueprint[$frame]]==False,
If[xTensorQ[\[Omega]]==True,
If[OptionValue[Verbose]==True,Print["Spin connection ",FS@\[Omega]," is already defined"];];
];
If[xTensorQ[\[Omega]]==False,
DefSpinConnection[\[Omega][-ci[[1]],-fi[[1]],-fi[[2]]],cd,PrintAs->\[Omega]p ];
If[OptionValue[Verbose]==True,Print["Defined spin connection ",FS@\[Omega]," of the covariant derivative ",FS@cd ];];
]
]
]
]
]
]


Options[LoadFrameForm]={Verbose->True};
LoadFrameForm[OptionsPattern[]]:=Module[{
man=$olution[$manifold,$ymbol],
fs=Table[($olution[$frame,$form][[ii]])[$ymbol],{ii,1,Length@$olution[$frame,$form]}],
fp=Table[($olution[$frame,$form][[ii]])[$print],{ii,1,Length@$olution[$frame,$form]}]
},
If[TrueQ[$olution[$manifold]==$blueprint[$manifold]]==False,
If[TrueQ[$olution[$frame]==$blueprint[$frame]]==False,
If[xTensorQ/@fs==ConstantArray[True,Length@fs ],
If[OptionValue[Verbose]==True,Print["Forms ",FS@fs, " are already defined"];];
];
If[xTensorQ/@fs==ConstantArray[False,Length@fs ],
Do[DefDiffForm[fs[[ii]][],man,1,PrintAs->fp[[ii]] ];,{ii,1,Length@fs} ];
If[OptionValue[Verbose]==True,Print["Defined forms ",FS@fs," of degrees ",FS@ConstantArray[1,Length@fs ]," on the manifold ",FS@man ];];
]
]
]
]


Options[LoadSpinor]={Verbose->True};
LoadSpinor[OptionsPattern[]]:=Module[{
man=$olution[$manifold,$ymbol],
ss=Table[($olution[$pinor][[ii]])[$ymbol],{ii,1,Length@$olution[$pinor]}],
sp=Table[($olution[$pinor][[ii]])[$print],{ii,1,Length@$olution[$pinor]}],
st=Table[($olution[$pinor][[ii]])[$type],{ii,1,Length@$olution[$pinor]}],
si=$olution[$basis,$spin,$index]
},
If[TrueQ[$olution[$pinor]==$blueprint[$pinor]]==False,
If[SpinorQ/@ss==ConstantArray[True,Length@ss ],
If[OptionValue[Verbose]==True,Print["Spinors ",FS@ss," are already defined"];];
];
If[SpinorQ/@ss==ConstantArray[False,Length@ss ],
Do[DefSpinor[ss[[ii]][-si[[1]] ],man,SpinorType->st[[ii]],PrintAs->sp[[ii]] ],{ii,1,Length@ss} ];
If[OptionValue[Verbose]==True,Print["Defined spinors ",FS@ss," of types ",FS@st, " on the manifold ",FS@man ];];
];
];
]


Options[LoadBasis]={Verbose->True};
LoadBasis[OptionsPattern[]]:=Module[{
man=$olution[$manifold,$ymbol],
cn=Keys@$olution[$frame,$form],
fs=$olution[$basis,$flat,$ymbol],
fc=$olution[$basis,$flat,$color],
fi=$olution[$basis,$flat,$index],
Fman=ContextMergeSymbol["Frame",$olution[$manifold,$ymbol]],
(*Fman=Symbol@@{"Frame"<>ToString[$olution[$manifold,$ymbol]]},*)
(*ACfs=ContextMergeSymbol["AChristoffelPD",$olution[$basis,$flat,$ymbol]],*)
ACfs=Symbol@@{"AChristoffelPD"<>ToString[$olution[$basis,$flat,$ymbol]]},
ss=$olution[$basis,$spin,$ymbol],
sc=$olution[$basis,$spin,$color],
si=$olution[$basis,$spin,$index],
Sman=ContextMergeSymbol["Spin",$olution[$manifold,$ymbol]],
(*Sman=Symbol@@{"Spin"<>ToString[$olution[$manifold,$ymbol]]},*)
(*ACss=ContextMergeSymbol["AChristoffelPD",$olution[$basis,$spin,$ymbol]]*)
ACss=Symbol@@{"AChristoffelPD"<>ToString[$olution[$basis,$spin,$ymbol]]}
},
If[TrueQ[$olution[$manifold]==$blueprint[$manifold]]==False,
If[TrueQ[$olution[$basis,$flat]==$blueprint[$basis,$flat]]==False,
If[TrueQ[$olution[$basis,$spin]==$blueprint[$basis,$spin]]==False,
If[TrueQ[$olution[$frame]==$blueprint[$frame]]==False,
If[BasisQ[fs ]==True,
If[OptionValue[Verbose]==True,Print["Basis ",FS@fs," is already defined"];];,
DefBasis[fs,Fman,cn,BasisColor->fc ];
ACfs[__ ]:=0;
If[OptionValue[Verbose]==True,Print["Defined ",fc," basis ",FS@fs," on the vector bundle ",FS@Fman," | Set ",FS@ACfs," to zero" ];];
];
If[BasisQ[ss ]==True,
If[OptionValue[Verbose]==True,Print["Basis ",FS@ss," is already defined"];];,
DefBasis[ss,Sman,Table[jj,{jj,1,DimOfVBundle[Sman]} ],BasisColor->sc ];
ACss[__ ]:=0;
If[OptionValue[Verbose]==True,Print["Defined " ,sc," basis ",FS@ss," on the vector bundle ",FS@Sman," | Set ",FS@ACss," to zero" ];];
];
]
]
]
]
]


LoadAppendConstant[newList_]:=Module[{
nl=newList,
old=$olution[$constant,$ymbol]
},
If[TrueQ[$olution[$constant]==$blueprint[$constant]]==False,
$olution[$constant,$ymbol]=DeleteDuplicates@Flatten@Append[$olution[$constant,$ymbol],nl];,
SetConstant[nl];
];
CheckAbort[ValidateConstant[],
$olution[$constant,$ymbol]=old;
];
LoadConstant[];
]


LoadAppendFunction[newFunctionList_]:=Module[{
nl=newFunctionList,
old=$olution[$function,$ymbol]
},
$olution[$function,$ymbol]=DeleteDuplicates@Flatten@Append[$olution[$function,$ymbol],nl];
CheckAbort[ValidateFunction[],
$olution[$function,$ymbol]=old;
];
LoadFunction[];
]


LoadAppendForm[keyList_,symbolList_,printList_,rankList_,internalRankList_]:=Module[{
kl=keyList,
sl=symbolList,
pl=printList,
rl=rankList,
irl=internalRankList,
old=$olution[$form]
},
If[TrueQ[$olution[$form]==$blueprint[$form]]==False,
$olution[$form]=
Append[$olution[$form],
Table[kl[[ii]]-><|$ymbol->sl[[ii]],$print->pl[[ii]],$rank->rl[[ii]],$internalRank->irl[[ii]],$expression->$blueprint[$form,Symbol,$expression]|>,{ii,1,Length@kl}]
];,
SetForm[kl,sl,pl,rl,irl];
];
CheckAbort[ValidateForm[],
$olution[$form]=old;
];
LoadForm[];
]


LoadAppendForm[keyList_,rankList_,internalRankList_]:=Module[{
kl=keyList,
rl=rankList,
irl=internalRankList,
old=$olution[$form]
},
If[TrueQ[$olution[$form]==$blueprint[$form]]==False,
$olution[$form]=
Append[$olution[$form],
Table[kl[[ii]]-><|$ymbol->Symbol["f"<>ToString[kl[[ii]]]],$print->ToString[kl[[ii]]],$rank->rl[[ii]],$internalRank->irl[[ii]],$expression->$blueprint[$form,Symbol,$expression]|>,{ii,1,Length@kl}]
];,
SetForm[kl,rl,irl];
];
CheckAbort[ValidateForm[],
$olution[$form]=old;
];
LoadForm[];
]


LoadAppendTensor[keyList_,symbolList_,printList_,rankList_,internalRankList_,symmetryList_]:=Module[{
kl=keyList,
sl=symbolList,
pl=printList,
rl=rankList,
irl=internalRankList,
syl=symmetryList,
old=$olution[$tensor]
},
If[TrueQ[$olution[$tensor]==$blueprint[$tensor]]==False,
$olution[$tensor]=
Append[$olution[$tensor],
Table[kl[[ii]]-><|$ymbol->sl[[ii]],$print->pl[[ii]],$rank->rl[[ii]],$internalRank->irl[[ii]],$ymmetry->syl[[ii]],$value->$blueprint[$tensor,Symbol,$value]|>,{ii,1,Length@kl}]
];,
SetTensor[kl,sl,pl,rl,irl,syl];
];
CheckAbort[ValidateTensor[],
$olution[$tensor]=old;
];
LoadTensor[];
]


LoadAppendTensor[keyList_,rankList_,internalRankList_,symmetryList_]:=Module[{
kl=keyList,
rl=rankList,
irl=internalRankList,
syl=symmetryList,
old=$olution[$tensor]
},
If[TrueQ[$olution[$tensor]==$blueprint[$tensor]]==False,
$olution[$tensor]=
Append[$olution[$tensor],
Table[kl[[ii]]-><|$ymbol->Symbol[ToString[kl[[ii]]]<>ToString[kl[[ii]]]],$print->ToString[kl[[ii]]],$rank->rl[[ii]],$internalRank->irl[[ii]],$ymmetry->syl[[ii]],$value->$blueprint[$tensor,Symbol,$value]|>,{ii,1,Length@kl}]
];,
SetTensor[kl,rl,irl,syl];
];
CheckAbort[ValidateTensor[],
$olution[$tensor]=old;
];
LoadTensor[];
]


LoadAppendRule[key_,value_]:=Module[{
tmp
},
If[TrueQ[ToString[Head@value]==ToString[Rule]],
tmp={value};,
tmp=value
];
If[MemberQ[Keys@$olution[$rule],key]==False,
$olution[$rule]=Append[$olution[$rule],key->tmp];
,
Do[
If[MemberQ[Keys@$olution[$rule,key],(Keys@tmp)[[ii]]],
$olution[$rule,key]=#/. HoldPattern[#2->_]:>(#2->#3)&@@{$olution[$rule,key],(Keys@tmp)[[ii]],(Values@tmp)[[ii]]};
,
$olution[$rule,key]=DeleteDuplicates@Append[$olution[$rule,key],tmp[[ii]]];
]
,
{ii,1,Length@Keys@tmp}
]
]
]


LoadAppendAssumption[$constant,assumptionList_]:=Module[{
al=assumptionList,
old=$olution[$assumption]
},
$olution[$assumption,$constant]=DeleteDuplicates@Flatten@Append[$olution[$assumption,$constant],al];
CheckAbort[ValidateAssumption[],
$olution[$assumption]=old;
];
System`$Assumptions =And@@DeleteDuplicates@Join[
{0<$infinity},
$olution[$assumption,$coordinate],
$olution[$assumption,$coordinate]/.ToXCoord,
$olution[$assumption,$constant],
$olution[$assumption,$function]/.Table[(Head/@$olution[$function,$ymbol])[[ii]]->($olution[$function,$ymbol])[[ii]],{ii,1,Length@$olution[$function,$ymbol]}],
$olution[$assumption,$function]/.Table[(Head/@$olution[$function,$ymbol])[[ii]]->($olution[$function,$ymbol])[[ii]],{ii,1,Length@$olution[$function,$ymbol]}]/.ToXCoord
];
]


UnloadDeleteConstant[deleteList_]:=Module[{
dl=deleteList
},
If[SubsetQ[$olution[$constant,$ymbol],dl],
$olution[$constant,$ymbol]=DeleteCases[$olution[$constant,$ymbol],Alternatives@@dl];
UndefConstantSymbol/@dl;
];
LoadConstant[];
]


UnloadDeleteFunction[deleteList_]:=Module[{
dl=deleteList
},
If[SubsetQ[$olution[$function,$ymbol],dl],
$olution[$function,$ymbol]=DeleteCases[$olution[$function,$ymbol],Alternatives@@dl];
UndefScalarFunction/@Head/@dl;
];
LoadFunction[];
]


UnloadDeleteForm[keyList_]:=Module[{
kl=keyList,
sl=Table[$olution[$form,keyList[[ii]],$ymbol],{ii,1,Length@keyList}]
},
If[SubsetQ[Keys@$olution[$form],kl],
$olution[$form]=KeyDrop[$olution[$form],kl];
UndefDiffForm/@Table[sl[[ii]],{ii,1,Length@sl}];
];
LoadForm[];
]


UnloadDeleteTensor[keyList_]:=Module[{
kl=keyList,
sl=Table[$olution[$tensor,keyList[[ii]],$ymbol],{ii,1,Length@keyList}]
},
If[SubsetQ[Keys@$olution[$tensor],kl],
$olution[$tensor]=KeyDrop[$olution[$tensor],kl];
UndefTensor/@Table[sl[[ii]],{ii,1,Length@sl}];
];
LoadTensor[];
]


UnloadDeleteRule[keyList_]:=Module[{
kl=keyList
},
If[Length@keyList==0,
If[MemberQ[Keys@$olution[$rule],kl],
$olution[$rule]=KeyDrop[$olution[$rule],kl];
];
If[SubsetQ[Keys@$olution[$rule],kl],
$olution[$rule]=KeyDrop[$olution[$rule],kl];
];
]
]


UnloadDeleteRule[key_,elementKey_]:=Module[{
},
If[MemberQ[Keys@$olution[$rule],key],
$olution[$rule,key]=KeyDrop[$olution[$rule,key],elementKey]/.Association[x__]:>List[x];
];
]


UnloadDeleteAssumption[$constant,deleteList_]:=Module[{
dl=deleteList
},
If[SubsetQ[$olution[$assumption,$constant],dl],
$olution[$assumption,$constant]=DeleteCases[$olution[$assumption,$constant],Alternatives@@dl];
];
System`$Assumptions =And@@DeleteDuplicates@Join[
{0<$infinity},
$olution[$assumption,$coordinate],
$olution[$assumption,$coordinate]/.ToXCoord,
$olution[$assumption,$constant],
$olution[$assumption,$function]/.Table[(Head/@$olution[$function,$ymbol])[[ii]]->($olution[$function,$ymbol])[[ii]],{ii,1,Length@$olution[$function,$ymbol]}],
$olution[$assumption,$function]/.Table[(Head/@$olution[$function,$ymbol])[[ii]]->($olution[$function,$ymbol])[[ii]],{ii,1,Length@$olution[$function,$ymbol]}]/.ToXCoord
];
]


Options[Load$olution]={Verbose->True};
Load$olution[OptionsPattern[]]:=Module[{
},
LoadManifold[Verbose->OptionValue[Verbose]];
LoadConstant[Verbose->OptionValue[Verbose]];
LoadFunction[Verbose->OptionValue[Verbose]];
LoadForm[Verbose->OptionValue[Verbose]];
LoadTensor[Verbose->OptionValue[Verbose]];
LoadMetric[Verbose->OptionValue[Verbose]];
LoadChart[Verbose->OptionValue[Verbose]];
LoadFrameBundle[Verbose->OptionValue[Verbose]];
LoadSpinStructure[Verbose->OptionValue[Verbose]];
LoadSpinConnection[Verbose->OptionValue[Verbose]];
LoadFrameForm[Verbose->OptionValue[Verbose]];
LoadSpinor[Verbose->OptionValue[Verbose]];
LoadBasis[Verbose->OptionValue[Verbose]];
]


ValidateSaveSolution::collide="You can only overwrite this solution with prefix `1`, or save it with an entirely new prefix";


SaveSolution[prefix_]:=Module[{
dir=FileNameJoin[{
Directory[],
$olution[$info,$name],
$olution[$info,$identifier],
$olution[$info,$coordinateSystem],
ToString[$olution[$info,$ignature]],
ToString[prefix]
}],
upDir=FileNameJoin[{
Directory[],
$olution[$info,$name],
$olution[$info,$identifier],
$olution[$info,$coordinateSystem],
ToString[$olution[$info,$ignature]]
}],
dirInit=FileNameJoin[{
Directory[],
$olution[$info,$name],
$olution[$info,$identifier],
$olution[$info,$coordinateSystem],
ToString[$olution[$info,$ignature]],
ToString[prefix]<>"_Init"
}],
init="Init.m",
old=$olution,
existingPrefixes,
putName,
choice
},
existingPrefixes=
DeleteCases[$prefix]@(
FileNameSplit[#][[-1]]&/@
DeleteCases[FileNames[All,upDir],_?(StringContainsQ[#,"Init"]&)]
);
If[MemberQ[existingPrefixes,prefix],
choice=ChoiceDialog[{"You are about to overwrite an existing solution with prefix ",FS@prefix," starting from a solution with prefix",FS@$prefix," Are you sure you want to continue?"}];
If[choice==True,
Quiet[CreateDirectory[dir]];
System`$Context="Global`";
putName=FileNameJoin[{dir,StringReplace[DateString[{"ISODate","_","Time"}],":"->"-"]<>".m" }];
Put[$olution,putName];
System`$Context=GenContext[];
If[TrueQ[Length@FileNames[All,dir]>5]==True,
DeleteFile[Take[Sort[FileNames[All,dir]],1][[1]]];
];
Quiet[CreateDirectory[dirInit]];
ToInitial[];
System`$Context="Global`";
Put[$olution,FileNameJoin[{dirInit,init}]];
System`$Context=GenContext[];
$olution=old;
Print["Saved ",FB@"$olution" ," under the file name ",FS@putName];
]
,
Quiet[CreateDirectory[dir]];
System`$Context="Global`";
putName=FileNameJoin[{dir,StringReplace[DateString[{"ISODate","_","Time"}],":"->"-"]<>".m" }];
Put[$olution,putName];
System`$Context=GenContext[];
If[TrueQ[Length@FileNames[All,dir]>5]==True,
DeleteFile[Take[Sort[FileNames[All,dir]],1][[1]]];
];
Quiet[CreateDirectory[dirInit]];
ToInitial[];
System`$Context="Global`";
Put[$olution,FileNameJoin[{dirInit,init}]];
System`$Context=GenContext[];
$olution=old;
Print["Saved ",FB@"$olution" ," under the file name ",FS@putName];
]
]


SaveSolution[]:=SaveSolution[$prefix]


Options[Solution]={Version->1,ChangeContext(*here*)->True,ChangeCoord(*here2*)->True};
Solution[{name_,identifier_,coordinateSystem_,signature_,prefix_},keyList_,OptionsPattern[]]:=Module[{
n=ToString[name],
i=ToString[identifier],
c=ToString[coordinateSystem],
s=ToString[signature],
p=ToString[prefix],
v=OptionValue[Version],
dirInit=ToString[prefix]<>"_Init",
init="Init.m",
targetContext=ToString[name]<>"`"<>ToString[identifier]<>"`"<>ToString[coordinateSystem]<>"`"<>ToString[signature]<>"`",
targetCoordList,
old=$olution,
oldContext=GenContext[],
ret,
mkl
},
(*prepare stuff from the target input*)
$olution=Get[FileNameJoin[{Directory[],n,i,c,s,dirInit,init}]];
targetCoordList=ToString/@Values@$olution[$basis,$curved,$coordinate];
mkl=If[TrueQ[Head@#==Symbol]&&!StringContainsQ[ToString@#,"$"],Symbol[targetContext<>ToString@#],#]&/@keyList;
(*Print[Symbol[targetContext<>ToString@#]&/@keyList];*)
(*load the new new solution, prepare the return and set $olution to old*)
System`$Context=GenContext[];
Load$olution[Verbose->False];
System`$Context=oldContext;
System`$Assumptions =And@@DeleteDuplicates@Join[
Level[System`$Assumptions,1],
{0<$infinity},
$olution[$assumption,$coordinate],
$olution[$assumption,$coordinate]/.ToXCoord,
$olution[$assumption,$constant],
$olution[$assumption,$function]/.Table[(Head/@$olution[$function,$ymbol])[[ii]]->($olution[$function,$ymbol])[[ii]],{ii,1,Length@$olution[$function,$ymbol]}],
$olution[$assumption,$function]/.Table[(Head/@$olution[$function,$ymbol])[[ii]]->($olution[$function,$ymbol])[[ii]],{ii,1,Length@$olution[$function,$ymbol]}]/.ToXCoord
];
ret=Get[Take[ReverseSort[FileNames[All,FileNameJoin[{Directory[],n,i,c,s,p}]]]][[v]]]@@mkl;
$olution=old;
(*return ifs*)
If[OptionValue[ChangeContext(*here*)]==False&&OptionValue[ChangeCoord(*here2*)]==False,
Return[ret];
];
If[OptionValue[ChangeContext(*here*)]==True&&OptionValue[ChangeCoord(*here2*)]==False,
If[TrueQ[Head@ret==Association],
ret=ret/.Association[x__]:>List[x]/.ChangeContext[{n,i,c,s},targetCoordList]/.List[x__]:>Association[x];
Return[ret];
,
Return[ret/.ChangeContext[{n,i,c,s},targetCoordList]];
]
];
If[OptionValue[ChangeContext(*here*)]==True&&OptionValue[ChangeCoord(*here2*)]==True,
If[TrueQ[Head@ret==Association],
ret=ret/.Association[x__]:>List[x]/.ChangeContext[{n,i,c,s},targetCoordList]/.ChangeXCoord[{n,i,c,s}]/.ChangeCoord[{n,i,c,s}]/.List[x__]:>Association[x];
Return[ret]
,
Return[ret/.ChangeContext[{n,i,c,s},targetCoordList]/.ChangeXCoord[{n,i,c,s}]/.ChangeCoord[{n,i,c,s}]];
]
]
]


Solution[{name_,identifier_,coordinateSystem_,signature_},keyList_,OptionsPattern[]]:=Solution[{name,identifier,coordinateSystem,signature,Default},keyList,Version->OptionValue[Version],ChangeContext(*here*)->OptionValue[ChangeContext(*here*)],ChangeCoord(*here2*)->OptionValue[ChangeCoord(*here2*)]]


(*Solution[{name_,identifier_,coordinateSystem_,signature_,prefix_},OptionsPattern[]]:=Solution[{name,identifier,coordinateSystem,signature,prefix},{},Version\[Rule]OptionValue[Version],ChangeContextQ\[Rule]OptionValue[ChangeContextQ],ChangeCoordQ\[Rule]OptionValue[ChangeCoordQ]]*)


(*Solution[{name_,identifier_,coordinateSystem_,signature_},OptionsPattern[]]:=Solution[{name,identifier,coordinateSystem,signature,"Default"},{},Version\[Rule]OptionValue[Version],ChangeContextQ\[Rule]OptionValue[ChangeContextQ],ChangeCoordQ\[Rule]OptionValue[ChangeCoordQ]]*)


Options[SaveCoordinateTransformation]={ChangeContext(*here*)->True};
SaveCoordinateTransformation[{name_,identifier_,coordinateSystem_,signature_},coordinateTransformation_,OptionsPattern[]]:=Module[{
nct=ToString[name]<>"`"<>ToString[identifier]<>"`"<>ToString[coordinateSystem]<>"`"<>ToString[signature]<>"`",
oco=Values@$olution[$basis,$curved,$coordinate],
nco=Symbol/@Table[
StringDrop[(ToString/@Values@Solution[{name,identifier,coordinateSystem,signature},{$basis,$curved,$coordinate},ChangeContext(*here*)->False,ChangeCoord(*here2*)->False])[[ii]],(DeleteDuplicates[StringPosition[(ToString/@Values@Solution[{name,identifier,coordinateSystem,signature},{$basis,$curved,$coordinate},ChangeContext(*here*)->False,ChangeCoord(*here2*)->False])[[ii]],"`"][[-1]]])[[1]]],{ii,1,Length@(ToString/@Values@Solution[{name,identifier,coordinateSystem,signature},{$basis,$curved,$coordinate},ChangeContext(*here*)->False,ChangeCoord(*here2*)->False])}],
dirct=FileNameJoin[{
Directory[],
"CoordinateTransformations"
}],
ctname=System`$Context<>"->"<>ToString[name]<>"`"<>ToString[identifier]<>"`"<>ToString[coordinateSystem]<>"`"<>ToString[signature]<>"`"<>".m",
kcot=Keys@coordinateTransformation,
vcot=Values@coordinateTransformation,
toxcoord,
cc,
ret,
xret
},
toxcoord=Table[nco[[ii]]->nco[[ii]][],{ii,1,Length@nco}];
cc=Table[nco[[ii]]->Symbol@(nct<>ToString[nco[[ii]]]),{ii,1,Length@nco}];
If[OptionValue[ChangeContext(*here*)]==True,
ret=Table[(kcot)[[ii]]->(vcot/.cc/.ChangeContext[{name,identifier,coordinateSystem,signature},ChangeCoord(*here2*)->False,Reverse->True])[[ii]],{ii,1,Length@kcot}];
xret=Table[(kcot/.ToXCoord)[[ii]]->(vcot/.toxcoord/.cc/.ChangeContext[{name,identifier,coordinateSystem,signature},ChangeCoord(*here2*)->False,Reverse->True])[[ii]],{ii,1,Length@kcot}];,
ret=Table[(kcot)[[ii]]->(vcot/.cc)[[ii]],{ii,1,Length@kcot}];
xret=Table[(kcot/.ToXCoord)[[ii]]->(vcot/.toxcoord/.cc)[[ii]],{ii,1,Length@kcot}];
];
System`$Context="Global`";
Quiet[CreateDirectory[dirct]];
Put[
<|0->ret,1->xret|>,FileNameJoin[{dirct,ctname}]
];
System`$Context=GenContext[];
]


ChangeContext[{name_,identifier_,coordinateSystem_,signature_},oldCoordList_]:=Module[{
n=ToString[name],
i=ToString[identifier],
c=ToString[coordinateSystem],
s=ToString[signature],
targetContext=ToString[name]<>"`"<>ToString[identifier]<>"`"<>ToString[coordinateSystem]<>"`"<>ToString[signature]<>"`",
nct=ToString[name]<>"`"<>ToString[identifier]<>"`"<>ToString[coordinateSystem]<>"`"<>ToString[signature]<>"`",
syli,
nsyli,
dirct=FileNameJoin[{
Directory[],
"CoordinateTransformations"
}]
},
syli=Complement[DeleteCases[Names[targetContext<>"*"],_?(StringContainsQ[#,"$"]&)],oldCoordList];
nsyli=Table[System`$Context<>StringDrop[syli[[ii]],StringLength@targetContext],{ii,1,Length@syli}];
Return[
Table[Symbol@syli[[ii]]->Symbol@nsyli[[ii]],{ii,1,Length@syli}]
];
]


Options[ChangeContext]={ChangeCoord(*here2*)->True,Reverse->False};
ChangeContext[{name_,identifier_,coordinateSystem_,signature_},ChangeCoord(*here2*)->False]:=ChangeContext[{name,identifier,coordinateSystem,signature},Values@Solution[{name,identifier,coordinateSystem,signature},{$basis,$curved,$coordinate},ChangeContext(*here*)->False,ChangeCoord(*here2*)->False]];
ChangeContext[{name_,identifier_,coordinateSystem_,signature_},ChangeCoord(*here2*)->False,Reverse->True]:=
(AssociationMap[Reverse,ChangeContext[{name,identifier,coordinateSystem,signature},ChangeCoord(*here2*)->False]/.List[x__]:>Association[x]]/.Association[x__]:>List[x])


ChangeCoord[{name_,identifier_,coordinateSystem_,signature_}]:=Module[{
dirct=FileNameJoin[{
Directory[],
"CoordinateTransformations"
}],
ctname=ToString[name]<>"`"<>ToString[identifier]<>"`"<>ToString[coordinateSystem]<>"`"<>ToString[signature]<>"`"<>"->"<>System`$Context<>".m"
},
If[FileExistsQ[FileNameJoin[{dirct,ctname}]],
Return[
Get[FileNameJoin[{dirct,ctname}]][0]
];,
Print["The coordinate transformation ",FS@ctname," doesn't exist | Did not change coordinates"];
Return[{}];
]
]


ChangeXCoord[{name_,identifier_,coordinateSystem_,signature_}]:=Module[{
dirct=FileNameJoin[{
Directory[],
"CoordinateTransformations"
}],
ctname=ToString[name]<>"`"<>ToString[identifier]<>"`"<>ToString[coordinateSystem]<>"`"<>ToString[signature]<>"`"<>"->"<>System`$Context<>".m"
},
If[FileExistsQ[FileNameJoin[{dirct,ctname}]],
Return[
Get[FileNameJoin[{dirct,ctname}]][1]
];,
Print["The coordinate transformation ",FS@ctname," doesn't exist | Did not change coordinates"];
Return[{}];
]
]


ValidateSolution[]:=Module[{
},
ValidateInfo[];
ValidateManifold[];
ValidateBasis[];
ValidateConstant[];
ValidateFunction[];
ValidateAssumption[];
ValidateScalar[];
ValidateForm[];
ValidateTensor[];
ValidateMetric[];
ValidateFrame[];
ValidateGamma[];
ValidateSpinor[];
]


AttachTVs[keyList_,blueprintKeyList_]:=Module[{
sy,
vidl,
cl,
frl
},
If[TrueQ[($olution@@Join[keyList,{$value}])==($blueprint@@Join[blueprintKeyList,{$value}])]==False,
sy=$olution@@Join[keyList,{$ymbol}];
vidl=Keys@($olution@@Join[keyList,{$value}]);
cl=Table[Level[(Keys@($olution@@Join[keyList,{$value}]))[[ii]],1][[2]],{ii,1,Length@($olution@@Join[keyList,{$value}])}];
frl=Values@($olution@@Join[keyList,{$value}]);
TensorValIDs[sy]^=vidl;
Do[
Evaluate@sy/:TensorValues[Evaluate@sy,cl[[ii]]]=Evaluate@frl[[ii]],
{ii,1,Length@vidl}
]
];
]


Options[LoadSolution]={Version->1};
LoadSolution[{name_,identifier_,coordinateSystem_,signature_,prefix_},OptionsPattern[]]:=Module[{
n=ToString[name],
i=ToString[identifier],
c=ToString[coordinateSystem],
s=ToString[signature],
p=ToString[prefix],
v=OptionValue[Version],
dirInit=ToString[prefix]<>"_Init",
init="Init.m"
},
$prefix=p;
$olution=Get[FileNameJoin[{Directory[],n,i,c,s,dirInit,init}]];
System`$Context=GenContext[];
Load$olution[Verbose->True];
$olution=Get[Take[ReverseSort[FileNames[All,FileNameJoin[{Directory[],n,i,c,s,p}]]]][[v]]];
System`$Assumptions =And@@DeleteDuplicates@Join[
{0<$infinity},
$olution[$assumption,$coordinate],
$olution[$assumption,$coordinate]/.ToXCoord,
$olution[$assumption,$constant],
$olution[$assumption,$function]/.Table[(Head/@$olution[$function,$ymbol])[[ii]]->($olution[$function,$ymbol])[[ii]],{ii,1,Length@$olution[$function,$ymbol]}],
$olution[$assumption,$function]/.Table[(Head/@$olution[$function,$ymbol])[[ii]]->($olution[$function,$ymbol])[[ii]],{ii,1,Length@$olution[$function,$ymbol]}]/.ToXCoord
];
Do[
AttachTVs[{$tensor,(Keys@$olution[$tensor])[[\[Alpha]\[Alpha]]]},{$tensor,Symbol}];,
{\[Alpha]\[Alpha],1,Length@$olution[$tensor]}
];
AttachTVs[{$metric,$curved,$tensor},{$metric,$curved,$tensor}];
AttachTVs[{$metric,$curved,$christoffel},{$metric,$curved,$christoffel}];
AttachTVs[{$metric,$curved,$riemann},{$metric,$curved,$riemann}];
AttachTVs[{$metric,$curved,$ricci},{$metric,$curved,$ricci}];
AttachTVs[{$metric,$flat,$tensor},{$metric,$flat,$tensor}];
AttachTVs[{$frame,$vielbein},{$frame,$vielbein}];
AttachTVs[{$frame,$spinConnection},{$frame,$spinConnection}];
Do[
AttachTVs[{$gamma,$flat,(Keys@$olution[$gamma,$flat])[[\[Alpha]\[Alpha]]]},{$gamma,$flat,Integer}];,
{\[Alpha]\[Alpha],1,Length@$olution[$gamma,$flat]}
];
Do[
AttachTVs[{$gamma,$curved,(Keys@$olution[$gamma,$curved])[[\[Alpha]\[Alpha]]]},{$gamma,$curved,Integer}];,
{\[Alpha]\[Alpha],1,Length@$olution[$gamma,$curved]}
];
Do[
AttachTVs[{$pinor,(Keys@$olution[$pinor])[[\[Alpha]\[Alpha]]]},{$pinor,Symbol}];,
{\[Alpha]\[Alpha],1,Length@$olution[$pinor]}
];
Print["Loaded solution version ",FS@v," from ",FS@FileNameJoin[{Directory[],n,i,c,s,p}]];
]


LoadSolution[{name_,identifier_,coordinateSystem_,signature_},OptionsPattern[]]:=LoadSolution[{name,identifier,coordinateSystem,signature,Default},Version->OptionValue[Version]]


ButtonLoadSolution[fileName_]:=Module[{
n=FileNameSplit[fileName][[-6]],
i=FileNameSplit[fileName][[-5]],
c=FileNameSplit[fileName][[-4]],
s=FileNameSplit[fileName][[-3]],
p=FileNameSplit[fileName][[-2]],
v
},
If[StringContainsQ[fileName,"Init.m"],
Button["Load Init",
$olution=Get[fileName];
System`$Context=GenContext[];
Load$olution[Verbose->True];,
Background->LightBlue
]
,
v=(Flatten@Position[ReverseSort[FileNames[All,FileNameJoin[{Directory[],n,i,c,s,p}]]],fileName])[[1]];
Button["Load version "<>ToString[v],
LoadSolution[{n,i,c,s,p},Version->v];,
Background->LightBlue
]
]
]


Options[DeleteSolution]={Version->5};
DeleteSolution[{name_,identifier_,coordinateSystem_,signature_,prefix_},OptionsPattern[]]:=Module[{
n=ToString[name],
i=ToString[identifier],
c=ToString[coordinateSystem],
s=ToString[signature],
p=ToString[prefix],
v=OptionValue[Version],
fn,
choice,
dirInit=ToString[prefix]<>"_Init"
},
fn=Take[ReverseSort[FileNames[All,FileNameJoin[{Directory[],n,i,c,s,p}]]]][[v]];
If[FileExistsQ[fn],
choice=ChoiceDialog[{"You are about to delete ",FS@fn}];
If[choice==True,
DeleteFile[fn];
If[FileNames[All,FileNameJoin[{Directory[],n,i,c,s,p}]]=={},
DeleteDirectory[FileNameJoin[{Directory[],n,i,c,s,p}]];
DeleteDirectory[FileNameJoin[{Directory[],n,i,c,s,dirInit}],DeleteContents->True];
Print["Deleted ",FS@fn," and the associated empty directories"];
,
Print["Deleted ",FS@fn];
]
]
];
]


ButtonDeleteSolution[fileName_]:=Module[{
n=FileNameSplit[fileName][[-6]],
i=FileNameSplit[fileName][[-5]],
c=FileNameSplit[fileName][[-4]],
s=FileNameSplit[fileName][[-3]],
p=FileNameSplit[fileName][[-2]],
v
},
If[StringContainsQ[fileName,"Init.m"],
Button["Nothing",Background->LightGreen]
,
v=(Flatten@Position[ReverseSort[FileNames[All,FileNameJoin[{Directory[],n,i,c,s,p}]]],fileName])[[1]];
Button["Delete version "<>ToString[v],
DeleteSolution[{n,i,c,s,p},Version->v];,
Method->"Queued",Background->LightRed
]
]
]


SaveGenerator[]:=Module[{
gen="Generator",
n=$olution[$info,$name],
i=$olution[$info,$identifier],
c=$olution[$info,$coordinateSystem],
s=ToString[$olution[$info,$ignature]],
currentPath=Quiet[NotebookFileName[]],
targetPath,
choice
},
targetPath=FileNameJoin[{ParentDirectory[Directory[]],gen,n<>"_"<>i<>"_"<>c<>"_"<>s<>".nb"}];
If[ToString[currentPath]==ToString[$Failed],
NotebookSave[InputNotebook[],targetPath];
,
If[currentPath!=targetPath,
choice=ChoiceDialog[{"You are currently working with notebook located at ",FS@currentPath," You are now attempting to overwrite (if it exists) ",FS@targetPath," Are you sure you want to continue?"}];
If[choice==True,
NotebookSave[InputNotebook[],targetPath];
]
];
]
]


SaveExample[directoryName_,fileName_]:=Module[{
ex="Examples",
fn=ToString[fileName],
dn=ToString[directoryName],
dp,
fp
},
dp=FileNameJoin[{ParentDirectory[Directory[]],ex,dn}];
Quiet[CreateDirectory[dp]];
fp=FileNameJoin[{dp,fn<>".nb"}];
NotebookSave[InputNotebook[],fp];
]


SaveExample[]:=Module[{
ex="Examples",
fn=FileNameSplit[NotebookFileName[]][[-1]],
dn=FileNameSplit[NotebookFileName[]][[-2]]
},
NotebookSave[InputNotebook[],FileNameJoin[{ParentDirectory[Directory[]],ex,dn,fn}]];
]


ToInitial[]:=Module[{
sk=Keys@$olution[$scalar],
fk=Keys@$olution[$form],
tk=Keys@$olution[$tensor],
ffk=Keys@$olution[$frame,$form],
\[CapitalGamma]fk=Keys@$olution[$gamma,$flat],
\[CapitalGamma]ck=Keys@$olution[$gamma,$curved],
spk=Keys@$olution[$pinor]
},
Do[
$olution[$scalar,sk[[ii]],$value]=$blueprint[$scalar,Symbol,$value];,
{ii,1,Length@sk}
];
Do[
$olution[$form,fk[[ii]],$expression]=$blueprint[$form,Symbol,$expression];,
{ii,1,Length@fk}
];
Do[
$olution[$tensor,tk[[ii]],$value]=$blueprint[$tensor,Symbol,$value];,
{ii,1,Length@tk}
];
$olution[$metric,$curved,$ds2]=$blueprint[$metric,$curved,$ds2];
$olution[$metric,$curved,$tensor,$value]=$blueprint[$metric,$curved,$tensor,$value];
$olution[$metric,$curved,$christoffel,$value]=$blueprint[$metric,$curved,$christoffel,$value];
$olution[$metric,$curved,$riemann,$value]=$blueprint[$metric,$curved,$riemann,$value];
$olution[$metric,$curved,$ricci,$value]=$blueprint[$metric,$curved,$ricci,$value];
$olution[$metric,$curved,$ricciScalar,$value]=$blueprint[$metric,$curved,$ricciScalar,$value];
$olution[$metric,$curved,$det,$value]=$blueprint[$metric,$curved,$det,$value];
$olution[$metric,$flat,$tensor,$value]=$blueprint[$metric,$flat,$tensor,$value];
Do[
$olution[$frame,$form,ffk[[ii]],$expression]=$blueprint[$frame,$form,Integer,$expression];,
{ii,1,Length@ffk}
];
$olution[$frame,$vielbein,$value]=$blueprint[$frame,$vielbein,$value];
$olution[$frame,$spinConnection,$value]=$blueprint[$frame,$spinConnection,$value];
Do[
$olution[$gamma,$flat,\[CapitalGamma]fk[[ii]],$value]=$blueprint[$gamma,$flat,Integer,$value];,
{ii,1,Length@\[CapitalGamma]fk}
];
Do[
$olution[$gamma,$curved,\[CapitalGamma]ck[[ii]],$value]=$blueprint[$gamma,$curved,Integer,$value];,
{ii,1,Length@\[CapitalGamma]ck}
];
Do[
$olution[$pinor,spk[[ii]],$value]=$blueprint[$pinor,Symbol,$value];,
{ii,1,Length@spk}
];
]


AllSolutions[]:=Dataset[FileSystemMap[<|" "->ButtonLoadSolution[#],""->ButtonDeleteSolution[#]|>&,Directory[],{2,7}]]


Print$olution[]:=TableForm[Normal@(Dataset[#]&/@$olution),TableAlignments->Center]


Print$olution[key_]:=If[Length@key==0,
Return[TableForm[Normal@(Dataset[#]&/@$olution[key]),TableAlignments->Center]],
Return[TableForm[Normal@(Dataset[#]&/@$olution@@key),TableAlignments->Center]]
]


PrintSolution[list1_,list2_]:=Return[TableForm[Normal@(Dataset[#]&/@Solution[list1,list2,ChangeCoord->False]),TableAlignments->Center]]


GenerateMetric[basis_]:=Module[{
c=$olution[$basis,$curved,$coordinate],
xc=$olution[$basis,$curved,$coordinate]//.ToXCoord,
ds2=$olution[$metric,$curved,$ds2],
dim=$olution[$manifold,$dimension],
s=$olution[$metric,$curved,$ignature],
tb
},
If[TrueQ[basis==$olution[$basis,$curved,$ymbol]]==True,
tb=Table[Diff[xc[[ii]]]\[CircleTimes]Diff[xc[[jj]]],{ii,1,dim},{jj,1,dim}];
Return[
Table[
(1/2 (Normal@CoefficientArrays[ds2,tb[[ii]] ][[2]]+Normal@CoefficientArrays[ds2,Transpose[tb][[ii]]][[2]])),
{ii,1,dim}
]
]
];
If[TrueQ[basis==$olution[$basis,$flat,$ymbol]]==True,
If[s==-1,
Return[DiagonalMatrix[Join[{-1},ConstantArray[1,Length@c-1]]]
]
];
If[s==1,
Return[DiagonalMatrix[ConstantArray[1,Length@c]]]
];
];
]


GenerateMetric[expr_,coordList_]:=Module[{
c=coordList,
xc=coordList//.ToXCoord,
ds2=expr,
dim=Length@coordList,
tb
},
tb=Table[Diff[xc[[ii]]]\[CircleTimes]Diff[xc[[jj]]],{ii,1,dim},{jj,1,dim}];
Return[
Table[
(1/2 (Normal@CoefficientArrays[ds2,tb[[ii]] ][[2]]+Normal@CoefficientArrays[ds2,Transpose[tb][[ii]]][[2]])),
{ii,1,dim}
]
];
]


GenerateFormTensor[key_]:=Module[{
c=$olution[$basis,$curved,$coordinate],
xc=$olution[$basis,$curved,$coordinate]//.ToXCoord,
fr=$olution[$form,key,$rank],
fe=$olution[$form,key,$expression],
curved=$olution[$basis,$curved,$ymbol],
dim=$olution[$manifold,$dimension],
ind=GetIndicesOfVBundle[TangentBundleOfManifold[$olution[$manifold,$ymbol ] ],Length@$olution[$basis,$curved,$index]],
tmp,
ct
},
If[fr==1,
tmp=Table[
Coefficient[fe,Diff[xc[[ii]]]],
{ii,1,dim}
];
ct=CTensor[tmp,{-curved}];
Return[
ct[-ind[[1]]][[0,1]]
];
];
If[fr==2,
tmp=Table[
Coefficient[fe,Diff[xc[[ii]]]\[Wedge]Diff[xc[[jj]]]],
{ii,1,dim},{jj,1,dim}
];
ct=CTensor[tmp,{-curved,-curved}];
Return[
2!Antisymmetrize[ct[-ind[[1]],-ind[[2]]],{-ind[[1]],-ind[[2]]}][[0,1]]
];
];
If[fr>=3,Print["Forms of rank >= 3 are still in construction" ];
Return[Null];
];
]


(* ::Input::Initialization:: *)
GenerateVielbein[]:=Module[{
xc=Values@$olution[$basis,$curved,$coordinate]/.ToXCoord,
vv=Table[($olution[$frame,$form][[ii]])[$expression],{ii,1,Length@$olution[$frame,$form]}]
},
Return[
Table[
Coefficient[vv,Diff[xc[[ii]]]],
{ii,1,Length@xc}
]
]
]


Set$metric[table_]:=Module[{
tb=table/.ToXCoord,
dcli=Diff/@($olution[$basis,$curved,$coordinate]/.ToXCoord)
},
$olution[$metric,$curved,$ds2]=Total@Flatten@Table[tb[[ii,jj]]dcli[[ii]]\[CircleTimes]dcli[[jj]],{ii,1,Length@dcli},{jj,1,Length@dcli}]//Simplification
]


PrintComputed[symbol_,$bas_,indexPos_,simplify_,time_]:=Module[{
b=Table[$olution[$basis,$bas[[ii]],$ymbol],{ii,1,Length@$bas}],
i=Table[$olution[$basis,$bas[[ii]],$index],{ii,1,Length@$bas}],
ip=indexPos
},
Print["Computed ",symbol@@(ip*Table[{i[[\[Alpha]\[Alpha],\[Alpha]\[Alpha]]],b[[\[Alpha]\[Alpha]]]},{\[Alpha]\[Alpha],1,Length@ip}])," using ",FB@simplify," in ",FB@UnitConvert[Quantity[Round[AbsoluteTime[]-time],"Seconds"],MixedRadix["Minutes","Seconds"]]];
]


PrintComputeMetric[symbol_,$bas_,indexPos_,table_,simplify_]:=Module[{
sy=symbol,
b=Table[$olution[$basis,$bas[[ii]],$ymbol],{ii,1,Length@$bas}],
i=Table[$olution[$basis,$bas[[ii]],$index],{ii,1,Length@$bas}],
ip=indexPos,
tb=table,
at
},
$CVSimplify=simplify;
at=AbsoluteTime[];
Monitor[
MetricInBasis[sy,(DeleteDuplicates@ip)[[1]](DeleteDuplicates@b)[[1]],tb];,
{ProgressIndicator[Appearance->"Percolate"],"Computing "sy[ip[[1]]{i[[1,1]],b[[1]]},ip[[2]]{i[[2,2]],b[[2]]}]}
];
PrintComputed[sy,$bas,ip,simplify,at];
$CVSimplify=Simplify;
]


PrintComputeTensor[symbol_,$bas_,indexPos_,table_,simplify_]:=Module[{
sy=symbol,
b=Table[$olution[$basis,$bas[[ii]],$ymbol],{ii,1,Length@$bas}],
i=Table[$olution[$basis,$bas[[ii]],$index],{ii,1,Length@$bas}],
ip=indexPos,
tb=table,
at,
ili
},
$CVSimplify=simplify;
at=AbsoluteTime[];
If[Length@$bas==1,
Monitor[
Do[ComponentValue[
sy[{GetCNumber[b[[1]]][[ii]],ip[[1]]*b[[1]]}],
tb[[ii]]
],{ii,1,Length@GetCNumber[b[[1]]]}
],ProgressIndicator[ii,{1,Length@GetCNumber[b[[1]]]},ImageSize->{300,5}]
];
PrintComputed[sy,$bas,ip,simplify,at];
,
ComponentValue/@ComponentArray@(Composition@@Table[ToBasis[b[[ii]]],{ii,1,Length@$bas}])@(sy@@Table[ip[[ii]]*i[[ii,ii]],{ii,1,Length@$bas}])//Flatten;
ili=Table[(Composition@@Table[DeleteCases[b[[ii]]],{ii,1,Length@$bas}])@(Composition@@Table[DeleteCases[-b[[ii]]],{ii,1,Length@$bas}])@Flatten@Level[Keys@TensorValues[sy][[2]][[\[Alpha]\[Alpha]]],1],{\[Alpha]\[Alpha],1,Length@Keys@TensorValues[sy][[2]]}];
Monitor[
Do[ComponentValue[
sy@@Table[{ili[[\[Alpha]\[Alpha],ii]],ip[[ii]]b[[ii]]},{ii,1,Length@$bas}],
Part@@Join[{tb},Table[(Flatten@Position[GetCNumber[b[[ii]]],ili[[\[Alpha]\[Alpha],ii]]])[[1]],{ii,1,Length@$bas}]]
],{\[Alpha]\[Alpha],1,Length@ili}
],ProgressIndicator[\[Alpha]\[Alpha],{1,Length@ili},ImageSize->{300,5}]
];
PrintComputed[sy,$bas,ip,simplify,at];
];
$CVSimplify=Simplify;
]


PrintComputeTensor[symbol_,$bas_,{targetInd_,fromInd_},simplify_]:=Module[{
sy=symbol,
ti=targetInd,
fi=fromInd,
b=Table[$olution[$basis,$bas[[ii]],$ymbol],{ii,1,Length@$bas}],
i=Table[$olution[$basis,$bas[[ii]],$index],{ii,1,Length@$bas}],
m=Table[$olution[$metric,$bas[[ii]],$tensor,$ymbol],{ii,1,Length@$bas}],
curved=$olution[$basis,$curved,$ymbol],
flat=$olution[$basis,$flat,$ymbol],
spin=$olution[$basis,$spin,$ymbol],
ili,
tb,
at
},
$CVSimplify=simplify;
Monitor[
tb=ToValues@Simplification@ComponentArray@TraceBasisDummy@(Composition@@Table[ToBasis[b[[ii]]],{ii,1,Length@$bas}])@(Times@@Table[m[[ii]][ti[[ii]]*i[[ii,ii]],-fi[[ii]]*i[[ii,-ii]]],{ii,1,Length@$bas}]sy@@Table[fi[[ii]]*i[[ii,-ii]],{ii,1,Length@$bas}]),
{ProgressIndicator[Appearance->"Necklace"],"Applying tensor symmetries to "(Composition@@Table[ToBasis[b[[ii]]],{ii,1,Length@$bas}])@(sy@@Table[ti[[ii]]*i[[ii,ii]],{ii,1,Length@$bas}])}
];
PrintComputeTensor[sy,$bas,ti,tb,simplify];
$CVSimplify=Simplify;
]


PrintSimplified[symbol_,comp_,simplify_,time_]:=Print["Applied ",FB@simplify," to the ",FS@comp," components of ",FS@symbol," in ",FB@UnitConvert[Quantity[Round[AbsoluteTime[]-time],"Seconds"],MixedRadix["Minutes","Seconds"]]]


ParallelMapSimplify[symbol_,valID_,parallelSimplify_]:=(
symbol/:TensorValues[symbol,valID]=FoldedRule[
TensorValues[symbol,valID][[1]],
ParallelMap[parallelSimplify,TensorValues[symbol,valID][[2]],Method->Automatic,ProgressReporting->True]
];
)


ParallelMapSimplify[symbol_,valID_,parallelSimplify_,assump_]:=(
symbol/:TensorValues[symbol,valID]=FoldedRule[
TensorValues[symbol,valID][[1]],
ParallelMap[parallelSimplify[#1,Assumptions->assump]&,TensorValues[symbol,valID][[2]],Method->Automatic,ProgressReporting->True]
];
)


MapSimplify[symbol_,valID_,simplify_]:=(
symbol/:TensorValues[symbol,valID]=FoldedRule[
TensorValues[symbol,valID][[1]],
Map[simplify,TensorValues[symbol,valID][[2]]]
];
)


PrintParallelMapSimplify[symbol_,parallelSimplify_]:=Module[{
sy=symbol,
ps=parallelSimplify,
vidl=Table[Level[TensorValIDs[symbol][[ii]],1][[2]],{ii,1,Length@TensorValIDs[symbol]}],
at
},
If[TrueQ[ToString[ps]!=ToString[Identity]],
Do[
at=AbsoluteTime[];
ParallelMapSimplify[sy,vidl[[ii]],ps];
PrintSimplified[sy,vidl[[ii]],ps,at];,
{ii,1,Length@vidl}
];
];
]


PrintParallelMapSimplify2[tvidl_,parallelSimplify_,assump_]:=Module[{
sy,
ps=parallelSimplify,
vidl,
at
},
sy=Level[tvidl[[1]],1][[1]];
vidl=Table[Level[tvidl[[ii]],1][[2]],{ii,1,Length@tvidl}];
at=AbsoluteTime[];
If[TrueQ[ToString[ps]!=ToString[Identity]],
Do[
at=AbsoluteTime[];
If[TrueQ[ToString[ps]==ToString[Together]],
ParallelMapSimplify[sy,vidl[[ii]],ps];
,
ParallelMapSimplify[sy,vidl[[ii]],ps,assump];
];
PrintSimplified[sy,vidl[[ii]],ps,at];,
{ii,1,Length@vidl}
];
];
]


PrintParallelMapSimplify[symbol_,parallelSimplify_,assump_]:=Module[{
sy=symbol,
ps=parallelSimplify,
vidl=Table[Level[TensorValIDs[symbol][[ii]],1][[2]],{ii,1,Length@TensorValIDs[symbol]}],
at
},
If[TrueQ[ToString[ps]!=ToString[Identity]],
Do[
at=AbsoluteTime[];
ParallelMapSimplify[sy,vidl[[ii]],ps,assump];
PrintSimplified[sy,vidl[[ii]],ps,at];,
{ii,1,Length@vidl}
];
];
]


PlusParallelMapSimplify[expr_,termSimplify_,totalSimplify_,assump_]:=(
If[TrueQ[Head@expr==Plus],
Return[totalSimplify@Total@(ParallelMap[termSimplify[#1,Assumptions->assump]&,#,Method->Automatic,ProgressReporting->True]&/@Level[expr,1])];
];
If[TrueQ[Head@expr==Times],
Return[totalSimplify@(Level[expr,1][[1]] Total@(ParallelMap[termSimplify[#1,Assumptions->assump]&,#,Method->Automatic,ProgressReporting->True]&/@Level[Level[expr,1][[2]],1]))];
];
)


PrintMapSimplify[symbol_,simplify_]:=Module[{
sy=symbol,
s=simplify,
vidl=Table[Level[TensorValIDs[symbol][[ii]],1][[2]],{ii,1,Length@TensorValIDs[symbol]}],
at
},
If[TrueQ[ToString[ps]!=ToString[Identity]],
Do[
at=AbsoluteTime[];
Monitor[MapSimplify[sy,vidl[[ii]],s],{ProgressIndicator[Appearance->"Percolate"],"Applying ",FB@s," to the "FS@vidl[[ii]]," components of "FS@sy}];
PrintSimplified[sy,vidl[[ii]],s,at];,
{ii,1,Length@vidl}
];
];
]


Compute[$metric,$bas1_,$tensor,s_,ps_]:=Module[{
sy=$olution[$metric,$bas1,$tensor,$ymbol],
basis=$olution[$basis,$bas1,$ymbol],
mt,
imt,
vdg,
Detggcurved=$olution[$metric,$curved,$det,$ymbol],
i=Table[$olution[$basis,$bas1,$index],{ii,1,2}],
at,
a=System`$Assumptions
},
mt=GenerateMetric[basis];
PrintComputeMetric[sy,{$bas1,$bas1},{-1,-1},mt,s];
PrintParallelMapSimplify2[{ValID[sy,{{-basis,-basis}}]},ps,a];
imt=Inverse@TTensor[sy[-i[[1,1]],-i[[2,2]]]];
PrintComputeMetric[sy,{$bas1,$bas1},{1,1},imt,s];
PrintParallelMapSimplify2[{ValID[sy,{{basis,basis}}]},ps,a];
(*store*)
$olution[$metric,$bas1,$tensor,$value]=Table[TensorValIDs[sy][[ii]]->TensorValues[sy,Level[TensorValIDs[sy][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy]}]/.List[x__]:>Association[x];
(*det*)
If[TrueQ[$bas1==$curved],
at=AbsoluteTime[ ];
Monitor[vdg=Det@CTensor[sy[-i[[1,1]],-i[[2,2]]]][[0,1]]//s//ps,{ProgressIndicator[Appearance->"Percolate"],"Computing ",Detggcurved[]}];
Print["Computed ",Detggcurved[]," using ",FB@s," and ",FB@ps," in ",FB@UnitConvert[Quantity[Round[AbsoluteTime[]-at],"Seconds"],MixedRadix["Minutes","Seconds"]]];
(*store*)
$olution[$metric,$curved,$det,$value]=Detggcurved[]->vdg;
];
]


Compute[$metric,$bas1_,$christoffel,{{-1,-1,-1},{1,-1,-1},{1,1,-1}},s_,ps_]:=Module[{
sy=$olution[$metric,$bas1,$christoffel,$ymbol],
basis=$olution[$basis,$bas1,$ymbol],
$bas=Table[$bas1,{ii,1,3}],
i=Table[$olution[$basis,$bas1,$index],{ii,1,3}],
tb,
a=System`$Assumptions
},
Monitor[tb=ToValues@Simplification@ComponentArray@TraceBasisDummy@ToBasis[basis]@ToBasis[basis]@ChristoffelToGradMetric@sy[-i[[1,1]],-i[[2,2]],-i[[3,3]]];,
{ProgressIndicator[Appearance->"Necklace"],"Applying tensor symmetries to "ToBasis[basis]@(sy@@Table[-i[[ii,ii]],{ii,1,Length@$bas}])}];
PrintComputeTensor[sy,$bas,{-1,-1,-1},tb,s];
PrintParallelMapSimplify2[{ValID[sy,{{-basis,-basis,-basis}}]},ps,a];
PrintComputeTensor[sy,$bas,{{1,-1,-1},{-1,-1,-1}},s];
PrintParallelMapSimplify2[{ValID[sy,{{basis,-basis,-basis}}]},ps,a];
PrintComputeTensor[sy,$bas,{{1,1,-1},{1,-1,-1}},s];
PrintComputeTensor[sy,$bas,{{1,-1,1},{1,-1,-1}},s];
PrintParallelMapSimplify2[{ValID[sy,{{basis,-basis,basis},{basis,basis,-basis}}]},ps,a];
$olution[$metric,$bas1,$christoffel,$value]=Table[TensorValIDs[sy][[ii]]->TensorValues[sy,Level[TensorValIDs[sy][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy]}]/.List[x__]:>Association[x];
]


Compute[$metric,$bas1_,$christoffel,{{-1,-1,-1},{1,-1,-1}},s_,ps_]:=Module[{
sy=$olution[$metric,$bas1,$christoffel,$ymbol],
basis=$olution[$basis,$bas1,$ymbol],
$bas=Table[$bas1,{ii,1,3}],
i=Table[$olution[$basis,$bas1,$index],{ii,1,3}],
tb,
a=System`$Assumptions
},
Monitor[tb=ToValues@Simplification@ComponentArray@TraceBasisDummy@ToBasis[basis]@ToBasis[basis]@ChristoffelToGradMetric@sy[-i[[1,1]],-i[[2,2]],-i[[3,3]]];,
{ProgressIndicator[Appearance->"Necklace"],"Applying tensor symmetries to "ToBasis[basis]@(sy@@Table[-i[[ii,ii]],{ii,1,Length@$bas}])}];
PrintComputeTensor[sy,$bas,{-1,-1,-1},tb,s];
PrintParallelMapSimplify2[{ValID[sy,{{-basis,-basis,-basis}}]},ps,a];
PrintComputeTensor[sy,$bas,{{1,-1,-1},{-1,-1,-1}},s];
PrintParallelMapSimplify2[{ValID[sy,{{basis,-basis,-basis}}]},ps,a];
$olution[$metric,$bas1,$christoffel,$value]=Table[TensorValIDs[sy][[ii]]->TensorValues[sy,Level[TensorValIDs[sy][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy]}]/.List[x__]:>Association[x];
]


Compute[$metric,$bas1_,$christoffel,s_,ps_]:=Compute[$metric,$bas1,$christoffel,{{-1,-1,-1},{1,-1,-1},{1,1,-1}},s,ps]


Compute[$metric,$bas1_,$riemann,"All",s_,ps_]:=Module[{
sy=$olution[$metric,$bas1,$riemann,$ymbol],
basis=$olution[$basis,$bas1,$ymbol],
$bas=Table[$bas1,{ii,1,4}],
i=Table[$olution[$basis,$bas1,$index],{ii,1,4}],
tb,
a=System`$Assumptions
},
Monitor[tb=ToValues@Simplification@ComponentArray@TraceBasisDummy@ToBasis[basis]@ToBasis[basis]@RiemannToChristoffel@sy[-i[[1,1]],-i[[2,2]],-i[[3,3]],-i[[4,4]]];,
{ProgressIndicator[Appearance->"Necklace"],"Applying tensor symmetries to "ToBasis[basis]@(sy@@Table[-i[[ii,ii]],{ii,1,Length@$bas}])}];
PrintComputeTensor[sy,$bas,{-1,-1,-1,-1},tb,s];
PrintParallelMapSimplify2[{ValID[sy,{{-1,-1,-1,-1}}*basis]},ps,a];
PrintComputeTensor[sy,$bas,{{1,-1,-1,-1},{-1,-1,-1,-1}},s];
PrintComputeTensor[sy,$bas,{{-1,1,-1,-1},{-1,-1,-1,-1}},s];
PrintComputeTensor[sy,$bas,{{-1,-1,1,-1},{-1,-1,-1,-1}},s];
PrintComputeTensor[sy,$bas,{{-1,-1,-1,1},{-1,-1,-1,-1}},s];
PrintParallelMapSimplify2[{ValID[sy,{{-1,-1,-1,1},{-1,-1,1,-1},{-1,1,-1,-1},{1,-1,-1,-1}}*basis]},ps,a];
PrintComputeTensor[sy,$bas,{{1,-1,1,-1},{1,-1,-1,-1}},s];
PrintComputeTensor[sy,$bas,{{-1,1,1,-1},{-1,1,-1,-1}},s];
PrintComputeTensor[sy,$bas,{{1,-1,-1,1},{1,-1,-1,-1}},s];
PrintComputeTensor[sy,$bas,{{-1,1,-1,1},{-1,1,-1,-1}},s];
PrintParallelMapSimplify2[{ValID[sy,{{-1,1,-1,1},{1,-1,-1,1},{-1,1,1,-1},{1,-1,1,-1}}*basis]},ps,a];
PrintComputeTensor[sy,$bas,{{1,1,-1,-1},{1,-1,-1,-1}},s];
PrintComputeTensor[sy,$bas,{{-1,-1,1,1},{-1,-1,1,-1}},s];
PrintParallelMapSimplify2[{ValID[sy,{{-1,-1,1,1},{1,1,-1,-1}}*basis]},ps,a];
PrintComputeTensor[sy,$bas,{{1,1,1,-1},{1,1,-1,-1}},s];
PrintComputeTensor[sy,$bas,{{1,1,-1,1},{1,1,-1,-1}},s];
PrintComputeTensor[sy,$bas,{{1,-1,1,1},{-1,-1,1,1}},s];
PrintComputeTensor[sy,$bas,{{-1,1,1,1},{-1,-1,1,1}},s];
PrintParallelMapSimplify2[{ValID[sy,{{-1,1,1,1},{1,-1,1,1},{1,1,-1,1},{1,1,1,-1}}*basis]},ps,a];
PrintComputeTensor[sy,$bas,{{1,1,1,1},{1,1,1,-1}},s];
PrintParallelMapSimplify2[{ValID[sy,{{basis,basis,basis,basis}}]},ps,a];
$olution[$metric,$bas1,$riemann,$value]=Table[TensorValIDs[sy][[ii]]->TensorValues[sy,Level[TensorValIDs[sy][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy]}]/.List[x__]:>Association[x];
]


Compute[$metric,$bas1_,$riemann,{{-1,-1,-1,-1},{1,1,-1,-1},{1,1,1,1}},s_,ps_]:=Module[{
sy=$olution[$metric,$bas1,$riemann,$ymbol],
basis=$olution[$basis,$bas1,$ymbol],
$bas=Table[$bas1,{ii,1,4}],
i=Table[$olution[$basis,$bas1,$index],{ii,1,4}],
tb,
a=System`$Assumptions
},
Monitor[tb=ToValues@Simplification@ComponentArray@TraceBasisDummy@ToBasis[basis]@ToBasis[basis]@RiemannToChristoffel@sy[-i[[1,1]],-i[[2,2]],-i[[3,3]],-i[[4,4]]];,
{ProgressIndicator[Appearance->"Necklace"],"Applying tensor symmetries to "ToBasis[basis]@(sy@@Table[-i[[ii,ii]],{ii,1,Length@$bas}])}];
PrintComputeTensor[sy,$bas,{-1,-1,-1,-1},tb,s];
PrintParallelMapSimplify2[{ValID[sy,{{-basis,-basis,-basis,-basis}}]},ps,a];
PrintComputeTensor[sy,$bas,{{1,1,-1,-1},{-1,-1,-1,-1}},s];
PrintComputeTensor[sy,$bas,{{-1,-1,1,1},{-1,-1,-1,-1}},s];
PrintParallelMapSimplify2[{ValID[sy,{{-basis,-basis,basis,basis},{basis,basis,-basis,-basis}}]},ps,a];
PrintComputeTensor[sy,$bas,{{1,1,1,1},{1,1,-1,-1}},s];
PrintParallelMapSimplify2[{ValID[sy,{{basis,basis,basis,basis}}]},ps,a];
$olution[$metric,$bas1,$riemann,$value]=Table[TensorValIDs[sy][[ii]]->TensorValues[sy,Level[TensorValIDs[sy][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy]}]/.List[x__]:>Association[x];
]


Compute[$metric,$bas1_,$riemann,{{-1,-1,-1,-1}},s_,ps_]:=Module[{
sy=$olution[$metric,$bas1,$riemann,$ymbol],
basis=$olution[$basis,$bas1,$ymbol],
$bas=Table[$bas1,{ii,1,4}],
i=Table[$olution[$basis,$bas1,$index],{ii,1,4}],
tb,
a=System`$Assumptions
},
Monitor[tb=ToValues@Simplification@ComponentArray@TraceBasisDummy@ToBasis[basis]@ToBasis[basis]@RiemannToChristoffel@sy[-i[[1,1]],-i[[2,2]],-i[[3,3]],-i[[4,4]]];,
{ProgressIndicator[Appearance->"Necklace"],"Applying tensor symmetries to "ToBasis[basis]@(sy@@Table[-i[[ii,ii]],{ii,1,Length@$bas}])}];
PrintComputeTensor[sy,$bas,{-1,-1,-1,-1},tb,s];
PrintParallelMapSimplify2[{ValID[sy,{{-basis,-basis,-basis,-basis}}]},ps,a];
$olution[$metric,$bas1,$riemann,$value]=Table[TensorValIDs[sy][[ii]]->TensorValues[sy,Level[TensorValIDs[sy][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy]}]/.List[x__]:>Association[x];
]


Compute[$metric,$bas1_,$riemann,s_,ps_]:=Compute[$metric,$bas1,$riemann,{{-1,-1,-1,-1},{1,1,-1,-1},{1,1,1,1}},s,ps]


(*Compute[$metric,$bas1_,$riemann,s_,ps_]:=Module[{
sy=$olution[$metric,$bas1,$riemann,$ymbol],
basis=$olution[$basis,$bas1,$ymbol],
$bas=Table[$bas1,{ii,1,4}],
i=Table[$olution[$basis,$bas1,$index],{ii,1,4}],
tb
},
Monitor[tb=ToValues@Simplification@ComponentArray@TraceBasisDummy@ToBasis[basis]@ToBasis[basis]@RiemannToChristoffel@sy[-i\[LeftDoubleBracket]1,1\[RightDoubleBracket],-i\[LeftDoubleBracket]2,2\[RightDoubleBracket],-i\[LeftDoubleBracket]3,3\[RightDoubleBracket],-i\[LeftDoubleBracket]4,4\[RightDoubleBracket]];,
{ProgressIndicator[Appearance\[Rule]"Necklace"],"Applying tensor symmetries to "ToBasis[basis]@(sy@@Table[-i\[LeftDoubleBracket]ii,ii\[RightDoubleBracket],{ii,1,Length@$bas}])}];
PrintComputeTensor[sy,$bas,{-1,-1,-1,-1},tb,s];
PrintComputeTensor[sy,$bas,{{1,1,-1,-1},{-1,-1,-1,-1}},s];
PrintComputeTensor[sy,$bas,{{-1,-1,1,1},{-1,-1,-1,-1}},s];
PrintComputeTensor[sy,$bas,{{1,1,1,1},{1,1,-1,-1}},s];
PrintParallelMapSimplify[sy,ps];
$olution[$metric,$bas1,$riemann,$value]=Table[TensorValIDs[sy]\[LeftDoubleBracket]ii\[RightDoubleBracket]\[Rule]TensorValues[sy,Level[TensorValIDs[sy]\[LeftDoubleBracket]ii\[RightDoubleBracket],1]\[LeftDoubleBracket]2\[RightDoubleBracket]],{ii,1,Length@TensorValIDs[sy]}]/.List[x__]:>Association[x];
]*)


Compute[$metric,$bas1_,$ricci,{{-1,-1},{1,-1},{1,1}},s_,ps_]:=Module[{
sy=$olution[$metric,$bas1,$ricci,$ymbol],
basis=$olution[$basis,$bas1,$ymbol],
$bas=Table[$bas1,{ii,1,2}],
i=Table[$olution[$basis,$bas1,$index],{ii,1,2}],
tb,
at,
vRs,
RicciScalarcd=$olution[$metric,$curved,$ricciScalar,$ymbol],
m=$olution[$metric,$curved,$tensor,$ymbol],
a=System`$Assumptions
},
Monitor[tb=ToValues@Simplification@ComponentArray@TraceBasisDummy@ToBasis[basis]@ToBasis[basis]@RiemannToChristoffel@sy[-i[[1,1]],-i[[2,2]]];,
{ProgressIndicator[Appearance->"Necklace"],"Applying tensor symmetries to "ToBasis[basis]@(sy@@Table[-i[[ii,ii]],{ii,1,Length@$bas}])}];
PrintComputeTensor[sy,$bas,{-1,-1},tb,s];
PrintParallelMapSimplify2[{ValID[sy,{{-basis,-basis}}]},ps,a];
PrintComputeTensor[sy,$bas,{{1,-1},{-1,-1}},s];
PrintComputeTensor[sy,$bas,{{-1,1},{-1,-1}},s];
PrintParallelMapSimplify2[{ValID[sy,{{-basis,basis},{basis,-basis}}]},ps,a];
PrintComputeTensor[sy,$bas,{{1,1},{1,-1}},s];
PrintParallelMapSimplify2[{ValID[sy,{{basis,basis}}]},ps,a];
$olution[$metric,$bas1,$ricci,$value]=Table[TensorValIDs[sy][[ii]]->TensorValues[sy,Level[TensorValIDs[sy][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy]}]/.List[x__]:>Association[x];
If[TrueQ[$bas1==$curved],
at=AbsoluteTime[ ];
Monitor[vRs=Tr[CTensor[m[i[[1,1]],i[[2,2]]]][[0,1]] . CTensor[sy[-i[[1,1]],-i[[2,2]]]][[0,1]]]//s//ps,{ProgressIndicator[Appearance->"Percolate"],"Computing ",RicciScalarcd[]}];
Print["Computed ",RicciScalarcd[]," using ",FB@s," and ",FB@ps," in ",FB@UnitConvert[Quantity[Round[AbsoluteTime[]-at],"Seconds"],MixedRadix["Minutes","Seconds"]]];
(*store*)
$olution[$metric,$curved,$ricciScalar,$value]=RicciScalarcd[]->vRs;
];
]


Compute[$metric,$bas1_,$ricci,{{-1,-1},{1,-1}},s_,ps_]:=Module[{
sy=$olution[$metric,$bas1,$ricci,$ymbol],
basis=$olution[$basis,$bas1,$ymbol],
$bas=Table[$bas1,{ii,1,2}],
i=Table[$olution[$basis,$bas1,$index],{ii,1,2}],
tb,
at,
vRs,
RicciScalarcd=$olution[$metric,$curved,$ricciScalar,$ymbol],
m=$olution[$metric,$curved,$tensor,$ymbol],
a=System`$Assumptions
},
Monitor[tb=ToValues@Simplification@ComponentArray@TraceBasisDummy@ToBasis[basis]@ToBasis[basis]@RiemannToChristoffel@sy[-i[[1,1]],-i[[2,2]]];,
{ProgressIndicator[Appearance->"Necklace"],"Applying tensor symmetries to "ToBasis[basis]@(sy@@Table[-i[[ii,ii]],{ii,1,Length@$bas}])}];
PrintComputeTensor[sy,$bas,{-1,-1},tb,s];
PrintParallelMapSimplify2[{ValID[sy,{{-basis,-basis}}]},ps,a];
PrintComputeTensor[sy,$bas,{{1,-1},{-1,-1}},s];
PrintComputeTensor[sy,$bas,{{-1,1},{-1,-1}},s];
PrintParallelMapSimplify2[{ValID[sy,{{-basis,basis},{basis,-basis}}]},ps,a];$olution[$metric,$bas1,$ricci,$value]=Table[TensorValIDs[sy][[ii]]->TensorValues[sy,Level[TensorValIDs[sy][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy]}]/.List[x__]:>Association[x];
If[TrueQ[$bas1==$curved],
at=AbsoluteTime[ ];
Monitor[vRs=Tr[CTensor[m[i[[1,1]],i[[2,2]]]][[0,1]] . CTensor[sy[-i[[1,1]],-i[[2,2]]]][[0,1]]]//s//ps,{ProgressIndicator[Appearance->"Percolate"],"Computing ",RicciScalarcd[]}];
Print["Computed ",RicciScalarcd[]," using ",FB@s," and ",FB@ps," in ",FB@UnitConvert[Quantity[Round[AbsoluteTime[]-at],"Seconds"],MixedRadix["Minutes","Seconds"]]];
(*store*)
$olution[$metric,$curved,$ricciScalar,$value]=RicciScalarcd[]->vRs;
];
]


Compute[$metric,$bas1_,$ricci,{{-1,-1}},s_,ps_]:=Module[{
sy=$olution[$metric,$bas1,$ricci,$ymbol],
basis=$olution[$basis,$bas1,$ymbol],
$bas=Table[$bas1,{ii,1,2}],
i=Table[$olution[$basis,$bas1,$index],{ii,1,2}],
tb,
at,
vRs,
RicciScalarcd=$olution[$metric,$curved,$ricciScalar,$ymbol],
m=$olution[$metric,$curved,$tensor,$ymbol],
a=System`$Assumptions
},
Monitor[tb=ToValues@Simplification@ComponentArray@TraceBasisDummy@ToBasis[basis]@ToBasis[basis]@RiemannToChristoffel@sy[-i[[1,1]],-i[[2,2]]];,
{ProgressIndicator[Appearance->"Necklace"],"Applying tensor symmetries to "ToBasis[basis]@(sy@@Table[-i[[ii,ii]],{ii,1,Length@$bas}])}];
PrintComputeTensor[sy,$bas,{-1,-1},tb,s];
PrintParallelMapSimplify2[{ValID[sy,{{-basis,-basis}}]},ps,a];
$olution[$metric,$bas1,$ricci,$value]=Table[TensorValIDs[sy][[ii]]->TensorValues[sy,Level[TensorValIDs[sy][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy]}]/.List[x__]:>Association[x];
If[TrueQ[$bas1==$curved],
at=AbsoluteTime[ ];
Monitor[vRs=Tr[CTensor[m[i[[1,1]],i[[2,2]]]][[0,1]] . CTensor[sy[-i[[1,1]],-i[[2,2]]]][[0,1]]]//s//ps,{ProgressIndicator[Appearance->"Percolate"],"Computing ",RicciScalarcd[]}];
Print["Computed ",RicciScalarcd[]," using ",FB@s," and ",FB@ps," in ",FB@UnitConvert[Quantity[Round[AbsoluteTime[]-at],"Seconds"],MixedRadix["Minutes","Seconds"]]];
(*store*)
$olution[$metric,$curved,$ricciScalar,$value]=RicciScalarcd[]->vRs;
];
]


Compute[$metric,$bas1_,$ricci,s_,ps_]:=Compute[$metric,$bas1,$ricci,{{-1,-1},{1,-1},{1,1}},s,ps]


Compute[$tensor,key_,list_,s_,ps_]:=Module[{
sy=$olution[$tensor,key,$ymbol],
symInd=If[TrueQ[$olution[$tensor,key,$ymmetry]==Null],Return[Null],Return[Level[$olution[$tensor,key,$ymmetry],1][[1]]]],
$bas,
bas,
rank=$olution[$tensor,key,$rank],
curved=$olution[$basis,$curved,$ymbol],
flat=$olution[$basis,$flat,$ymbol],
spin=$olution[$basis,$spin,$ymbol],
li=list,
from,
target,
newTarget,
newFrom,
done=False,
a=System`$Assumptions
},
$bas=SlotsOfTensor[sy]/.Times[-1,x__]:>x/.VBundleOfBasis[curved]->$curved/.VBundleOfBasis[flat]->$flat/.VBundleOfBasis[spin]->$spin;
bas=Table[$olution[$basis,$bas[[ii]],$ymbol],{ii,1,Length@$bas}];
Do[
from=(Keys@li)[[ii]];
target=(Values@li)[[ii]];
If[TrueQ[symInd==Null],(*if no symmetries*)
If[TrueQ[Dimensions@from!={rank}](*if from is a table*),
PrintComputeTensor[sy,$bas,target,from,s];
PrintParallelMapSimplify2[{ValID[sy,{target*bas}]},ps,a];
,(*if from is an index configuration*)
PrintComputeTensor[sy,$bas,{target,from},s];
PrintParallelMapSimplify2[{ValID[sy,{target*bas}]},ps,a];
]
,(*if symmetries*)
If[target[[symInd[[1]]]]!=-target[[symInd[[2]]]],(*if mixed indices do not conincide with symmetric/antisymmetric indices*)
If[TrueQ[Dimensions@from!={rank}],PrintComputeTensor[sy,$bas,target,from,s],PrintComputeTensor[sy,$bas,{target,from},s]];
PrintParallelMapSimplify2[{ValID[sy,{target*bas}]},ps,a];
,(*if they coincide*)
If[done==False,(*to prevent doing it twice*)
newTarget=target;
newTarget[[symInd[[1]]]]=-target[[symInd[[1]]]];
newTarget[[symInd[[2]]]]=-target[[symInd[[2]]]];
newFrom=(Keys@DeleteCases[li,x_/;Values@x!=newTarget])[[1]];
If[TrueQ[Dimensions@from!={rank}],PrintComputeTensor[sy,$bas,target,from,s],PrintComputeTensor[sy,$bas,{target,from},s]];
If[TrueQ[Dimensions@newFrom!={rank}],PrintComputeTensor[sy,$bas,newTarget,newFrom,s],PrintComputeTensor[sy,$bas,{newTarget,newFrom},s]];
PrintParallelMapSimplify2[{ValID[sy,{newTarget*bas,target*bas}]},ps,a];
done=True;
]
];
]
,
{ii,1,Length@li}
];
$olution[$tensor,key,$value]=Table[TensorValIDs[sy][[ii]]->TensorValues[sy,Level[TensorValIDs[sy][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy]}]/.List[x__]:>Association[x];
]


Compute[$tensor,key_,s_,ps_]:=Module[{
rank=$olution[$tensor,key,$rank],
a=System`$Assumptions
},
If[TrueQ[rank==1],
Compute[$tensor,key,{GenerateFormTensor[key]->{-1},{-1}->{1}},s,ps];
];
If[TrueQ[rank==2],
Compute[$tensor,key,{GenerateFormTensor[key]->{-1,-1},{-1,-1}->{1,-1},{-1,-1}->{-1,1},{1,-1}->{1,1}},s,ps];
];
]


Compute[$frame,$vielbein,s_,ps_]:=Module[{
sy=$olution[$frame,$vielbein,$ymbol],
curved=$olution[$basis,$curved,$ymbol],
flat=$olution[$basis,$flat,$ymbol],
a=System`$Assumptions
},
PrintComputeTensor[sy,{$curved,$flat},{-1,1},GenerateVielbein[],s];
PrintParallelMapSimplify2[{ValID[sy,{{-curved,flat}}]},ps,a];
PrintComputeTensor[sy,{$curved,$flat},{{-1,-1},{-1,1}},s];
PrintParallelMapSimplify2[{ValID[sy,{{-curved,-flat}}]},ps,a];
PrintComputeTensor[sy,{$curved,$flat},{{1,-1},{-1,-1}},s];
PrintParallelMapSimplify2[{ValID[sy,{{curved,-flat}}]},ps,a];
PrintComputeTensor[sy,{$curved,$flat},{{1,1},{1,-1}},s];
PrintParallelMapSimplify2[{ValID[sy,{{curved,flat}}]},ps,a];
$olution[$frame,$vielbein,$value]=Table[TensorValIDs[sy][[ii]]->TensorValues[sy,Level[TensorValIDs[sy][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy]}]/.List[x__]:>Association[x];
]


Compute[$frame,$spinConnection,s_,ps_]:=Module[{
sy=$olution[$frame,$spinConnection,$ymbol],
m=$olution[$metric,$curved,$tensor,$ymbol],
e=$olution[$frame,$vielbein,$ymbol],
Christoffelcd=$olution[$metric,$curved,$christoffel,$ymbol],
i={$olution[$basis,$curved,$index],$olution[$basis,$flat,$index],$olution[$basis,$flat,$index]},
fi=$olution[$basis,$flat,$index],
ci=$olution[$basis,$curved,$index],
curved=$olution[$basis,$curved,$ymbol],
flat=$olution[$basis,$flat,$ymbol],
tb,
tmp,
a=System`$Assumptions
},
(*tmp=ToBasis[curved]@ToBasis[flat]@ToBasis[curved]@ToBasis[flat]@ContractMetric[Expand@SpinConnectionToFrame[sy[-i\[LeftDoubleBracket]1,1\[RightDoubleBracket],-i\[LeftDoubleBracket]2,2\[RightDoubleBracket],-i\[LeftDoubleBracket]3,3\[RightDoubleBracket]],sy],m];*)
tmp=ToBasis[curved]@ToBasis[flat]@(e[-ci[[-1]],-fi[[1]]](PD[-ci[[1]]][e[ci[[-1]],-fi[[2]]]]+Christoffelcd[ci[[-1]],-ci[[-2]],-ci[[1]]]e[ci[[-2]],-fi[[2]]]));
Monitor[tb=ToValues@ComponentArray@TraceBasisDummy@tmp;,
{ProgressIndicator[Appearance->"Necklace"],"Applying tensor symmetries to "ToBasis[curved]@ToBasis[flat]@(sy[-i[[1,1]],-i[[2,2]],-i[[3,3]]])}];
PrintComputeTensor[sy,{$curved,$flat,$flat},{-1,-1,-1},tb,s];
PrintParallelMapSimplify2[{ValID[sy,{{-curved,-flat,-flat}}]},ps,a];
$olution[$frame,$spinConnection,$value]=Table[TensorValIDs[sy][[ii]]->TensorValues[sy,Level[TensorValIDs[sy][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy]}]/.List[x__]:>Association[x];
]


Compute[$gamma,$flat,s_,ps_]:=Module[{
sy=Table[$olution[$gamma,$flat,ii,$ymbol],{ii,1,3}],
dim=$olution[$manifold,$dimension],
fi=$olution[$basis,$flat,$index],
fm=$olution[$metric,$flat,$tensor,$ymbol],
si=$olution[$basis,$spin,$index],
flat=$olution[$basis,$flat,$ymbol],
spin=$olution[$basis,$spin,$ymbol],
tb
},
tb=Table[$olution[$gamma,$flatGammaU,ii],{ii,0,dim-1}];
PrintComputeTensor[sy[[1]],{$flat,$spin,$spin},{1,-1,1},tb,s];
Monitor[
tb=ToValues@ComponentArray@(*Simplification@*)TraceBasisDummy@ToBasis[flat]@ToBasis[spin]@(fm[-fi[[1]],-fi[[-1]]]sy[[1]][fi[[-1]],-si[[1]],si[[2]]]);,
{ProgressIndicator[Appearance->"Necklace"],"Applying tensor symmetries to "ToBasis[flat]@ToBasis[spin]@(sy[[1]][-fi[[1]],-si[[1]],si[[2]]])}
];
PrintComputeTensor[sy[[1]],{$flat,$spin,$spin},{-1,-1,1},tb,s];
Monitor[
tb=ToValues@ComponentArray@(*Simplification@*)TraceBasisDummy@ToBasis[flat]@ToBasis[spin]@(SplitGammaMatrix@ToBasis[flat]@ToBasis[spin]@sy[[2]][fi[[1]],fi[[2]],-si[[1]],si[[2]]]);,
{ProgressIndicator[Appearance->"Necklace"],"Applying tensor symmetries to "ToBasis[flat]@ToBasis[spin]@sy[[2]][fi[[1]],fi[[2]],-si[[1]],si[[2]]]}
];
PrintComputeTensor[sy[[2]],{$flat,$flat,$spin,$spin},{1,1,-1,1},tb,s];
Monitor[
tb=ToValues@ComponentArray@Simplification@TraceBasisDummy@ToBasis[flat]@ToBasis[spin]@(SplitGammaMatrix@ToBasis[flat]@ToBasis[spin]@sy[[3]][fi[[1]],fi[[2]],fi[[3]],-si[[1]],si[[2]]]);,
{ProgressIndicator[Appearance->"Necklace"],"Applying tensor symmetries to "ToBasis[flat]@ToBasis[spin]@sy[[3]][fi[[1]],fi[[2]],fi[[3]],-si[[1]],si[[2]]]}
];
PrintComputeTensor[sy[[3]],{$flat,$flat,$flat,$spin,$spin},{1,1,1,-1,1},tb,s];
$olution[$gamma,$flat,1,$value]=Table[TensorValIDs[sy[[1]]][[ii]]->TensorValues[sy[[1]],Level[TensorValIDs[sy[[1]]][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy[[1]]]}]/.List[x__]:>Association[x];
$olution[$gamma,$flat,2,$value]=Table[TensorValIDs[sy[[2]]][[ii]]->TensorValues[sy[[2]],Level[TensorValIDs[sy[[2]]][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy[[2]]]}]/.List[x__]:>Association[x];
$olution[$gamma,$flat,3,$value]=Table[TensorValIDs[sy[[3]]][[ii]]->TensorValues[sy[[3]],Level[TensorValIDs[sy[[3]]][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy[[3]]]}]/.List[x__]:>Association[x];
]


Compute[$gamma,$curved,s_,ps_]:=Module[{
sy=Table[$olution[$gamma,$curved,ii,$ymbol],{ii,1,3}],
syf=Table[$olution[$gamma,$flat,ii,$ymbol],{ii,1,3}],
dim=$olution[$manifold,$dimension],
ci=$olution[$basis,$curved,$index],
fi=$olution[$basis,$flat,$index],
si=$olution[$basis,$spin,$index],
ee=$olution[$frame,$vielbein,$ymbol],
curved=$olution[$basis,$curved,$ymbol],
flat=$olution[$basis,$flat,$ymbol],
spin=$olution[$basis,$spin,$ymbol],
tb,
a=System`$Assumptions
},
Monitor[
tb=ToValues@ComponentArray@(*Simplification@*)TraceBasisDummy@ToBasis[curved]@ToBasis[flat]@ToBasis[spin]@(ee[ci[[1]],-fi[[-1]]]syf[[1]][fi[[-1]],-si[[1]],si[[2]]]);,
{ProgressIndicator[Appearance->"Necklace"],"Applying tensor symmetries to "ToBasis[curved]@ToBasis[spin]@(sy[[1]][ci[[1]],-si[[1]],si[[2]]])}
];
PrintComputeTensor[sy[[1]],{$curved,$spin,$spin},{1,-1,1},tb,s];
PrintParallelMapSimplify2[{ValID[sy[[1]],{{curved,-spin,spin}}]},ps,System`$Assumptions];
Monitor[
tb=ToValues@ComponentArray@(*Simplification@*)TraceBasisDummy@ToBasis[curved]@ToBasis[flat]@ToBasis[spin]@(ee[-ci[[1]],fi[[-1]]]syf[[1]][-fi[[-1]],-si[[1]],si[[2]]]);,
{ProgressIndicator[Appearance->"Necklace"],"Applying tensor symmetries to "ToBasis[curved]@ToBasis[spin]@(sy[[1]][-ci[[1]],-si[[1]],si[[2]]])}
];
PrintComputeTensor[sy[[1]],{$curved,$spin,$spin},{-1,-1,1},tb,s];
PrintParallelMapSimplify2[{ValID[sy[[1]],{{-curved,-spin,spin}}]},ps,System`$Assumptions];
Monitor[
tb=ToValues@ComponentArray@(*Simplification@*)TraceBasisDummy@ToBasis[spin]@ToBasis[curved]@(SplitGammaMatrix@ToBasis[spin]@ToBasis[curved]@sy[[3]][-ci[[1]],-ci[[2]],-ci[[3]],-si[[1]],si[[2]]]);,(*ToBasis[curved]@ToBasis[flat]@ToBasis[spin]@(ee[-ci\[LeftDoubleBracket]1\[RightDoubleBracket],-fi\[LeftDoubleBracket]-1\[RightDoubleBracket]]ee[-ci\[LeftDoubleBracket]2\[RightDoubleBracket],-fi\[LeftDoubleBracket]-2\[RightDoubleBracket]]ee[-ci\[LeftDoubleBracket]3\[RightDoubleBracket],-fi\[LeftDoubleBracket]-3\[RightDoubleBracket]]syf\[LeftDoubleBracket]3\[RightDoubleBracket][fi\[LeftDoubleBracket]-1\[RightDoubleBracket],fi\[LeftDoubleBracket]-2\[RightDoubleBracket],fi\[LeftDoubleBracket]-3\[RightDoubleBracket],-si\[LeftDoubleBracket]1\[RightDoubleBracket],si\[LeftDoubleBracket]2\[RightDoubleBracket]]);*)
{ProgressIndicator[Appearance->"Necklace"],"Applying tensor symmetries to "ToBasis[curved]@ToBasis[spin]@sy[[3]][-ci[[1]],-ci[[2]],-ci[[3]],-si[[1]],si[[2]]]}
];
PrintComputeTensor[sy[[3]],{$curved,$curved,$curved,$spin,$spin},{-1,-1,-1,-1,1},tb,s];
PrintParallelMapSimplify2[{ValID[sy[[3]],{{-curved,-curved,-curved,-spin,spin}}]},ps,a];
$olution[$gamma,$curved,1,$value]=Table[TensorValIDs[sy[[1]]][[ii]]->TensorValues[sy[[1]],Level[TensorValIDs[sy[[1]]][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy[[1]]]}]/.List[x__]:>Association[x];
$olution[$gamma,$curved,3,$value]=Table[TensorValIDs[sy[[3]]][[ii]]->TensorValues[sy[[3]],Level[TensorValIDs[sy[[3]]][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy[[3]]]}]/.List[x__]:>Association[x];
]


Compute[$pinor,key_,table_,s_,ps_]:=Module[{
sy=$olution[$pinor,key,$ymbol],
a=System`$Assumptions,
spin=$olution[$basis,$spin,$ymbol]
},
PrintComputeTensor[sy,{$spin},{-1},table,s];
PrintParallelMapSimplify2[{ValID[sy,{{-spin}}]},ps,a];
$olution[$pinor,key,$value]=Table[TensorValIDs[sy][[ii]]->TensorValues[sy,Level[TensorValIDs[sy][[ii]],1][[2]]],{ii,1,Length@TensorValIDs[sy]}]/.List[x__]:>Association[x];
]


(* ::Input::Initialization:: *)
Options[GetValues ]={IncludeCoordinatesQ->False};
GetValues[$form,key_ ]:=If[Values@$olution[$form ]=={},Return[{} ],Return[Table[$olution[$form ][[\[Alpha]\[Alpha]]][key ],{\[Alpha]\[Alpha],1,Length@$olution[$form ]} ] ] ]
GetValues[$scalar,key_ ]:=If[Values@$olution[$scalar ]=={},Return[{} ],Return[Table[$olution[$scalar ][[\[Alpha]\[Alpha]]][key ],{\[Alpha]\[Alpha],1,Length@$olution[$scalar ]} ] ] ]
GetValues[$frame,$form,key_ ]:=If[Values@$olution[$frame,$form ]=={},Return[{} ],Return[Table[$olution[$frame,$form ][[\[Alpha]\[Alpha]]][key ],{\[Alpha]\[Alpha],1,Length@$olution[$frame,$form ]} ] ] ]
GetValues[$gamma,key1_,key2_ ]:=If[Values@$olution[$gamma,key1 ]=={},Return[{} ],Return[Table[$olution[$gamma,key1 ][[\[Alpha]\[Alpha]]][key2 ],{\[Alpha]\[Alpha],1,Length@$olution[$gamma,key1 ]} ] ] ]
GetValues[$pinor,key_ ]:=If[Values@$olution[$pinor ]=={},Return[{} ],Return[Table[$olution[$pinor ][[\[Alpha]\[Alpha]]][key ],{\[Alpha]\[Alpha],1,Length@$olution[$pinor ]} ] ] ]
GetValues[$form,$tensor,key_ ]:=If[Values@$olution[$form ]=={},Return[{} ],Return[Table[$olution[$form ][[\[Alpha]\[Alpha]]][$tensor,key ],{\[Alpha]\[Alpha],Flatten@Position[KeyExistsQ[$tensor ]/@Values@$olution[$form ],True ]} ] ] ]
GetValues[$tensor,key_ ]:=If[Values@$olution[$tensor ]=={},Return[{} ],Return[Table[$olution[$tensor ][[\[Alpha]\[Alpha]]][key ],{\[Alpha]\[Alpha],1,Length@$olution[$tensor ]} ] ] ]
GetValues[$ymbol,OptionsPattern[ ] ]:=Module[{inclc=OptionValue[IncludeCoordinatesQ ]},
If[inclc==True,
Return[DeleteCases[Null ]@Join[Values@$olution[$coordinate ],{$olution[$manifold,$ymbol ]},{$olution[$basis,$curved,$ymbol ]},$olution[$basis,$curved,$index ],{$olution[$basis,$flat,$ymbol ]},$olution[$basis,$flat,$index ],{$olution[$basis,$spin,$ymbol ]},$olution[$basis,$spin,$index ],{$olution[$basis,$internal,$ymbol ]},$olution[$basis,$internal,$index ],$olution[$constant,$ymbol ],Head/@$olution[$function,$ymbol ],GetValues[$scalar,$ymbol ],GetValues[$form,$ymbol ],GetValues[$form,$tensor,$ymbol ],GetValues[$tensor,$ymbol ],{$olution[$metric,$curved,$covd ],$olution[$metric,$curved,$tensor,$ymbol ],$olution[$metric,$curved,$epsilon,$ymbol ],$olution[$metric,$curved,$christoffel,$ymbol ],$olution[$metric,$curved,$riemann,$ymbol ],$olution[$metric,$curved,$ricci,$ymbol ],$olution[$metric,$curved,$ricciScalar,$ymbol ],
$olution[$metric,$flat,$tensor,$ymbol ],$olution[$metric,$internal,$covd ],$olution[$metric,$internal,$tensor,$ymbol ],$olution[$metric,$internal,$epsilon,$ymbol ],$olution[$metric,$internal,$christoffel,$ymbol ],$olution[$metric,$internal,$riemann,$ymbol ],$olution[$metric,$internal,$ricci,$ymbol ],$olution[$metric,$internal,$ricciScalar,$ymbol ]},GetValues[$frame,$form,$ymbol ],{$olution[$frame,$vielbein,$ymbol ],$olution[$frame,$spinConnection,$ymbol ]},GetValues[$gamma,$flat,$ymbol ],GetValues[$gamma,$curved,$ymbol ],GetValues[$gamma,$internal,$ymbol ],GetValues[$pinor,$ymbol ] ] ]; ];
If[inclc==False,
Return[DeleteCases[Null ]@Join[{$olution[$manifold,$ymbol ]},{$olution[$basis,$curved,$ymbol ]},$olution[$basis,$curved,$index ],{$olution[$basis,$flat,$ymbol ]},$olution[$basis,$flat,$index ],{$olution[$basis,$spin,$ymbol ]},$olution[$basis,$spin,$index ],{$olution[$basis,$internal,$ymbol ]},$olution[$basis,$internal,$index ],$olution[$constant,$ymbol ],Head/@$olution[$function,$ymbol ],GetValues[$scalar,$ymbol ],GetValues[$form,$ymbol ],GetValues[$form,$tensor,$ymbol ],GetValues[$tensor,$ymbol ],{$olution[$metric,$curved,$covd ],$olution[$metric,$curved,$tensor,$ymbol ],$olution[$metric,$curved,$epsilon,$ymbol ],$olution[$metric,$curved,$christoffel,$ymbol ],$olution[$metric,$curved,$riemann,$ymbol ],$olution[$metric,$curved,$ricci,$ymbol ],$olution[$metric,$curved,$ricciScalar,$ymbol ],
$olution[$metric,$flat,$tensor,$ymbol ],$olution[$metric,$internal,$covd ],$olution[$metric,$internal,$tensor,$ymbol ],$olution[$metric,$internal,$epsilon,$ymbol ],$olution[$metric,$internal,$christoffel,$ymbol ],$olution[$metric,$internal,$riemann,$ymbol ],$olution[$metric,$internal,$ricci,$ymbol ],$olution[$metric,$internal,$ricciScalar,$ymbol ]},GetValues[$frame,$form,$ymbol ],{$olution[$frame,$vielbein,$ymbol ],$olution[$frame,$spinConnection,$ymbol ]},GetValues[$gamma,$flat,$ymbol ],GetValues[$gamma,$curved,$ymbol ],GetValues[$gamma,$internal,$ymbol ],GetValues[$pinor,$ymbol ] ] ]; ]; ]
Options[GetKeys ]={$tensorQ->Null};
GetKeys[$form,OptionsPattern[ ] ]:=Module[{tk={},tQ=OptionValue[$tensorQ ]},
If[tQ==Null,Return[Keys@$olution[$form ] ] ];
If[tQ==True,
Do[If[KeyExistsQ[$tensor ]@$olution[$form ][[\[Alpha]\[Alpha]]]==True,
tk=AppendTo[tk,(Keys@$olution[$form ])[[\[Alpha]\[Alpha]]] ] ],{\[Alpha]\[Alpha],1,Length@$olution[$form ]} ];
Return[tk ] ];
If[tQ==False,
Do[If[KeyExistsQ[$tensor ]@$olution[$form ][[\[Alpha]\[Alpha]]]==False,
tk=AppendTo[tk,(Keys@$olution[$form ])[[\[Alpha]\[Alpha]]] ] ],{\[Alpha]\[Alpha],1,Length@$olution[$form ]} ];
Return[tk ] ] ]


(* ::Input::Initialization:: *)
SetupManifold[ ]:=(Set[$Context,$olution[$info,$context ] ];
Module[{man=$olution[$manifold,$ymbol ],dim=$olution[$manifold,$dimension ],ci=$olution[$basis,$curved,$index ],ct=$olution[$info,$context ],gb="Global`"},
If[ManifoldQ[man ]==True,
Set[$Context,gb ];
Print@@{"Manifold ",FS@man," is already defined | Nothing was redefined"};
Set[$Context,ct ]; ];
If[ManifoldQ[man ]==False,
DefManifold[man,dim,ci ];
Set[$Context,gb ];
Print@@{"Defined manifold ",FS@man," of dimension ",FS@dim, " with indices ",FS@ci};
Set[$Context,ct ]; ]; ])


(* ::Input::Initialization:: *)
SetConstantSymbols[ ]:=(Set[$Context,$olution[$info,$context ] ];
Module[{pcs=$olution[$constant,$ymbol ],cs,ncs,ct=$olution[$info,$context ],gb="Global`"},
If[pcs!={},
cs=Select[pcs,ConstantSymbolQ[# ]==True & ];
ncs=Select[pcs,ConstantSymbolQ[# ]==False & ];
If[cs=={},
DefConstantSymbol@pcs;
Set[System`$Context,gb ];
Print["Defined constant symbols ",FS@pcs ];
Set[System`$Context,ct ]; ];
If[ncs=={},
Set[System`$Context,gb ];
Print["Constant symbols ",FS@pcs," are already defined | Nothing was redefined" ];
Set[System`$Context,ct ] ];
If[TrueQ[cs!={}]==True&&TrueQ[ncs!={}]==True,
DefConstantSymbol@ncs;
Set[System`$Context,gb ];
Print["Defined constant symbols ",FS@ncs," | Constant symbols ",FS@cs," are already defined | Nothing else was defined" ];
Set[System`$Context,ct ]; ]; ] ])


(* ::Input::Initialization:: *)
SetScalarFunctions[ ]:=(Set[$Context,$olution[$info,$context ] ];
Module[{psf=Head/@$olution[$function,$ymbol ],sf,nsf,ct=$olution[$info,$context ],gb="Global`"},
If[psf!={},
sf=Select[psf,ScalarFunctionQ[# ]==True & ];
nsf=Select[psf,ScalarFunctionQ[# ]==False & ];
If[sf=={},
DefScalarFunction@psf;
Set[System`$Context,gb ];
Print["Defined scalar functions ",FS@psf ];
Set[System`$Context,ct ]; ];
If[nsf=={},
Set[System`$Context,gb ];
Print["Scalar functions ",FS@psf," are already defined | Nothing was redefined" ];
Set[System`$Context,ct ] ];
If[TrueQ[sf!={}]==True&&TrueQ[nsf!={}]==True,
DefScalarFunction@nsf;
Set[System`$Context,gb ];
Print["Defined scalar functions ",FS@nsf," | Scalar functions ",FS@sf," are already defined | Nothing else was defined" ];
Set[System`$Context,ct ]; ]; ] ])


(* ::Input::Initialization:: *)
SetChart[ ]:=(Set[$Context,$olution[$info,$context ] ];
Module[{
man=$olution[$manifold,$ymbol ],
cn=Keys@$olution[$coordinate ],
xc=Values@$olution[$coordinate ]//.ToXCoord,
curved=$olution[$basis,$curved,$ymbol ],
cc=$olution[$basis,$curved,$color ],
ChristoffelPDcurved=Symbol@@{"ChristoffelPD"<>ToString[$olution[$basis,$curved,$ymbol ] ]},ct=$olution[$info,$context ],gb="Global`"},
If[ChartQ[curved ]==True,
Set[System`$Context,gb ];
Print["Chart ",FS@curved," is already defined | Nothing was redefined" ];
Set[System`$Context,ct ]; ];
If[ChartQ[curved ]==False,
DefChart[curved,man,cn,xc,FormatBasis->{"Partials","Differentials"},ChartColor->cc ];
ChristoffelPDcurved[__]:=0;
Set[System`$Context,gb ];
Print["Defined ",cc," chart ",FS@curved," with coordinates ",FS@xc," on the manifold ",FS@man," | Set ",FS@ChristoffelPDcurved," to zero" ];
Set[System`$Context,ct ]; ]; ])


(* ::Input::Initialization:: *)
SetForms[ ]:=(Set[$Context,$olution[$info,$context ] ];
Module[{
man=$olution[$manifold,$ymbol ],
pfs=GetValues[$form,$ymbol ],
pfp=GetValues[$form,$print ],
pfr=GetValues[$form,$rank ],
fs,fp,fr,nfs,nfp,nfr,
gb="Global`",ct=$olution[$info,$context ],newpos},
If[Length@pfs!=0,
fs=Select[pfs,xTensorQ[# ]==True & ];
nfs=Select[pfs,xTensorQ[# ]==False & ];
If[fs=={},
Do[
DefDiffForm[pfs[[\[Alpha]\[Alpha]]]//.ToXForm,man,pfr[[\[Alpha]\[Alpha]]],PrintAs->pfp[[\[Alpha]\[Alpha]]] ];
,{\[Alpha]\[Alpha],1,Length@pfs} ];
Set[System`$Context,gb ];
Print["Defined forms ",FS@pfs," of ranks ",FS@pfr," on the manifold ",FS@man ];
Set[System`$Context,ct ]; ];
If[nfs=={},
Set[System`$Context,gb ];
Print["Forms ",FS@fs, " are already defined | Nothing was redefiend" ];
Set[System`$Context,ct ]; ];
If[TrueQ[fs!={}]==True&&TrueQ[nfs!={}]==True,
newpos=Flatten@Table[Position[pfs,nfs[[\[Alpha]\[Alpha]]] ],{\[Alpha]\[Alpha],1,Length@nfs} ];
nfs=Table[pfs[[newpos[[\[Alpha]\[Alpha]]]]],{\[Alpha]\[Alpha],1,Length@newpos} ];
nfr=Table[pfr[[newpos[[\[Alpha]\[Alpha]]]]],{\[Alpha]\[Alpha],1,Length@newpos} ];
nfp=Table[pfp[[newpos[[\[Alpha]\[Alpha]]]]],{\[Alpha]\[Alpha],1,Length@newpos} ];
Do[
DefDiffForm[nfs[[\[Alpha]\[Alpha]]]//.ToXForm,man,nfr[[\[Alpha]\[Alpha]]],PrintAs->nfp[[\[Alpha]\[Alpha]]] ];
,{\[Alpha]\[Alpha],1,Length@nfs} ];
Set[System`$Context,gb ];
Print["Defined forms ",FS@nfs," of ranks ",FS@nfr," on the manifold ",FS@man," | Forms ",FS@fs," are already defined | Nothing else was redefined" ];
Set[System`$Context,ct ]; ]; ] ])


(* ::Input::Initialization:: *)
SetTensors[ ]:=(Set[$Context,$olution[$info,$context ] ];
Module[{
man=$olution[$manifold,$ymbol ],
pfts=GetValues[$form,$tensor,$ymbol ],
pftp=GetValues[$form,$tensor,$print ],
pftr=GetValues[$form,$tensor,$rank ],
ptts=GetValues[$tensor,$ymbol ],
pttp=GetValues[$tensor,$print ],
pttr=GetValues[$tensor,$rank ],
fts,ftp,ftr,nfts,nftp,nftr,
tts,ttp,ttr,ntts,nttp,nttr,
gb="Global`",ct=$olution[$info,$context ],newpos},
If[Length@pfts!=0,
fts=Select[pfts,xTensorQ[# ]==True & ];
nfts=Select[pfts,xTensorQ[# ]==False & ];
If[fts=={},
Do[
If[pftr[[\[Alpha]\[Alpha]]]==1,
DefTensor[pfts[[\[Alpha]\[Alpha]]]@@(-GetIndicesOfVBundle[TangentBundleOfManifold[man ],pftr[[\[Alpha]\[Alpha]]] ]),man,PrintAs->pftp[[\[Alpha]\[Alpha]]] ] ];
If[pftr[[\[Alpha]\[Alpha]]]>=2,
DefTensor[pfts[[\[Alpha]\[Alpha]]]@@(-GetIndicesOfVBundle[TangentBundleOfManifold[man ],pftr[[\[Alpha]\[Alpha]]] ]),man,Antisymmetric[Table[ii,{ii,1,pftr[[\[Alpha]\[Alpha]]]} ] ],PrintAs->pftp[[\[Alpha]\[Alpha]]] ] ]
,{\[Alpha]\[Alpha],1,Length@pfts} ];
Set[System`$Context,gb ];
Print["Defined antisymmetric tensors ",FS@pfts," of ranks ",FS@pftr," on the manifold ",FS@man ];
Set[System`$Context,ct ]; ];
If[nfts=={},
Set[System`$Context,gb ];
Print["Antisymmetric tensors ",FS@fts, " are already defined | Nothing was redefiend" ];
Set[System`$Context,ct ]; ];
If[TrueQ[fts!={}]==True&&TrueQ[nfts!={}]==True,
newpos=Flatten@Table[Position[pfts,nfts[[\[Alpha]\[Alpha]]] ],{\[Alpha]\[Alpha],1,Length@nfts} ];
nfts=Table[pfts[[newpos[[\[Alpha]\[Alpha]]]]],{\[Alpha]\[Alpha],1,Length@newpos} ];
nftp=Table[pftp[[newpos[[\[Alpha]\[Alpha]]]]],{\[Alpha]\[Alpha],1,Length@newpos} ];
nftr=Table[pftr[[newpos[[\[Alpha]\[Alpha]]]]],{\[Alpha]\[Alpha],1,Length@newpos} ];
Do[
If[nftr[[\[Alpha]\[Alpha]]]==1,
DefTensor[nfts[[\[Alpha]\[Alpha]]]@@(-GetIndicesOfVBundle[TangentBundleOfManifold[man ],nftr[[\[Alpha]\[Alpha]]] ]),man,PrintAs->nftp[[\[Alpha]\[Alpha]]] ] ];
If[nftr[[\[Alpha]\[Alpha]]]>=2,
DefTensor[nfts[[\[Alpha]\[Alpha]]]@@(-GetIndicesOfVBundle[TangentBundleOfManifold[man ],nftr[[\[Alpha]\[Alpha]]] ]),man,Antisymmetric[Table[ii,{ii,1,nftr[[\[Alpha]\[Alpha]]]} ] ],PrintAs->nftp[[\[Alpha]\[Alpha]]] ] ]
,{\[Alpha]\[Alpha],1,Length@nfts} ];
Set[System`$Context,gb ];
Print["Defined antisymmetric ",FS@nfts," of ranks ",FS@nftr," on the manifold ",FS@man," | Tensors ",FS@fts," are already defined | Nothing else was redefined" ];
Set[System`$Context,ct ]; ]; ];
If[Length@ptts!=0,
tts=Select[ptts,xTensorQ[# ]==True & ];
ntts=Select[ptts,xTensorQ[# ]==False & ];
If[tts=={},
Do[DefTensor[ptts[[\[Alpha]\[Alpha]]]@@(-GetIndicesOfVBundle[TangentBundleOfManifold[man ],pttr[[\[Alpha]\[Alpha]]] ]),man,PrintAs->pttp[[\[Alpha]\[Alpha]]] ],{\[Alpha]\[Alpha],1,Length@ptts} ];
Set[System`$Context,gb ];
Print["Defined tensors ",FS@ptts," of ranks ",FS@pttr," on the manifold ",FS@man ];
Set[System`$Context,ct ]; ];
If[ntts=={},
Set[System`$Context,gb ];
Print["Tensors ",FS@tts, " are already defined | Nothing was redefiend" ];
Set[System`$Context,ct ]; ];
If[TrueQ[tts!={}]==True&&TrueQ[ntts!={}]==True,
newpos=Flatten@Table[Position[ptts,ntts[[\[Alpha]\[Alpha]]] ],{\[Alpha]\[Alpha],1,Length@ntts} ];
ntts=Table[ptts[[newpos[[\[Alpha]\[Alpha]]]]],{\[Alpha]\[Alpha],1,Length@newpos} ];
nttp=Table[pttp[[newpos[[\[Alpha]\[Alpha]]]]],{\[Alpha]\[Alpha],1,Length@newpos} ];
nttr=Table[pttr[[newpos[[\[Alpha]\[Alpha]]]]],{\[Alpha]\[Alpha],1,Length@newpos} ];
Do[DefTensor[ntts[[\[Alpha]\[Alpha]]]@@(-GetIndicesOfVBundle[TangentBundleOfManifold[man ],nttr[[\[Alpha]\[Alpha]]] ]),man,PrintAs->nttp[[\[Alpha]\[Alpha]]] ]
,{\[Alpha]\[Alpha],1,Length@ntts} ];
Set[System`$Context,gb ];
Print["Defined tensors ",FS@ntts," of ranks ",FS@nttr," on the manifold ",FS@man," | Tensors ",FS@tts," are already defined | Nothing else was redefined" ];
Set[System`$Context,ct ]; ]; ] ])


(* ::Input::Initialization:: *)
SetupMetric[ ]:=(Set[$Context,$olution[$info,$context ]];
Module[{man=$olution[$manifold,$ymbol ],
gs=$olution[$metric,$curved,$tensor,$ymbol ],
gp=$olution[$metric,$curved,$tensor,$print ],
sd=$olution[$metric,$curved,$igndet ],
cd=$olution[$metric,$curved,$covd ],
ind=GetIndicesOfVBundle[TangentBundleOfManifold[$olution[$manifold,$ymbol ] ],Length@$ymbol[$basis,$curved,$index ] ],
gb="Global`",ct=$olution[$info,$context ]},
If[MetricQ[gs ]==True,
Set[System`$Context,gb ];
Print["Metric ",FS@gs, " is already defined | Nothing was redefined" ];
Set[System`$Context,ct ]; ];
If[MetricQ[gs ]==False,
DefMetric[sd,gs@@{-ind[[1]],-ind[[2]]},cd,{";","\[Del]"},PrintAs->gp,SymCovDQ->True ];
Set[System`$Context,gb ];
Print["Defined metric ",FS@gs, " of signature ",FS@sd," and covariant derivative ",FS@cd ];
Set[System`$Context,ct ]; ] ])


(* ::Input::Initialization:: *)
SetFrameBundle[ ]:=(Set[$Context,$olution[$info,$context ] ];
Module[{
ee=$olution[$frame,$vielbein,$ymbol ],
ep=$olution[$frame,$vielbein,$print ],
eta=$olution[$metric,$flat,$tensor,$ymbol ],
etap=$olution[$metric,$flat,$tensor,$print ],
ci=$olution[$basis,$curved,$index ],
fi=$olution[$basis,$flat,$index ],
si=$olution[$basis,$spin,$index ],
ct=$olution[$info,$context ],gb="Global`"},
If[xTensorQ[ee ]==True,
Set[System`$Context,gb ];
Print["Frame ",FS@ee," with flat metric ",FS@eta," is already defined | Nothing was redefined" ];
Set[System`$Context,ct ]; ];
If[xTensorQ[ee ]==False,
DefFrameBundle[ee[-ci[[1]],fi[[1]] ],eta[-fi[[1]],-fi[[2]] ],fi,PrintAs->{ep,etap} ];
Set[System`$Context,gb ];
Print["Defined frame ",FS@ee," with flat metric ",FS@eta," and flat indices ",FS@fi ];
Set[System`$Context,ct ]; ] ])


(* ::Input::Initialization:: *)
SetSpinStructure[ ]:=(Set[$Context,$olution[$info,$context ] ];
Module[{gg=$olution[$metric,$curved,$tensor,$ymbol ],si=$olution[$basis,$spin,$index ],Gammagg1=(Values@$olution[$gamma,$curved ][[1]])[[1]],ct=$olution[$info,$context ],gb="Global`"},
If[xTensorQ[Gammagg1 ]==True,
Set[System`$Context,gb ];
Print["Spin structure on the metric ",FS@gg," is already defined | Nothing was redefined" ];
Set[System`$Context,ct ]; ];
If[xTensorQ[Gammagg1 ]==False,
DefSpinStructure[gg,si ];
Set[System`$Context,gb ];
Print["Defined spin structure on the metric ",FS@gg," with spin indices ",FS@si ];
Set[System`$Context,ct ]; ] ])


(* ::Input::Initialization:: *)
SetSpinConnection[ ]:=(Set[$Context,$olution[$info,$context ] ];
Module[{
\[Omega]=$olution[$frame,$spinConnection,$ymbol ],
\[Omega]p=$olution[$frame,$spinConnection,$print ],
ci=$olution[$basis,$curved,$index ],
fi=$olution[$basis,$flat,$index ],
cd=$olution[$metric,$curved,$covd ],
ct=$olution[$info,$context ],gb="Global`"},
If[xTensorQ[\[Omega] ]==True,
Set[System`$Context,gb ];
Print["Spin connection ",FS@\[Omega]," is already defined | Nothing was redefined" ];
Set[System`$Context,ct ]; ];
If[xTensorQ[\[Omega] ]==False,
DefSpinConnection[\[Omega][-ci[[1]],-fi[[1]],-fi[[2]] ],cd,PrintAs->\[Omega]p ];
Set[System`$Context,gb ];
Print["Defined spin connection ",FS@\[Omega]," of the covariant derivative ",FS@cd ];
Set[System`$Context,ct ]; ] ])


(* ::Input::Initialization:: *)
SetFrameForms[ ]:=(Set[$Context,$olution[$info,$context ] ];
Module[{
man=$olution[$manifold,$ymbol ],
fs=GetValues[$frame,$form,$ymbol ],
fp=GetValues[$frame,$form,$print ],
ct=$olution[$info,$context ],gb="Global`"},
If[xTensorQ/@fs==ConstantArray[True,Length@fs ],
Set[System`$Context,gb ];
Print["Forms ",FS@fs, " are already defined | Nothing was redefiend" ];
Set[System`$Context,ct ]; ];
If[xTensorQ/@fs==ConstantArray[False,Length@fs ],
Do[DefDiffForm[fs[[ii]]//.ToXForm,man,1,PrintAs->fp[[ii]] ];,{ii,1,Length@fs} ];
Set[System`$Context,gb ];
Print["Defined forms ",FS@fs," of degrees ",FS@ConstantArray[1,Length@fs ]," on the manifold ",FS@man ];
Set[System`$Context,ct ]; ] ])


(* ::Input::Initialization:: *)
SetSpinors[ ]:=(Set[$Context,$olution[$info,$context ] ];
Module[{
man=$olution[$manifold,$ymbol ],
ss=GetValues[$pinor,$ymbol ],
sp=GetValues[$pinor,$print ],
st=GetValues[$pinor,$type ],
si=$olution[$basis,$spin,$index ],ct=$olution[$info,$context ],gb="Global`"},
 If[SpinorQ/@ss==ConstantArray[True,Length@ss ],
Set[System`$Context,gb ];
Print["Spinors ",FS@ss," are already defined | Nothing was redefined" ];
Set[System`$Context,ct ]; ];
If[SpinorQ/@ss==ConstantArray[False,Length@ss ],
Do[DefSpinor[ss[[ii]][-si[[1]] ],man,SpinorType->st[[ii]],PrintAs->sp[[ii]] ],{ii,1,Length@ss} ];
Set[System`$Context,gb ];
Print["Defined spinors ",FS@ss," of types ",FS@st, " on the manifold ",FS@man ];
Set[System`$Context,ct ]; ] ])


(* ::Input::Initialization:: *)
SetBases[ ]:=(Set[$Context,$olution[$info,$context ] ];
Module[{
man=$olution[$manifold,$ymbol ],
cn=Keys@$olution[$frame,$form ],
fs=$olution[$basis,$flat,$ymbol ],
fc=$olution[$basis,$flat,$color ],
fi=$olution[$basis,$flat,$index ],
Fman=Symbol@@{"Frame"<>ToString[$olution[$manifold,$ymbol ] ]},
ACfs=Symbol@@{"AChristoffelPD"<>ToString[$olution[$basis,$flat,$ymbol ] ]},
ss=$olution[$basis,$spin,$ymbol ],
sc=$olution[$basis,$spin,$color ],
si=$olution[$basis,$spin,$index ],
Sman=Symbol@@{"Spin"<>ToString[$olution[$manifold,$ymbol ] ]},
ACss=Symbol@@{"AChristoffelPD"<>ToString[$olution[$basis,$spin,$ymbol ] ]},
ct=$olution[$info,$context ],gb="Global`"},
If[BasisQ[fs ]==True,
Set[System`$Context,gb ];
Print["Basis ",FS@fs," is already defined | Nothing is redefined" ];
Set[System`$Context,ct ];,
DefBasis[fs,Fman,cn,BasisColor->fc ];
ACfs[__ ]:=0;
Set[System`$Context,gb ];
Print["Defined ",fc," basis ",FS@fs," on the vector bundle ",FS@Fman," | Set ",FS@ACfs," to zero" ];
Set[System`$Context,ct ]; ];
If[BasisQ[ss ]==True,
Set[System`$Context,gb ];
Print["Basis ",FS@ss," is already defined | Nothing is redefined" ];
Set[System`$Context,ct ];,
DefBasis[ss,Sman,Table[jj,{jj,1,DimOfVBundle[Sman ]} ],BasisColor->sc ];
ACss[__ ]:=0;
Set[System`$Context,gb ];
Print["Defined " ,sc," basis ",FS@ss," on the vector bundle ",FS@Sman," | Set ",FS@ACss," to zero" ];
Set[System`$Context,ct ]; ]; ])


(* ::Input::Initialization:: *)
Options[SetSolution ]={SetForSusyQ->False,PrintContextQ->True};
SetSolution[OptionsPattern[ ] ]:=Module[{sQ=$olution[$info,$usyQ ],ssQ=OptionValue[SetForSusyQ ],gb="Global`",ct=$olution[$info,$context ],pc=OptionValue[PrintContextQ ]},
If[ssQ==False,
SetManifold[ ];
SetConstantSymbols[ ];
SetScalarFunctions[ ];
SetChart[ ];
SetForms[ ];
SetTensors[ ];
SetMetric[ ];
UseDimensionStart[ ];
CommutativityOfProduct[CircleTimes ]^="Commutative";
System`$Assumptions =And@@DeleteDuplicates@Join[{0<$infinity},Flatten@Values@$olution[$assumption ],Flatten@Values@$olution[$assumption ]//.ToXCoord ];
Set[$Context,gb ];
Print["Set ",FB@"$Assumptions"," = ",FS@System`$Assumptions ];
Set[$Context,ct ];
If[pc==True,Print["Current context: " FS@System`$Context ] ] ];
If[ssQ==True&&sQ==True,
SetManifold[ ];
SetConstantSymbols[ ];
SetScalarFunctions[ ];
SetChart[ ];
SetForms[ ];
SetTensors[ ];
SetMetric[ ];
SetFrameBundle[ ];
SetSpinStructure[ ];
SetSpinConnection[ ];
SetFrameForms[ ];
SetSpinors[ ];
SetBases[ ];
UseDimensionStart[ ];
CommutativityOfProduct[CircleTimes ]^="Commutative";
System`$Assumptions =And@@DeleteDuplicates@Join[{0<$infinity},Flatten@Values@$olution[$assumption ],Flatten@Values@$olution[$assumption ]//.ToXCoord ];
Set[$Context,gb ];
Print["Set ",FB@"$Assumptions"," = ",FS@System`$Assumptions ];
Set[$Context,ct ];
If[pc==True,Print["Current context: " FS@System`$Context ] ] ]; 
If[ssQ==True&&sQ==False,Print["Cannot set susy environment for a non-susy solution | Nothing was defined" ] ] ]


Options[CalculateRank2Tensor]={SimplificationMethod->Simplify};
CalculateRank2Tensor[tenSymb_,tensorMatrix_,OptionsPattern[]]:=(Set[$Context,$olution[$info,$context]];
Module[
{man=$olution[$manifold,$ymbol],
curved=$olution[$basis,$curved,$ymbol],
dim=$olution[$manifold,$dimension],
gs=$olution[$metric,$curved,$tensor,$ymbol],
cd=$olution[$metric,$curved,$covd],
sd=$olution[$metric,$curved,$igndet],
ind=GetIndicesOfVBundle[TangentBundleOfManifold[$olution[$manifold,$ymbol]],Length@$olution[$basis,$curved,$index]],
at,TDD=tensorMatrix,TUD,TDU,TUU,
sT=OptionValue[SimplificationMethod],
gb="Global`",ct=$olution[$info,$context],ts=tenSymb},
If[ToString[SymmetryGroupOfTensor[ts]]==\!\(\*
TagBox[
StyleBox["\"\<StrongGenSet[{1, 2}, GenSet[Cycles[{1, 2}]]]\>\"",
ShowSpecialCharacters->False,
ShowStringCharacters->True,
NumberMarks->True],
FullForm]\),
$CVSimplify=sT;
(*TDD*)
at=AbsoluteTime[];
Monitor[Do[ComponentValue[ts[{-ind[[1]],-curved},{-ind[[2]],-curved} ]/.{ind[[1]]->-ii,ind[[2]]->-jj} ],
{jj,0,dim-2},{ii,jj+1,dim-1} ],
{ProgressIndicator[Dynamic@jj,Dynamic/@{0,dim-2},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@ii,Dynamic/@{jj+1,dim-1},ImageSize->{Automatic,5}]},$startMonitoring ];
Monitor[Do[ComponentValue[ts[{ii,-curved},{jj,-curved} ],TDD[[ii+1,jj+1]]],
{ii,0,dim-1},{jj,ii,dim-1}],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@jj,Dynamic/@{ii,dim-1},ImageSize->{Automatic,5}]},$startMonitoring ];
Print["Calculated ",ts[-{ind[[1]],curved},-{ind[[2]],curved} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
(*TUD*)
at=AbsoluteTime[];
Monitor[Do[ComponentValue[ts[{ii,curved},{jj,-curved}]],{ii,1,dim-1},{jj,0,ii-1}],
{ProgressIndicator[Dynamic@ii,Dynamic/@{1,dim-1},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@jj,Dynamic/@{0,ii-1},ImageSize->{Automatic,5}]},$startMonitoring];
TUD=TraceBasisDummy@ToBasis[curved ]@ToBasis[curved ]@(gs[ind[[1]],ind[[-1]]]ts[-ind[[-1]],-ind[[2]]] );
Monitor[Do[ComponentValue[ts[{ii,curved},{jj,-curved} ],ToValues@(TUD/.{ind[[1]]->ii,ind[[2]]->-jj})],{ii,0,dim-1},{jj,ii,dim-1}],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@jj,Dynamic/@{ii,dim-1},ImageSize->{Automatic,5}]},$startMonitoring];
TDU=TraceBasisDummy@ToBasis[curved ]@ToBasis[curved ]@(ts[-ind[[1]],-ind[[-1]]]gs[ind[[-1]],ind[[2]]]);
Monitor[Do[ComponentValue[ts[{ii,-curved},{jj,curved}],ToValues@(TDU/.{ind[[1]]->-ii,ind[[2]]->jj})],{ii,0,dim-2},{jj,ii+1,dim-1}],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-2},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@jj,Dynamic/@{ii+1,dim-1},ImageSize->{Automatic,5}]},$startMonitoring];
Print["Calculated ",ts[ {ind[[1]],curved},-{ind[[2]],curved}]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[]-at)," seconds" ];
];
(*TUU*)
(*at=AbsoluteTime[];
Monitor[Do[ComponentValue[ts[{ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved} ]/.{ind\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]ii,ind\[LeftDoubleBracket]2\[RightDoubleBracket]\[Rule]jj} ],
{jj,0,dim-2},{ii,jj+1,dim-1} ],
{ProgressIndicator[Dynamic@jj,Dynamic/@{0,dim-2},ImageSize\[Rule]{Automatic,5}],
ProgressIndicator[Dynamic@ii,Dynamic/@{jj+1,dim-1},ImageSize\[Rule]{Automatic,5}]},$startMonitoring ];
TUU=TraceBasisDummy@ToBasis[curved ]@ToBasis[curved ]@(ts[ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]-1\[RightDoubleBracket]]gs[ind\[LeftDoubleBracket]-1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket]]);
Monitor[Do[ComponentValue[ts[{ii,curved},{jj,curved} ],ToValues@(TUU/.{ind\[LeftDoubleBracket]1\[RightDoubleBracket]->ii,ind\[LeftDoubleBracket]2\[RightDoubleBracket]->jj})],
{ii,0,dim-1},{jj,ii,dim-1}],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize\[Rule]{Automatic,5}],
ProgressIndicator[Dynamic@jj,Dynamic/@{ii,dim-1},ImageSize\[Rule]{Automatic,5}]},$startMonitoring ];
Print["Calculated ",ts[ {ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved}]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[]-at)," seconds" ];*)
$CVSimplify=Simplify;
]
)


(* ::Input::Initialization:: *)
(*Options[CalculateMetric]={SimplificationMethod\[Rule]{Simplify,Simplify,Simplify,Identity},AllQ\[Rule]False};
CalculateMetric[OptionsPattern[]]:=(Set[$Context,$olution[$info,$context]];
Module[{man=$olution[$manifold,$ymbol],
curved=$olution[$basis,$curved,$ymbol],
dim=$olution[$manifold,$dimension],
gg=$olution[$metric,$curved,$tensor,$ymbol],
cd=$olution[$metric,$curved,$covd],
sd=$olution[$metric,$curved,$igndet],
ind=GetIndicesOfVBundle[TangentBundleOfManifold[$olution[$manifold,$ymbol]],Length@$olution[$basis,$curved,$index]],
at,srg,tmp,ili,gDD,gUU,R,
sg=OptionValue[SimplificationMethod]\[LeftDoubleBracket]1\[RightDoubleBracket],
s\[Epsilon]=OptionValue[SimplificationMethod]\[LeftDoubleBracket]2\[RightDoubleBracket],
s\[CapitalGamma]=OptionValue[SimplificationMethod]\[LeftDoubleBracket]3\[RightDoubleBracket],
sR=OptionValue[SimplificationMethod]\[LeftDoubleBracket]4\[RightDoubleBracket],
epsilongg=$olution[$metric,$curved,$epsilon,$ymbol],
Christoffelcd=$olution[$metric,$curved,$christoffel,$ymbol],
Riemanncd=$olution[$metric,$curved,$riemann,$ymbol],
Riccicd=$olution[$metric,$curved,$ricci,$ymbol],
RicciScalarcd=$olution[$metric,$curved,$ricciScalar,$ymbol],
gb="Global`",ct=$olution[$info,$context]},
(*Metric*)
$CVSimplify=sg;
(*gDD*)
at=AbsoluteTime[ ];
gDD=GenMetricMatrix[ ];
MetricInBasis[gg,-curved,gDD ];
Print["Calculated ",gg[-{ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
(*gUU*)
at=AbsoluteTime[ ];
gUU=Inverse@gDD;
MetricInBasis[gg,curved,gUU ];
Print["Calculated ",gg[{ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
(*Epsilon-pseudo-tensor*)
$CVSimplify=s\[Epsilon];
(*\[Epsilon]D...*)
srg=Sqrt[sd Det[gDD ]];
at=AbsoluteTime[];
ComponentValue/@ComponentArray@ToBasis[curved]@(epsilon[gg]@@Table[-ind\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],{\[Alpha]\[Alpha],1,dim}])//Flatten;
ComponentValue[epsilongg@@Table[{\[Alpha]\[Alpha],-curved},{\[Alpha]\[Alpha],0,5-1}],srg];
Print["Calculated ",epsilongg@@Table[-{ind\[LeftDoubleBracket]ii\[RightDoubleBracket],curved},{ii,1,dim} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
(*\[Epsilon]U...*)
If[OptionValue[AllQ]\[Equal]True,
at=AbsoluteTime[];
ComponentValue/@ComponentArray@ToBasis[curved]@(epsilon[gg]@@Table[ind\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],{\[Alpha]\[Alpha],1,dim}])//Flatten;
ComponentValue[epsilongg@@Table[{\[Alpha]\[Alpha],curved},{\[Alpha]\[Alpha],0,5-1}],sd srg];
Print["Calculated ",epsilongg@@Table[{ind\[LeftDoubleBracket]ii\[RightDoubleBracket],curved},{ii,1,dim} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
];
(*Christoffel*)
$CVSimplify=s\[CapitalGamma];
(*AllQ = True*)
If[OptionValue[AllQ]==True,
at=AbsoluteTime[];
ComponentValue/@ComponentArray@ToBasis[curved]@Christoffelcd[-ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket],-ind\[LeftDoubleBracket]3\[RightDoubleBracket]]//Flatten;
ComponentValue/@ComponentArray@ToBasis[curved]@Christoffelcd[ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket],-ind\[LeftDoubleBracket]3\[RightDoubleBracket]]//Flatten;
ComponentValue/@ComponentArray@ToBasis[curved]@Christoffelcd[ind\[LeftDoubleBracket]1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket],-ind\[LeftDoubleBracket]3\[RightDoubleBracket]]//Flatten;
ComponentValue/@ComponentArray@ToBasis[curved]@Christoffelcd[ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket],ind\[LeftDoubleBracket]3\[RightDoubleBracket]]//Flatten;
(*\[CapitalGamma]DDD*)
ili=Table[Level[Keys@TensorValues[Christoffelcd]\[LeftDoubleBracket]-1\[RightDoubleBracket]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],1]//Flatten//DeleteCases[-curved]//DeleteCases[curved],{\[Alpha]\[Alpha],1,Length@Keys@TensorValues[Christoffelcd]\[LeftDoubleBracket]-1\[RightDoubleBracket]}];
Monitor[
Do[ComponentValue[
Christoffelcd[{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket],-curved}],
ToValues@(ToBasis[curved ]@ToBasis[curved ]@ChristoffelToGradMetric@Christoffelcd[-ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket],-ind\[LeftDoubleBracket]3\[RightDoubleBracket]]/.
{ind\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],ind\[LeftDoubleBracket]3\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket]}
)
],{\[Alpha]\[Alpha],1,Length@ili}
],ProgressIndicator[\[Alpha]\[Alpha],{1,Length@ili},ImageSize\[Rule]{300,5}],$startMonitoring
];
Print["Calculated ",Christoffelcd[-{ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]3\[RightDoubleBracket],curved} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
(*\[CapitalGamma]UDD*)
ili=Table[Level[Keys@TensorValues[Christoffelcd]\[LeftDoubleBracket]-1\[RightDoubleBracket]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],1]//Flatten//DeleteCases[-curved]//DeleteCases[curved],{\[Alpha]\[Alpha],1,Length@Keys@TensorValues[Christoffelcd]\[LeftDoubleBracket]-1\[RightDoubleBracket]}];
Monitor[
Do[ComponentValue[
Christoffelcd[{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket],-curved}],
ToValues@(TraceBasisDummy@ToBasis[curved]@(gg[ind\[LeftDoubleBracket]1\[RightDoubleBracket],ind\[LeftDoubleBracket]-1\[RightDoubleBracket]]Christoffelcd[-ind\[LeftDoubleBracket]-1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket],-ind\[LeftDoubleBracket]3\[RightDoubleBracket]])/.
{ind\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],ind\[LeftDoubleBracket]3\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket]}
)
],{\[Alpha]\[Alpha],1,Length@ili}
],ProgressIndicator[\[Alpha]\[Alpha],{1,Length@ili},ImageSize\[Rule]{300,5}],$startMonitoring
];
Print["Calculated ",Christoffelcd[{ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]3\[RightDoubleBracket],curved} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
(*\[CapitalGamma]UUD*)
ili=Table[Level[Keys@TensorValues[Christoffelcd]\[LeftDoubleBracket]-1\[RightDoubleBracket]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],1]//Flatten//DeleteCases[-curved]//DeleteCases[curved],{\[Alpha]\[Alpha],1,Length@Keys@TensorValues[Christoffelcd]\[LeftDoubleBracket]-1\[RightDoubleBracket]}];
Monitor[
Do[ComponentValue[
Christoffelcd[{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket],-curved}],
ToValues@(TraceBasisDummy@ToBasis[curved]@(gg[ind\[LeftDoubleBracket]2\[RightDoubleBracket],ind\[LeftDoubleBracket]-2\[RightDoubleBracket]]Christoffelcd[ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]-2\[RightDoubleBracket],-ind\[LeftDoubleBracket]3\[RightDoubleBracket]])/.
{ind\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket]\[Rule]ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],ind\[LeftDoubleBracket]3\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket]}
)
],{\[Alpha]\[Alpha],1,Length@ili}
],ProgressIndicator[\[Alpha]\[Alpha],{1,Length@ili},ImageSize\[Rule]{300,5}],$startMonitoring
];
Print["Calculated ",Christoffelcd[{ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]3\[RightDoubleBracket],curved} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
(*\[CapitalGamma]UDU*)
ili=Table[Level[Keys@TensorValues[Christoffelcd]\[LeftDoubleBracket]-1\[RightDoubleBracket]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],1]//Flatten//DeleteCases[-curved]//DeleteCases[curved],{\[Alpha]\[Alpha],1,Length@Keys@TensorValues[Christoffelcd]\[LeftDoubleBracket]-1\[RightDoubleBracket]}];
Monitor[
Do[ComponentValue[
Christoffelcd[{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket],curved}],
ToValues@(TraceBasisDummy@ToBasis[curved]@(gg[ind\[LeftDoubleBracket]3\[RightDoubleBracket],ind\[LeftDoubleBracket]-3\[RightDoubleBracket]]Christoffelcd[ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket],-ind\[LeftDoubleBracket]-3\[RightDoubleBracket]])/.
{ind\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],ind\[LeftDoubleBracket]3\[RightDoubleBracket]\[Rule]ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket]}
)
],{\[Alpha]\[Alpha],1,Length@ili}
],ProgressIndicator[\[Alpha]\[Alpha],{1,Length@ili},ImageSize\[Rule]{300,5}],$startMonitoring
];
Print["Calculated ",Christoffelcd[{ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved},{ind\[LeftDoubleBracket]3\[RightDoubleBracket],curved} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];,
(*AllQ = False*)
at=AbsoluteTime[];
ComponentValue/@ComponentArray@ToBasis[curved]@Christoffelcd[-ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket],-ind\[LeftDoubleBracket]3\[RightDoubleBracket]]//Flatten;
ComponentValue/@ComponentArray@ToBasis[curved]@Christoffelcd[ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket],-ind\[LeftDoubleBracket]3\[RightDoubleBracket]]//Flatten;
(*\[CapitalGamma]DDD*)
ili=Table[Level[Keys@TensorValues[Christoffelcd]\[LeftDoubleBracket]-1\[RightDoubleBracket]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],1]//Flatten//DeleteCases[-curved]//DeleteCases[curved],{\[Alpha]\[Alpha],1,Length@Keys@TensorValues[Christoffelcd]\[LeftDoubleBracket]-1\[RightDoubleBracket]}];
Monitor[
Do[ComponentValue[
Christoffelcd[{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket],-curved}],
ToValues@(ToBasis[curved ]@ToBasis[curved ]@ChristoffelToGradMetric@Christoffelcd[-ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket],-ind\[LeftDoubleBracket]3\[RightDoubleBracket]]/.
{ind\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],ind\[LeftDoubleBracket]3\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket]}
)
],{\[Alpha]\[Alpha],1,Length@ili}
],ProgressIndicator[\[Alpha]\[Alpha],{1,Length@ili},ImageSize\[Rule]{300,5}],$startMonitoring
];
Print["Calculated ",Christoffelcd[-{ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]3\[RightDoubleBracket],curved} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
(*\[CapitalGamma]UDD*)
ili=Table[Level[Keys@TensorValues[Christoffelcd]\[LeftDoubleBracket]-1\[RightDoubleBracket]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],1]//Flatten//DeleteCases[-curved]//DeleteCases[curved],{\[Alpha]\[Alpha],1,Length@Keys@TensorValues[Christoffelcd]\[LeftDoubleBracket]-1\[RightDoubleBracket]}];
Monitor[
Do[ComponentValue[
Christoffelcd[{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket],-curved}],
ToValues@(TraceBasisDummy@ToBasis[curved]@(gg[ind\[LeftDoubleBracket]1\[RightDoubleBracket],ind\[LeftDoubleBracket]-1\[RightDoubleBracket]]Christoffelcd[-ind\[LeftDoubleBracket]-1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket],-ind\[LeftDoubleBracket]3\[RightDoubleBracket]])/.
{ind\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],ind\[LeftDoubleBracket]3\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket]}
)
],{\[Alpha]\[Alpha],1,Length@ili}
],ProgressIndicator[\[Alpha]\[Alpha],{1,Length@ili},ImageSize\[Rule]{300,5}],$startMonitoring
];
Print["Calculated ",Christoffelcd[{ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]3\[RightDoubleBracket],curved} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
];
(*Riemann*)
$CVSimplify=sR;
If[OptionValue[AllQ]==True,
at=AbsoluteTime[];
ComponentValue/@ComponentArray@ToBasis[curved]@Riemanncd[-ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket],-ind\[LeftDoubleBracket]3\[RightDoubleBracket],-ind\[LeftDoubleBracket]4\[RightDoubleBracket]]//Flatten;
ComponentValue/@ComponentArray@ToBasis[curved]@Riemanncd[ind\[LeftDoubleBracket]1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket],-ind\[LeftDoubleBracket]3\[RightDoubleBracket],-ind\[LeftDoubleBracket]4\[RightDoubleBracket]]//Flatten;
ComponentValue/@ComponentArray@ToBasis[curved]@Riemanncd[-ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket],ind\[LeftDoubleBracket]3\[RightDoubleBracket],ind\[LeftDoubleBracket]4\[RightDoubleBracket]]//Flatten;
ComponentValue/@ComponentArray@ToBasis[curved]@Riemanncd[ind\[LeftDoubleBracket]1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket],ind\[LeftDoubleBracket]3\[RightDoubleBracket],ind\[LeftDoubleBracket]4\[RightDoubleBracket]]//Flatten;
(*RDDDD*)
ili=Table[Level[Keys@TensorValues[Riemanncd]\[LeftDoubleBracket]-1\[RightDoubleBracket]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],1]//Flatten//DeleteCases[-curved]//DeleteCases[curved],{\[Alpha]\[Alpha],1,Length@Keys@TensorValues[Riemanncd]\[LeftDoubleBracket]-1\[RightDoubleBracket]}];
Monitor[
Do[ComponentValue[
Riemanncd[{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],4\[RightDoubleBracket],-curved}],
ToValues@(TraceBasisDummy@ContractMetric@ToBasis[curved ]@ToBasis[curved ]@RiemannToChristoffel@Riemanncd[-ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket],-ind\[LeftDoubleBracket]3\[RightDoubleBracket],-ind\[LeftDoubleBracket]4\[RightDoubleBracket]]/.
{ind\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],ind\[LeftDoubleBracket]3\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket],ind\[LeftDoubleBracket]4\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],4\[RightDoubleBracket]}
)
],{\[Alpha]\[Alpha],1,Length@ili}
],ProgressIndicator[\[Alpha]\[Alpha],{1,Length@ili},ImageSize\[Rule]{300,5}],$startMonitoring
];
Print["Calculated ",Riemanncd[-{ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]3\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]4\[RightDoubleBracket],curved}]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[]-at)," seconds"];
(*RUUDD*)
at=AbsoluteTime[];
ili=Table[Level[Keys@TensorValues[Riemanncd]\[LeftDoubleBracket]-1\[RightDoubleBracket]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],1]//Flatten//DeleteCases[-curved]//DeleteCases[curved],{\[Alpha]\[Alpha],1,Length@Keys@TensorValues[Riemanncd]\[LeftDoubleBracket]-1\[RightDoubleBracket]}];
Monitor[
Do[ComponentValue[
Riemanncd[{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],4\[RightDoubleBracket],-curved}],
ToValues@(TraceBasisDummy@ToBasis[curved]@(gg[ind\[LeftDoubleBracket]1\[RightDoubleBracket],ind\[LeftDoubleBracket]-1\[RightDoubleBracket]]gg[ind\[LeftDoubleBracket]2\[RightDoubleBracket],ind\[LeftDoubleBracket]-2\[RightDoubleBracket]]Riemanncd[-ind[[-1]],-ind[[-2]],-ind[[3]],-ind[[4]]])/.
{ind\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket]\[Rule]ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],ind\[LeftDoubleBracket]3\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket],ind\[LeftDoubleBracket]4\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],4\[RightDoubleBracket]}
)
],{\[Alpha]\[Alpha],1,Length@ili}
],ProgressIndicator[\[Alpha]\[Alpha],{1,Length@ili},ImageSize\[Rule]{300,5}],$startMonitoring
];
Print["Calculated ",Riemanncd[{ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]3\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]4\[RightDoubleBracket],curved}]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[]-at)," seconds"];
(*RDDUU*)
at=AbsoluteTime[];
ili=Table[Level[Keys@TensorValues[Riemanncd]\[LeftDoubleBracket]-1\[RightDoubleBracket]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],1]//Flatten//DeleteCases[-curved]//DeleteCases[curved],{\[Alpha]\[Alpha],1,Length@Keys@TensorValues[Riemanncd]\[LeftDoubleBracket]-1\[RightDoubleBracket]}];
Monitor[
Do[ComponentValue[
Riemanncd[{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket],curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],4\[RightDoubleBracket],curved}],
ToValues@(TraceBasisDummy@ToBasis[curved]@(gg[ind\[LeftDoubleBracket]3\[RightDoubleBracket],ind\[LeftDoubleBracket]-3\[RightDoubleBracket]]gg[ind\[LeftDoubleBracket]4\[RightDoubleBracket],ind\[LeftDoubleBracket]-4\[RightDoubleBracket]]Riemanncd[-ind[[1]],-ind[[2]],-ind[[-3]],-ind[[-4]]])/.
{ind\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],ind\[LeftDoubleBracket]3\[RightDoubleBracket]\[Rule]ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket],ind\[LeftDoubleBracket]4\[RightDoubleBracket]\[Rule]ili\[LeftDoubleBracket]\[Alpha]\[Alpha],4\[RightDoubleBracket]}
)
],{\[Alpha]\[Alpha],1,Length@ili}
],ProgressIndicator[\[Alpha]\[Alpha],{1,Length@ili},ImageSize\[Rule]{300,5}],$startMonitoring
];
Print["Calculated ",Riemanncd[-{ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved},{ind\[LeftDoubleBracket]3\[RightDoubleBracket],curved},{ind\[LeftDoubleBracket]4\[RightDoubleBracket],curved}]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[]-at)," seconds"];
(*RUUUU*)
at=AbsoluteTime[];
ili=Table[Level[Keys@TensorValues[Riemanncd]\[LeftDoubleBracket]-1\[RightDoubleBracket]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],1]//Flatten//DeleteCases[-curved]//DeleteCases[curved],{\[Alpha]\[Alpha],1,Length@Keys@TensorValues[Riemanncd]\[LeftDoubleBracket]-1\[RightDoubleBracket]}];
Monitor[
Do[ComponentValue[
Riemanncd[{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket],curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],4\[RightDoubleBracket],curved}],
ToValues@(TraceBasisDummy@ToBasis[curved]@(gg[ind\[LeftDoubleBracket]3\[RightDoubleBracket],ind\[LeftDoubleBracket]-3\[RightDoubleBracket]]gg[ind\[LeftDoubleBracket]4\[RightDoubleBracket],ind\[LeftDoubleBracket]-4\[RightDoubleBracket]]Riemanncd[ind[[1]],ind[[2]],-ind[[-3]],-ind[[-4]]])/.
{ind\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket]\[Rule]ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],ind\[LeftDoubleBracket]3\[RightDoubleBracket]\[Rule]ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket],ind\[LeftDoubleBracket]4\[RightDoubleBracket]\[Rule]ili\[LeftDoubleBracket]\[Alpha]\[Alpha],4\[RightDoubleBracket]}
)
],{\[Alpha]\[Alpha],1,Length@ili}
],ProgressIndicator[\[Alpha]\[Alpha],{1,Length@ili},ImageSize\[Rule]{300,5}],$startMonitoring
];
Print["Calculated ",Riemanncd[{ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved},{ind\[LeftDoubleBracket]3\[RightDoubleBracket],curved},{ind\[LeftDoubleBracket]4\[RightDoubleBracket],curved}]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[]-at)," seconds"];,
at=AbsoluteTime[];
ComponentValue/@ComponentArray@ToBasis[curved]@Riemanncd[-ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket],-ind\[LeftDoubleBracket]3\[RightDoubleBracket],-ind\[LeftDoubleBracket]4\[RightDoubleBracket]]//Flatten;
(*RDDDD*)
ili=Table[Level[Keys@TensorValues[Riemanncd]\[LeftDoubleBracket]-1\[RightDoubleBracket]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],1]//Flatten//DeleteCases[-curved]//DeleteCases[curved],{\[Alpha]\[Alpha],1,Length@Keys@TensorValues[Riemanncd]\[LeftDoubleBracket]-1\[RightDoubleBracket]}];
Monitor[
Do[ComponentValue[
Riemanncd[{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],4\[RightDoubleBracket],-curved}],
ToValues@(TraceBasisDummy@ContractMetric@ToBasis[curved ]@ToBasis[curved ]@RiemannToChristoffel@Riemanncd[-ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket],-ind\[LeftDoubleBracket]3\[RightDoubleBracket],-ind\[LeftDoubleBracket]4\[RightDoubleBracket]]/.
{ind\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],ind\[LeftDoubleBracket]3\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],3\[RightDoubleBracket],ind\[LeftDoubleBracket]4\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],4\[RightDoubleBracket]}
)
],{\[Alpha]\[Alpha],1,Length@ili}
],ProgressIndicator[\[Alpha]\[Alpha],{1,Length@ili},ImageSize\[Rule]{300,5}],$startMonitoring
];
Print["Calculated ",Riemanncd[-{ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]3\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]4\[RightDoubleBracket],curved}]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[]-at)," seconds"];
];
(*Ricci tensor*)
If[OptionValue[AllQ]==True,
at=AbsoluteTime[];
ComponentValue/@ComponentArray@ToBasis[curved]@Riccicd[-ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket]]//Flatten;
ComponentValue/@ComponentArray@ToBasis[curved]@Riccicd[ind\[LeftDoubleBracket]1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket]]//Flatten;
(*RDD*)
ili=Table[Level[Keys@TensorValues[Riccicd]\[LeftDoubleBracket]-1\[RightDoubleBracket]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],1]//Flatten//DeleteCases[-curved]//DeleteCases[curved],{\[Alpha]\[Alpha],1,Length@Keys@TensorValues[Riccicd]\[LeftDoubleBracket]-1\[RightDoubleBracket]}];
Monitor[
Do[ComponentValue[
Riccicd[{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],-curved}],
ToValues@(TraceBasisDummy@ContractMetric@ToBasis[curved ]@ToBasis[curved ]@RiemannToChristoffel@Riccicd[-ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket]]/.
{ind\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket]}
)
],{\[Alpha]\[Alpha],1,Length@ili}
],ProgressIndicator[\[Alpha]\[Alpha],{1,Length@ili},ImageSize\[Rule]{300,5}],$startMonitoring
];
Print["Calculated ",Riccicd[-{ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved}]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[]-at)," seconds"];
(*RUU*)
at=AbsoluteTime[];
ili=Table[Level[Keys@TensorValues[Riccicd]\[LeftDoubleBracket]-1\[RightDoubleBracket]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],1]//Flatten//DeleteCases[-curved]//DeleteCases[curved],{\[Alpha]\[Alpha],1,Length@Keys@TensorValues[Riccicd]\[LeftDoubleBracket]-1\[RightDoubleBracket]}];
Monitor[
Do[ComponentValue[
Riccicd[{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],curved}],
ToValues@(TraceBasisDummy@ToBasis[curved]@(gg[ind\[LeftDoubleBracket]1\[RightDoubleBracket],ind\[LeftDoubleBracket]-1\[RightDoubleBracket]]gg[ind\[LeftDoubleBracket]2\[RightDoubleBracket],ind\[LeftDoubleBracket]-2\[RightDoubleBracket]]Riccicd[-ind[[-1]],-ind[[-2]]])/.
{ind\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket]\[Rule]ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket]}
)
],{\[Alpha]\[Alpha],1,Length@ili}
],ProgressIndicator[\[Alpha]\[Alpha],{1,Length@ili},ImageSize\[Rule]{300,5}],$startMonitoring
];
Print["Calculated ",Riccicd[{ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved}]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[]-at)," seconds"];,
at=AbsoluteTime[];
ComponentValue/@ComponentArray@ToBasis[curved]@Riccicd[-ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket]]//Flatten;
(*RDD*)
ili=Table[Level[Keys@TensorValues[Riccicd]\[LeftDoubleBracket]-1\[RightDoubleBracket]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],1]//Flatten//DeleteCases[-curved]//DeleteCases[curved],{\[Alpha]\[Alpha],1,Length@Keys@TensorValues[Riccicd]\[LeftDoubleBracket]-1\[RightDoubleBracket]}];
Monitor[
Do[ComponentValue[
Riccicd[{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],-curved},{ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket],-curved}],
ToValues@(TraceBasisDummy@ContractMetric@ToBasis[curved ]@ToBasis[curved ]@RiemannToChristoffel@Riccicd[-ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket]]/.
{ind\[LeftDoubleBracket]1\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket]\[Rule]-ili\[LeftDoubleBracket]\[Alpha]\[Alpha],2\[RightDoubleBracket]}
)
],{\[Alpha]\[Alpha],1,Length@ili}
],ProgressIndicator[\[Alpha]\[Alpha],{1,Length@ili},ImageSize\[Rule]{300,5}],$startMonitoring
];
Print["Calculated ",Riccicd[-{ind\[LeftDoubleBracket]1\[RightDoubleBracket],curved},-{ind\[LeftDoubleBracket]2\[RightDoubleBracket],curved}]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[]-at)," seconds"];
];
(*Ricci scalar*)
at=AbsoluteTime[ ];
R=Tr[CTensor[gg[ind\[LeftDoubleBracket]1\[RightDoubleBracket],ind\[LeftDoubleBracket]2\[RightDoubleBracket]]]\[LeftDoubleBracket]0,1\[RightDoubleBracket].CTensor[Riccicd[-ind\[LeftDoubleBracket]1\[RightDoubleBracket],-ind\[LeftDoubleBracket]2\[RightDoubleBracket]]]\[LeftDoubleBracket]0,1\[RightDoubleBracket]];
If[sR==FullSimplify,
tmp=RicciScalarcd[]\[Rule]R//FullSimplify;
Print["Calculated ",RicciScalarcd[ ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ]; ];
If[sR==Simplify,
tmp=RicciScalarcd[]\[Rule]R//Simplify;
Print["Calculated ",RicciScalarcd[ ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ]; ];
If[sR==Identity,
at=AbsoluteTime[ ];
tmp=RicciScalarcd[]\[Rule]R;
Print["Calculated ",RicciScalarcd[ ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ]; ];
If[sR==Together,
at=AbsoluteTime[ ];
tmp=RicciScalarcd[]\[Rule]R//Together;
Print["Calculated ",RicciScalarcd[ ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ]; ];
(*Storing TVals*)
$CVSimplify=Simplify;
$olution[$metric,$curved,$tensor,$value]=TensorValues[Evaluate@gg];
$olution[$metric,$curved,$epsilon,$value]=TensorValues[Evaluate@epsilongg];
$olution[$metric,$curved,$christoffel,$value]=TensorValues[Evaluate@Christoffelcd];
$olution[$metric,$curved,$riemann,$value]=TensorValues[Evaluate@Riemanncd];
$olution[$metric,$curved,$ricci,$value]=TensorValues[Evaluate@Riccicd];
$olution[$metric,$curved,$ricciScalar,$value]=tmp;
Print["Stored the calculated tensor values in the appropriate slots in ", FB@"$olution"];
Print["Current context: ",FS@System`$Context]])*)


(* ::Input::Initialization:: *)
Options[CalculateFormTensor ]={SimplificationMethod->ConstantArray[Simplify,Length@GetValues[$form,$tensor,$ymbol ] ]};
CalculateFormTensor[OptionsPattern[ ] ]:=(Set[$Context,$olution[$info,$context ]];
Module[{man=$manifold,
c=Values@$olution[$coordinate ],
dim=$olution[$manifold,$dimension ],
curved=$olution[$basis,$curved,$ymbol ],
gs=$olution[$metric,$curved,$tensor,$ymbol ],
ind=GetIndicesOfVBundle[TangentBundleOfManifold[$olution[$manifold,$ymbol ] ],Length@$olution[$basis,$curved,$index ] ],
ftl=Length@GetValues[$form,$tensor,$ymbol ],
fts=GetValues[$form,$tensor,$ymbol ],
ftp=GetValues[$form,$tensor,$print ],
ftr=GetValues[$form,$tensor,$rank ],
fte=GetValues[$form,$tensor,$value ],
ftk=GetKeys[$form,$tensorQ->True ],
cts=OptionValue[SimplificationMethod ],
at,AD,AU,FDD,FDU,FUU,FUD,
gb="Global`",ct=$olution[$info,$context ]},
Do[
If[ftr[[\[Alpha]\[Alpha]]]==1,
(*AD*)
$CVSimplify=cts[[\[Alpha]\[Alpha]]];
at=AbsoluteTime[ ];
AD=GenFormTensorTable[ftk[[\[Alpha]\[Alpha]]] ];
Monitor[Do[ComponentValue[fts[[\[Alpha]\[Alpha]]][{ii,-curved} ],AD[[ii+1]] ],{ii,0,dim-1} ],{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ]},$startMonitoring ];
Print["Calculated ",fts[[\[Alpha]\[Alpha]]][-{ind[[1]],curved} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
(*AU*)
at=AbsoluteTime[];
AU=TraceBasisDummy@ToBasis[curved]@(fts[[\[Alpha]\[Alpha]]][-ind[[-1]]]gs[ind[[-1]],ind[[1]]]);
Monitor[
Do[ComponentValue[fts[[\[Alpha]\[Alpha]]][{ii,curved}],ToValues@(AU/.ind[[1]]->ii)],{ii,0,dim-1}],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5}]},$startMonitoring];
Print["Calculated ",fts[[\[Alpha]\[Alpha]]][{ind[[1]],curved}]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[]-at)," seconds" ];
$CVSimplify=Simplify; ];
If[ftr[[\[Alpha]\[Alpha]]]==2,
(*FDD*)
$CVSimplify=cts[[\[Alpha]\[Alpha]]];
at=AbsoluteTime[ ];
(*ComponentValue/@(Table[fts\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket][{ii,-curved},{jj,-curved} ],{ii,0,dim-1},{jj,0,ii} ]//Flatten);*)
Monitor[Do[ComponentValue[fts[[\[Alpha]\[Alpha]]][{ii,-curved},{jj,-curved} ] ],{ii,0,dim-1},{jj,0,ii} ],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@jj,Dynamic/@{0,ii},ImageSize->{Automatic,5} ]},$startMonitoring ];
FDD=GenFormTensorTable[ftk[[\[Alpha]\[Alpha]]] ];
Monitor[Do[ComponentValue[fts[[\[Alpha]\[Alpha]]][{ii,-curved},{jj,-curved} ],FDD[[ii+1,jj+1]] ],{ii,0,dim-2},{jj,ii+1,dim-1} ],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-2},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@jj,Dynamic/@{ii+1,dim-1},ImageSize->{Automatic,5} ]},$startMonitoring ];
Print["Calculated ",fts[[\[Alpha]\[Alpha]]][ -{ind[[1]],curved},-{ind[[2]],curved} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
(*FDU*)
at=AbsoluteTime[ ];
(*ComponentValue/@(Table[fts\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket][{ii,-curved},{jj,curved} ],{ii,0,dim-1},{jj,0,ii} ]//Flatten);*)
Monitor[Do[ComponentValue[fts[[\[Alpha]\[Alpha]]][{ii,-curved},{jj,curved} ] ],{ii,0,dim-1},{jj,0,ii} ],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@jj,Dynamic/@{0,ii},ImageSize->{Automatic,5} ]},$startMonitoring ];
FDU=TraceBasisDummy@ToBasis[curved ]@ToBasis[curved ]@(fts[[\[Alpha]\[Alpha]]][-ind[[1]],-ind[[-1]] ] gs[ind[[-1]],ind[[2]] ]);
Monitor[Do[ComponentValue[fts[[\[Alpha]\[Alpha]]][{ii,-curved},{jj,curved} ],ToValues@(FDU/.{ind[[1]]->-ii,ind[[2]]->jj}) ],{ii,0,dim-2},{jj,ii+1,dim-1} ],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-2},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@jj,Dynamic/@{ii+1,dim-1},ImageSize->{Automatic,5} ]},$startMonitoring ];
FUD=TraceBasisDummy@ToBasis[curved ]@ToBasis[curved ]@(gs[ind[[1]],ind[[-1]] ]fts[[\[Alpha]\[Alpha]]][-ind[[-1]],-ind[[2]] ]);
Monitor[Do[ComponentValue[fts[[\[Alpha]\[Alpha]]][{ii,curved},{jj,-curved} ],ToValues@(FUD/.{ind[[1]]->ii,ind[[2]]->-jj}) ],{ii,0,dim-1},{jj,ii,dim-1} ],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@jj,Dynamic/@{ii,dim-1},ImageSize->{Automatic,5} ]},$startMonitoring ];
Print["Calculated ",fts[[\[Alpha]\[Alpha]]][ -{ind[[1]],curved},{ind[[2]],curved} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
(*FUD*)
at=AbsoluteTime[ ];
Monitor[Do[ComponentValue[fts[[\[Alpha]\[Alpha]]][{ii,curved},{jj,-curved} ] ],{ii,1,dim-1},{jj,0,ii-1} ],
{ProgressIndicator[Dynamic@ii,Dynamic/@{1,dim-1},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@jj,Dynamic/@{0,ii-1},ImageSize->{Automatic,5} ]},$startMonitoring ];
(*ComponentValue/@(Table[fts\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket][{ii,curved},{jj,-curved} ],{ii,1,dim-1},{jj,0,ii-1} ]//Flatten);*)
FUD=TraceBasisDummy@ToBasis[curved ]@ToBasis[curved ]@(gs[ind[[1]],ind[[-1]] ]fts[[\[Alpha]\[Alpha]]][-ind[[-1]],-ind[[2]] ]);
Monitor[Do[ComponentValue[fts[[\[Alpha]\[Alpha]]][{ii,curved},{jj,-curved} ],ToValues@(FUD/.{ind[[1]]->ii,ind[[2]]->-jj}) ],{ii,0,dim-1},{jj,ii,dim-1} ],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@jj,Dynamic/@{ii,dim-1},ImageSize->{Automatic,5} ]},$startMonitoring ];
Print["Calculated ",fts[[\[Alpha]\[Alpha]]][{ind[[1]],curved},-{ind[[2]],curved} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
(*FUU*)
at=AbsoluteTime[ ];
(*ComponentValue/@(Table[fts\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket][{ii,curved},{jj,curved} ],{ii,0,dim-1},{jj,0,ii} ]//Flatten);*)
Monitor[Do[ComponentValue[fts[[\[Alpha]\[Alpha]]][{ii,curved},{jj,curved} ] ],{ii,0,dim-1},{jj,0,ii} ],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@jj,Dynamic/@{0,ii},ImageSize->{Automatic,5} ]},$startMonitoring ];
FUU=TraceBasisDummy@ToBasis[curved ]@ToBasis[curved ]@(gs[ind[[1]],ind[[-1]] ]fts[[\[Alpha]\[Alpha]]][-ind[[-1]],ind[[2]] ]);
Monitor[Do[ComponentValue[fts[[\[Alpha]\[Alpha]]][{ii,curved},{jj,curved} ],ToValues@(FUU/.{ind[[1]]->ii,ind[[2]]->jj}) ],{ii,0,dim-2},{jj,ii+1,dim-1} ],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-2},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@jj,Dynamic/@{ii+1,dim-1},ImageSize->{Automatic,5} ]},$startMonitoring ];
Print["Calculated ",fts[[\[Alpha]\[Alpha]]][{ind[[1]],curved},{ind[[2]],curved} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
$CVSimplify=Simplify; ];
If[ftr[[\[Alpha]\[Alpha]]]==3,Print["Antisymmetric tensors of rank 3 are still in construction | Nothing was calculated" ]; ];
If[ftr[[\[Alpha]\[Alpha]]]==4,Print["Antisymmetric tensors of rank 4 are still in construction | Nothing was calculated" ]; ];
If[ftr[[\[Alpha]\[Alpha]]]==5,Print["Antisymmetric tensors of rank 5 are still in construction | Nothing was calculated" ]; ];
,{\[Alpha]\[Alpha],1,ftl} ];
(*Storing TVals*)
Do[$olution[$form,ftk[[\[Alpha]\[Alpha]]],$tensor,$value ]=TensorValues[Evaluate@fts[[\[Alpha]\[Alpha]]] ];,{\[Alpha]\[Alpha],1,ftl} ];
Print["Stored the calculated tensor values in the appropriate slots in ", FB@"$olution" ];
Print["Current context: ", FS@System`$Context ] ])


(* ::Input::Initialization:: *)
Options[CalculateFrame ]={SimplificationMethod->{Simplify,Simplify}};
CalculateFrame[OptionsPattern[ ] ]:=(Set[$Context,$olution[$info,$context ] ];
Module[{
eta=$olution[$metric,$flat,$tensor,$ymbol ],
gg=$olution[$metric,$curved,$tensor,$ymbol ],
flat=$olution[$basis,$flat,$ymbol ],
curved=$olution[$basis,$curved,$ymbol ],
fi=GetIndicesOfVBundle[Symbol@@{"Frame"<>ToString[$olution[$manifold,$ymbol ] ]},Length@$olution[$basis,$flat,$index ] ],
ci=GetIndicesOfVBundle[TangentBundleOfManifold[$olution[$manifold,$ymbol ] ],Length@$olution[$basis,$curved,$index ] ],
ee=$olution[$frame,$vielbein,$ymbol ],
\[Omega]=$olution[$frame,$spinConnection,$ymbol ],
c=Values@$olution[$coordinate ],
dim=$olution[$manifold,$dimension ],
See=OptionValue[SimplificationMethod ][[1]],S\[Omega]=OptionValue[SimplificationMethod ][[2]],
at,tmp},
(*\[Eta]*)
at=AbsoluteTime[ ];
MetricInBasis[eta,-flat,GenFlatMetricMatrix[ ] ];
Print["Calculated ",eta[-{fi[[1]],flat},-{fi[[2]],flat} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
at=AbsoluteTime[ ];
MetricInBasis[eta,flat,Inverse@GenFlatMetricMatrix[ ] ];
Print["Calculated ",eta[{fi[[1]],flat},{fi[[2]],flat} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
(*ee*)
$CVSimplify=See;
at=AbsoluteTime[ ];
Monitor[Do[ComponentValue[ee[{ii,-curved},{jj,flat} ],GenVielbeinMatrix[ ][[ii+1,jj+1]] ],{ii,0,dim-1},{jj,0,dim-1} ],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@jj,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ]},$startMonitoring ];
(*AllComponentValues[ee[-{ci\[LeftDoubleBracket]1\[RightDoubleBracket],curved},{fi\[LeftDoubleBracket]1\[RightDoubleBracket],flat} ],GenVielbeinMatrix[ ] ];*)
Print["Calculated ",ee[-{ci[[1]],curved},{fi[[1]],flat} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
at=AbsoluteTime[ ];
tmp=TraceBasisDummy@ToBasis[flat ]@ToBasis[curved ]@(ee[-ci[[1]],fi[[-1]] ]eta[-fi[[-1]],-fi[[1]] ]);
Monitor[Do[ComponentValue[ee[{ii,-curved},{jj,-flat} ],ToValues@(tmp/.{ci[[1]]->-ii,fi[[1]]->-jj}) ],{ii,0,dim-1},{jj,0,dim-1} ],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@jj,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ]},$startMonitoring ];
(*AllComponentValues[ee[-{ci\[LeftDoubleBracket]1\[RightDoubleBracket],curved},-{fi\[LeftDoubleBracket]1\[RightDoubleBracket],flat} ],ToValues@TraceBasisDummy@ComponentArray@ToBasis[flat ]@ToBasis[curved ]@(ee[-ci\[LeftDoubleBracket]1\[RightDoubleBracket],fi\[LeftDoubleBracket]-1\[RightDoubleBracket] ]eta[-fi\[LeftDoubleBracket]-1\[RightDoubleBracket],-fi\[LeftDoubleBracket]1\[RightDoubleBracket] ]) ];*)
Print["Calculated ",ee[-{ci[[1]],curved},-{fi[[1]],flat} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
at=AbsoluteTime[ ];
Monitor[Do[ComponentValue[ee[{ii,curved},{jj,-flat} ],(Transpose@Inverse@GenVielbeinMatrix[ ])[[ii+1,jj+1]] ],{ii,0,dim-1},{jj,0,dim-1} ],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@jj,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ]},$startMonitoring ];
(*AllComponentValues[ee[{ci\[LeftDoubleBracket]1\[RightDoubleBracket],curved},-{fi\[LeftDoubleBracket]1\[RightDoubleBracket],flat} ],Transpose@Inverse@GenVielbeinMatrix[ ] ];*)
Print["Calculated ",ee[{ci[[1]],curved},-{fi[[1]],flat} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
at=AbsoluteTime[ ];
tmp=TraceBasisDummy@ToBasis[flat ]@ToBasis[curved ]@(ee[ci[[1]],-fi[[-1]] ]eta[fi[[-1]],fi[[1]] ]);
Monitor[Do[ComponentValue[ee[{ii,curved},{jj,flat} ],ToValues@(tmp/.{ci[[1]]->ii,fi[[1]]->jj}) ],{ii,0,dim-1},{jj,0,dim-1} ],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@jj,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ]},$startMonitoring ];
(*AllComponentValues[ee[{ci\[LeftDoubleBracket]1\[RightDoubleBracket],curved},{fi\[LeftDoubleBracket]1\[RightDoubleBracket],flat} ],ToValues@TraceBasisDummy@ComponentArray@ToBasis[flat ]@ToBasis[curved ]@(ee[ci\[LeftDoubleBracket]1\[RightDoubleBracket],-fi\[LeftDoubleBracket]-1\[RightDoubleBracket] ]eta[fi\[LeftDoubleBracket]-1\[RightDoubleBracket],fi\[LeftDoubleBracket]1\[RightDoubleBracket] ]) ];*)
Print["Calculated ",ee[{ci[[1]],curved},{fi[[1]],flat} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
$CVSimplify=Simplify;
(*\[Omega]*)
$CVSimplify=S\[Omega];
at=AbsoluteTime[ ];
Monitor[Do[ComponentValue[\[Omega][{ii,-curved},{jj,-flat},{kk,-flat}]],
{ii,0,dim-1},{jj,0,dim-1},{kk,0,jj}
],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@jj,Dynamic/@{0,dim-1},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@kk,Dynamic/@{0,jj},ImageSize->{Automatic,5}]
},$startMonitoring
];
tmp=ToValues@TraceBasisDummy@ToBasis[flat ]@ToBasis[flat ]@ToBasis[curved ]@ContractMetric[Expand@SpinConnectionToFrame[\[Omega][-ci[[1]],-fi[[1]],-fi[[2]] ],\[Omega]],gg ];
Monitor[Do[ComponentValue[\[Omega][{ii,-curved},{jj,-flat},{kk,-flat}],ToValues@(tmp/.{ci[[1]]->-ii,fi[[1]]->-jj,fi[[2]]->-kk})],
{ii,0,dim-1},{jj,0,dim-2},{kk,jj+1,dim-1}
],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@jj,Dynamic/@{0,dim-2},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@kk,Dynamic/@{jj+1,dim-1},ImageSize->{Automatic,5}]
},$startMonitoring
];
(*tmp=ToValues@TraceBasisDummy@ToBasis[flat ]@ToBasis[flat ]@ToBasis[curved ]@ContractMetric[Expand@SpinConnectionToFrame[\[Omega][-ci\[LeftDoubleBracket]1\[RightDoubleBracket],-fi\[LeftDoubleBracket]1\[RightDoubleBracket],-fi\[LeftDoubleBracket]2\[RightDoubleBracket] ],\[Omega]],gg ];
Do[ComponentValue[\[Omega][{ii,-curved},{jj,-flat},{kk,-flat} ],ToValues@(tmp/.{ci\[LeftDoubleBracket]1\[RightDoubleBracket]->-ii,fi\[LeftDoubleBracket]1\[RightDoubleBracket]->-jj,fi\[LeftDoubleBracket]2\[RightDoubleBracket]->-kk}) ],{ii,0,dim-1},{jj,0,dim-1},{kk,0,dim-1} ];*)
Print["Calculated ",\[Omega][-{ci[[1]],curved},-{fi[[1]],flat},-{fi[[2]],flat} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
$CVSimplify=Simplify;
(*Storing TVals*)
$olution[$metric,$flat,$tensor,$value ]=TensorValues[Evaluate@eta ];
$olution[$frame,$vielbein,$value ]=TensorValues[Evaluate@ee ];
$olution[$frame,$spinConnection,$value ]=TensorValues[Evaluate@\[Omega] ];
Print["Stored the calculated tensor values in the appropriate slots in ", FB@"$olution" ];
Print["Current context: ",FS@System`$Context ] ])


(* ::Input::Initialization:: *)
Options[CalculateGamma ]={SimplificationMethod->{Simplify,Simplify}};
CalculateGamma[OptionsPattern[ ] ]:=(Set[$Context,$olution[$info,$context ] ];
Module[{at,tmp,
Gammaeta1=GetValues[$gamma,$flat,$ymbol ][[1]],
Gammaeta2=GetValues[$gamma,$flat,$ymbol ][[2]],
Gammaeta3=GetValues[$gamma,$flat,$ymbol ][[3]],
Gammagg1=GetValues[$gamma,$curved,$ymbol ][[1]],
Gammagg2=GetValues[$gamma,$curved,$ymbol ][[2]],
Gammagg3=GetValues[$gamma,$curved,$ymbol ][[3]],
curved=$olution[$basis,$curved,$ymbol ],
flat=$olution[$basis,$flat,$ymbol ],
spin=$olution[$basis,$spin,$ymbol ],
eta=$olution[$metric,$flat,$tensor,$ymbol ],
ee=$olution[$frame,$vielbein,$ymbol ],
Frameman=Symbol@@{"Frame"<>ToString[$olution[$manifold,$ymbol ] ]},
Spinman=Symbol@@{"Spin"<>ToString[$olution[$manifold,$ymbol ] ]},
ci=GetIndicesOfVBundle[TangentBundleOfManifold[$olution[$manifold,$ymbol ] ],Length@$olution[$basis,$curved,$index ] ],
fi=GetIndicesOfVBundle[Symbol@@{"Frame"<>ToString[$olution[$manifold,$ymbol ] ]},Length@$olution[$basis,$flat,$index ] ],
si=GetIndicesOfVBundle[Symbol@@{"Spin"<>ToString[$olution[$manifold,$ymbol ] ]},Length@$olution[$basis,$spin,$index ] ],
S\[CapitalGamma]\[Eta]=OptionValue[SimplificationMethod ][[1]],S\[CapitalGamma]g=OptionValue[SimplificationMethod ][[2]],
flatGammaU=Values@$olution[$gamma,$flatGammaU ],
dim=$olution[$manifold,$dimension ]},
(*\[CapitalGamma]\[Eta]*)
$CVSimplify=S\[CapitalGamma]\[Eta];
at=AbsoluteTime[ ];
Monitor[Do[ComponentValue[Gammaeta1[{ii,flat},{II,-spin},{JJ,spin} ],flatGammaU[[ii+1,II,JJ]] ],{ii,0,dim-1},{II,1,DimOfVBundle[Spinman ]},{JJ,1,DimOfVBundle[Spinman ]} ],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@II,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@JJ,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ]},$startMonitoring  ];
Print["Calculated ",Gammaeta1[{fi[[1]],flat},-{si[[1]],spin},{si[[2]],spin} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
at=AbsoluteTime[ ];
tmp=TraceBasisDummy@ToBasis[spin ]@ToBasis[flat ]@(eta[-fi[[1]],-fi[[-1]] ]Gammaeta1[fi[[-1]],-si[[1]],si[[2]] ]);
Monitor[Do[ComponentValue[Gammaeta1[{ii,-flat},{II,-spin},{JJ,spin} ],ToValues@(tmp/.{fi[[1]]->-ii,si[[1]]->-II,si[[2]]->JJ}) ],{ii,0,dim-1},{II,1,DimOfVBundle[Spinman ]},{JJ,1,DimOfVBundle[Spinman ]} ],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@II,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@JJ,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ]},$startMonitoring  ];
Print["Calculated ",Gammaeta1[-{fi[[1]],flat},-{si[[1]],spin},{si[[2]],spin} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
at=AbsoluteTime[ ];
Monitor[Do[ComponentValue[Gammaeta2[{ii,flat},{jj,flat},{II,-spin},{JJ,spin}]],
{ii,0,dim-1},{jj,0,ii},{II,1,DimOfVBundle[Spinman]},{JJ,1,DimOfVBundle[Spinman]}
],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@jj,Dynamic/@{0,ii},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@II,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@JJ,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ]
},$startMonitoring
];
tmp=TraceBasisDummy@ToBasis[spin ]@ToBasis[flat ]@(SplitGammaMatrix@ToBasis[spin ]@ToBasis[flat ]@Gammaeta2[fi[[1]],fi[[2]],-si[[1]],si[[2]] ]);
Monitor[Do[ComponentValue[Gammaeta2[{ii,flat},{jj,flat},{II,-spin},{JJ,spin}],ToValues@(tmp/.{fi[[1]]->ii,fi[[2]]->jj,si[[1]]->-II,si[[2]]->JJ})],
{ii,0,dim-2},{jj,ii+1,dim-1},{II,1,DimOfVBundle[Spinman]},{JJ,1,DimOfVBundle[Spinman]}
],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-2},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@jj,Dynamic/@{ii+1,dim-1},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@II,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@JJ,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ]
},$startMonitoring
];
(*tmp=TraceBasisDummy@ToBasis[spin ]@ToBasis[flat ]@(SplitGammaMatrix@ToBasis[spin ]@ToBasis[flat ]@Gammaeta2[fi\[LeftDoubleBracket]1\[RightDoubleBracket],fi\[LeftDoubleBracket]2\[RightDoubleBracket],-si\[LeftDoubleBracket]1\[RightDoubleBracket],si\[LeftDoubleBracket]2\[RightDoubleBracket] ]);
Do[ComponentValue[Gammaeta2[{ii,flat},{jj,flat},{II,-spin},{JJ,spin} ],ToValues@(tmp/.{fi\[LeftDoubleBracket]1\[RightDoubleBracket]->ii,fi\[LeftDoubleBracket]2\[RightDoubleBracket]->jj,si\[LeftDoubleBracket]1\[RightDoubleBracket]->-II,si\[LeftDoubleBracket]2\[RightDoubleBracket]->JJ}) ],
{ii,0,dim-1},{jj,0,dim-1},{II,1,DimOfVBundle[Spinman ]},{JJ,1,DimOfVBundle[Spinman ]} ];*)
Print["Calculated ",Gammaeta2[{fi[[1]],flat},{fi[[2]],flat},-{si[[1]],spin},{si[[2]],spin} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
at=AbsoluteTime[ ];
Monitor[Do[ComponentValue[Gammaeta3[{ii,flat},{jj,flat},{kk,flat},{II,-spin},{JJ,spin}]],
{ii,0,dim-1},{jj,0,dim-1},{kk,0,jj},{II,1,DimOfVBundle[Spinman]},{JJ,1,DimOfVBundle[Spinman]}
],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@jj,Dynamic/@{0,dim-1},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@kk,Dynamic/@{0,jj},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@II,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@JJ,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ]
},$startMonitoring
];
Monitor[Do[ComponentValue[Gammaeta3[{ii,flat},{jj,flat},{kk,flat},{II,-spin},{JJ,spin}]],
{ii,0,dim-2},{jj,0,ii},{kk,jj+1,dim-1},{II,1,DimOfVBundle[Spinman]},{JJ,1,DimOfVBundle[Spinman]}
],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-2},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@jj,Dynamic/@{0,ii},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@kk,Dynamic/@{jj+1,dim-1},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@II,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@JJ,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ]
},$startMonitoring
];
Monitor[Do[ComponentValue[Gammaeta3[{dim-1,flat},{jj,flat},{kk,flat},{II,-spin},{JJ,spin}]],
{jj,0,dim-2},{kk,jj+1,dim-1},{II,1,DimOfVBundle[Spinman]},{JJ,1,DimOfVBundle[Spinman]}
],
{ProgressIndicator[Dynamic@jj,Dynamic/@{0,dim-2},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@kk,Dynamic/@{jj+1,dim-1},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@II,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@JJ,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ]
},$startMonitoring
];
tmp=TraceBasisDummy@ToBasis[spin ]@ToBasis[flat ]@(SplitGammaMatrix@ToBasis[spin ]@ToBasis[flat ]@Gammaeta3[fi[[1]],fi[[2]],fi[[3]],-si[[1]],si[[2]] ]);
Monitor[Do[ComponentValue[Gammaeta3[{ii,flat},{jj,flat},{kk,flat},{II,-spin},{JJ,spin}],ToValues@(tmp/.{fi[[1]]->ii,fi[[2]]->jj,fi[[3]]->kk,si[[1]]->-II,si[[2]]->JJ})],
{ii,0,dim-3},{jj,ii+1,dim-2},{kk,jj+1,dim-1},{II,1,DimOfVBundle[Spinman]},{JJ,1,DimOfVBundle[Spinman]}
],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-3},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@jj,Dynamic/@{ii+1,dim-2},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@kk,Dynamic/@{jj+1,dim-1},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@II,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@JJ,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ]
},$startMonitoring
];
(*tmp=TraceBasisDummy@ToBasis[spin ]@ToBasis[flat ]@(SplitGammaMatrix@ToBasis[spin ]@ToBasis[flat ]@Gammaeta3[fi\[LeftDoubleBracket]1\[RightDoubleBracket],fi\[LeftDoubleBracket]2\[RightDoubleBracket],fi\[LeftDoubleBracket]3\[RightDoubleBracket],-si\[LeftDoubleBracket]1\[RightDoubleBracket],si\[LeftDoubleBracket]2\[RightDoubleBracket] ]);
Do[ComponentValue[Gammaeta3[{ii,flat},{jj,flat},{kk,flat},{II,-spin},{JJ,spin} ],ToValues@(tmp/.{fi\[LeftDoubleBracket]1\[RightDoubleBracket]->ii,fi\[LeftDoubleBracket]2\[RightDoubleBracket]->jj,fi\[LeftDoubleBracket]3\[RightDoubleBracket]->kk,si\[LeftDoubleBracket]1\[RightDoubleBracket]->-II,si\[LeftDoubleBracket]2\[RightDoubleBracket]->JJ}) ],
{ii,0,dim-1},{jj,0,dim-1},{kk,0,dim-1},{II,1,DimOfVBundle[Spinman ]},{JJ,1,DimOfVBundle[Spinman ]} ];*)
Print["Calculated ",Gammaeta3[{fi[[1]],flat},{fi[[2]],flat},{fi[[3]],flat},-{si[[1]],spin},{si[[2]],spin} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
$CVSimplify=Simplify;
(*\[CapitalGamma]g*)
$CVSimplify=S\[CapitalGamma]g;
at=AbsoluteTime[ ];
tmp=TraceBasisDummy@ToBasis[curved ]@ToBasis[flat ]@ToBasis[spin ]@(ee[ci[[1]],-fi[[-1]] ]Gammaeta1[fi[[-1]],-si[[1]],si[[2]] ]);
Monitor[Do[ComponentValue[Gammagg1[{ii,curved},{II,-spin},{JJ,spin} ],ToValues@(tmp/.{ci[[1]]->ii,si[[1]]->-II,si[[2]]->JJ}) ],{ii,0,dim-1},{II,1,DimOfVBundle[Spinman ]},{JJ,1,DimOfVBundle[Spinman ]} ],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@II,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@JJ,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ]},$startMonitoring ];
Print["Calculated ",Gammagg1[{ci[[1]],curved},-{si[[1]],spin},{si[[2]],spin} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
at=AbsoluteTime[ ];
tmp=TraceBasisDummy@ToBasis[curved ]@ToBasis[flat ]@ToBasis[spin ]@(ee[-ci[[1]],-fi[[-1]] ]Gammaeta1[fi[[-1]],-si[[1]],si[[2]] ]);
Monitor[Do[ComponentValue[Gammagg1[{ii,-curved},{II,-spin},{JJ,spin} ],ToValues@(tmp/.{ci[[1]]->-ii,si[[1]]->-II,si[[2]]->JJ}) ],{ii,0,dim-1},{II,1,DimOfVBundle[Spinman ]},{JJ,1,DimOfVBundle[Spinman ]} ],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@II,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@JJ,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ]},$startMonitoring  ];
Print["Calculated ",Gammagg1[-{ci[[1]],curved},-{si[[1]],spin},{si[[2]],spin} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
at=AbsoluteTime[ ];
Monitor[Do[ComponentValue[Gammagg3[{ii,-curved},{jj,-curved},{kk,-curved},{II,-spin},{JJ,spin}]],
{ii,0,dim-1},{jj,0,dim-1},{kk,0,jj},{II,1,DimOfVBundle[Spinman]},{JJ,1,DimOfVBundle[Spinman]}
],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-1},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@jj,Dynamic/@{0,dim-1},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@kk,Dynamic/@{0,jj},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@II,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@JJ,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ]
},$startMonitoring
];
Monitor[Do[ComponentValue[Gammagg3[{ii,-curved},{jj,-curved},{kk,-curved},{II,-spin},{JJ,spin}]],
{ii,0,dim-2},{jj,0,ii},{kk,jj+1,dim-1},{II,1,DimOfVBundle[Spinman]},{JJ,1,DimOfVBundle[Spinman]}
],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-2},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@jj,Dynamic/@{0,ii},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@kk,Dynamic/@{jj+1,dim-1},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@II,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@JJ,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ]
},$startMonitoring
];
Monitor[Do[ComponentValue[Gammagg3[{dim-1,-curved},{jj,-curved},{kk,-curved},{II,-spin},{JJ,spin}]],
{jj,0,dim-2},{kk,jj+1,dim-1},{II,1,DimOfVBundle[Spinman]},{JJ,1,DimOfVBundle[Spinman]}
],
{ProgressIndicator[Dynamic@jj,Dynamic/@{0,dim-2},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@kk,Dynamic/@{jj+1,dim-1},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@II,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@JJ,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ]
},$startMonitoring
];
tmp=TraceBasisDummy@ToBasis[curved ]@ToBasis[flat ]@ToBasis[spin ]@(ee[-ci[[1]],-fi[[-1]] ]ee[-ci[[2]],-fi[[-2]] ]ee[-ci[[3]],-fi[[-3]] ]Gammaeta3[fi[[-1]],fi[[-2]],fi[[-3]],-si[[1]],si[[2]] ]);
Monitor[Do[ComponentValue[Gammagg3[{ii,-curved},{jj,-curved},{kk,-curved},{II,-spin},{JJ,spin}],ToValues@(tmp/.{ci[[1]]->-ii,ci[[2]]->-jj,ci[[3]]->-kk,si[[1]]->-II,si[[2]]->JJ})],
{ii,0,dim-3},{jj,ii+1,dim-2},{kk,jj+1,dim-1},{II,1,DimOfVBundle[Spinman]},{JJ,1,DimOfVBundle[Spinman]}
],
{ProgressIndicator[Dynamic@ii,Dynamic/@{0,dim-3},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@jj,Dynamic/@{ii+1,dim-2},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@kk,Dynamic/@{jj+1,dim-1},ImageSize->{Automatic,5}],
ProgressIndicator[Dynamic@II,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ],
ProgressIndicator[Dynamic@JJ,Dynamic/@{1,DimOfVBundle[Spinman ]},ImageSize->{Automatic,5} ]
},$startMonitoring
];
Print["Calculated ",Gammagg3[-{ci[[1]],curved},-{ci[[2]],curved},-{ci[[3]],curved},-{si[[1]],spin},{si[[2]],spin} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];
(*tmp=TraceBasisDummy@ToBasis[curved ]@ToBasis[flat ]@ToBasis[spin ]@(ee[-ci\[LeftDoubleBracket]1\[RightDoubleBracket],-fi\[LeftDoubleBracket]-1\[RightDoubleBracket] ]ee[ci\[LeftDoubleBracket]2\[RightDoubleBracket],-fi\[LeftDoubleBracket]-2\[RightDoubleBracket] ]ee[ci\[LeftDoubleBracket]3\[RightDoubleBracket],-fi\[LeftDoubleBracket]-3\[RightDoubleBracket] ]Gammaeta3[fi\[LeftDoubleBracket]-1\[RightDoubleBracket],fi\[LeftDoubleBracket]-2\[RightDoubleBracket],fi\[LeftDoubleBracket]-3\[RightDoubleBracket],-si\[LeftDoubleBracket]1\[RightDoubleBracket],si\[LeftDoubleBracket]2\[RightDoubleBracket] ]);
Do[ComponentValue[Gammagg3[{ii,-curved},{jj,curved},{kk,curved},{II,-spin},{JJ,spin} ],ToValues@(tmp/.{ci\[LeftDoubleBracket]1\[RightDoubleBracket]->-ii,ci\[LeftDoubleBracket]2\[RightDoubleBracket]->jj,ci\[LeftDoubleBracket]3\[RightDoubleBracket]->kk,si\[LeftDoubleBracket]1\[RightDoubleBracket]->-II,si\[LeftDoubleBracket]2\[RightDoubleBracket]->JJ}) ],
{ii,0,dim-1},{jj,0,dim-1},{kk,0,dim-1},{II,1,DimOfVBundle[Spinman ]},{JJ,1,DimOfVBundle[Spinman ]} ];
Print["Calculated ",Gammagg3[-{ci\[LeftDoubleBracket]1\[RightDoubleBracket],curved},{ci\[LeftDoubleBracket]2\[RightDoubleBracket],curved},{ci\[LeftDoubleBracket]3\[RightDoubleBracket],curved},-{si\[LeftDoubleBracket]1\[RightDoubleBracket],spin},{si\[LeftDoubleBracket]2\[RightDoubleBracket],spin} ]," using ",FB@$CVSimplify," in ",FB@(AbsoluteTime[ ]-at)," seconds" ];*)
$CVSimplify=Simplify;
(*Storing TVals*)
Do[$olution[$gamma,$flat,(Keys@$olution[$gamma,$flat ])[[\[Alpha]\[Alpha]]],$value ]=TensorValues[Evaluate@GetValues[$gamma,$flat,$ymbol ][[\[Alpha]\[Alpha]]] ],{\[Alpha]\[Alpha],1,Length@Keys[$olution[$gamma,$flat ] ]} ];
Do[$olution[$gamma,$curved,(Keys@$olution[$gamma,$curved ])[[\[Alpha]\[Alpha]]],$value ]=TensorValues[Evaluate@GetValues[$gamma,$curved,$ymbol ][[\[Alpha]\[Alpha]]] ],{\[Alpha]\[Alpha],1,Length@Keys[$olution[$gamma,$curved ] ]} ];
Print["Stored the calculated tensor values in the appropriate slots in ", FB@"$olution" ];
Print["Current context: ",FS@System`$Context ] ])


(* ::Input::Initialization:: *)
(*Options[SaveSolution ]={SolutionType->Initial};
SaveSolution[OptionsPattern[ ] ]:=(Set[$Context,"Global`" ];
Module[{sol,name,st=ToString[OptionValue[SolutionType ] ]<>"/",si,ct=$olution[$info,$context ],fullmat,mat,sortedmat,fullsortedmat},
Quiet[CreateDirectory[FileNameJoin[{Directory[],StringDrop[st,-1 ]}]]];
sol=$olution;
name=$olution[$info,$name ];
Put[sol,st<>name<>".m" ];
Print["File ",FS@(name<>".m"), " containing the current keys and values of the association ",FB@"$olution"," saved to folder ",FS@FileNameJoin[{Directory[ ],st}] ];
If[ct=="z`",Print["Congratulations, you are the author of the ",FS@(Length@singleContext),"-th solution in this package!" ]; ];
If[ct=="zz`",Print["CONGRATULATIONS! You are the author of the ",FS@(Length@singleContext+Length@doubleContext),"-th solution in this package!" ]; ];
If[ct=="zzz`",Print["CONGRATULATIONS! YOU are the author of the ",FS@(Length@singleContext+Length@doubleContext+Length@tripleContext),"-th SOLUTION IN THIS PACKAGE! | You have reached the limit of the function ",FB@"GenContext[]",", please ask the developers to extend it" ]; ];
si=Get["SolutionsInfo.m" ];
If[MemberQ[ToString/@(si[$name ]),$olution[$info,$name ] ]==False,
Do[si\[LeftDoubleBracket]ii\[RightDoubleBracket]=Append[si\[LeftDoubleBracket]ii\[RightDoubleBracket],(Values@$olution[$info ])\[LeftDoubleBracket]ii\[RightDoubleBracket] ],{ii,1,Length@si}],
si[$context ]=si[$context ]/.si[$context ]\[LeftDoubleBracket]Flatten@Position[si[$name ],name ]\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]:>$olution[$info,$context ];
si[$dimension ]=si[$dimension ]/.si[$dimension ]\[LeftDoubleBracket]Flatten@Position[si[$name ],name ]\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]:>$olution[$info,$dimension ];
si[$usyQ ]=si[$usyQ ]/.si[$usyQ ]\[LeftDoubleBracket]Flatten@Position[si[$name ],name ]\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]:>$olution[$info,$usyQ ];
si[$reference ]=si[$reference ]/.si[$reference ]\[LeftDoubleBracket]Flatten@Position[si[$name ],name ]\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]:>$olution[$info,$reference ];
si[$comment ]=si[$comment ]/.si[$comment ]\[LeftDoubleBracket]Flatten@Position[si[$name ],name ]\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket]:>$olution[$info,$comment ]; ];
fullmat=Transpose@Values@si;
mat=Rest@fullmat;
sortedmat=mat;
(*sortedmat=SortBy[mat,#\[LeftDoubleBracket]2\[RightDoubleBracket]& ];*)
fullsortedmat=Prepend[sortedmat,{FB@$name,FB@$context,FB@$dimension,FB@$usyQ,FB@$reference,FB@$comment} ];
si=<|
$name->(Transpose@fullsortedmat)\[LeftDoubleBracket]1\[RightDoubleBracket],
$context->(Transpose@fullsortedmat)\[LeftDoubleBracket]2\[RightDoubleBracket],
$dimension\[Rule](Transpose@fullsortedmat)\[LeftDoubleBracket]3\[RightDoubleBracket],
$usyQ->(Transpose@fullsortedmat)\[LeftDoubleBracket]4\[RightDoubleBracket],
$reference->(Transpose@fullsortedmat)\[LeftDoubleBracket]5\[RightDoubleBracket],
$comment->(Transpose@fullsortedmat)\[LeftDoubleBracket]6\[RightDoubleBracket]|>;
Put[si,"SolutionsInfo.m" ];
Set[$Context,ct];
Print["Current context: ",FS@System`$Context ] ])*)


(* ::Input::Initialization:: *)
(*DeleteSolution[solutionName_ ]:=Module[{sn=solutionName,si,pos},
If[FileExistsQ[FileNameJoin[{Directory[ ],"Initial",sn<>".m"} ] ]==True,DeleteFile[FileNameJoin[{Directory[ ],"Initial",sn<>".m"} ] ]; ];
If[FileExistsQ[FileNameJoin[{Directory[ ],"Raw",sn<>".m"} ] ]==True,DeleteFile[FileNameJoin[{Directory[ ],"Raw",sn<>".m"} ] ]; ];
If[FileExistsQ[FileNameJoin[{Directory[ ],"Final",sn<>".m"} ] ]==True,DeleteFile[FileNameJoin[{Directory[ ],"Final",sn<>".m"} ] ]; ];
si=Get["SolutionsInfo.m" ];
pos=Position[si[$name ],sn ];
si[$name ]=Delete[si[$name ],pos ];
si[$context ]=Delete[si[$context ],pos ];
si[$dimension ]=Delete[si[$dimension ],pos ];
si[$usyQ ]=Delete[si[$usyQ ],pos ];
si[$reference ]=Delete[si[$reference ],pos ];
si[$comment ]=Delete[si[$comment ],pos ];
Put[si,"SolutionsInfo.m" ]; ]*)


(* ::Input::Initialization:: *)
(*PrintSolutions[ ]:=Module[{si},
si=Get["SolutionsInfo.m" ];
Return[Grid[Transpose@Values@si,Frame\[Rule]All,Alignment\[Rule]Left]]
]*)


(* ::Input::Initialization:: *)
Options[GetSolution ]={SolutionType->Initial};
GetSolution[solutionName_,OptionsPattern[ ] ]:=Module[{sn=solutionName,st=OptionValue[SolutionType ]},
Return[Get[ToString[st ]<>"/"<>sn<>".m" ] ] ]


(* ::Input::Initialization:: *)
CleanSolution[ ]:=Module[{},
$olution=<|
$info-><|$name->Null,$context->Null,$usyQ->Null,$reference-><||>|>,
$coordinate-><||>,
$manifold-><|$ymbol->Null,$dimension->Null|>,
$basis-><|
$curved-><|$ymbol->Null,$color->Null,$index->{}|>,
$flat-><|$ymbol->Null,$color->Null,$index->{}|>,
$spin-><|$ymbol->Null,$color->Null,$index->{}|>,
$internal-><|$ymbol->Null,$color->Null,$index->{}|>|>,
$constant-><|$ymbol->{}|>,
$function-><|$ymbol->{}|>,
$scalar-><||>,
$assumption-><||>,
$form-><||>,
$rule-><||>,
$tensor-><||>,
$metric-><|
$curved-><|
$igndet->Null,$covd->Null,$ds2->Null,
$tensor-><|$ymbol->Null,$print->Null,$value->FoldedRule[{},{}]|>,
$epsilon-><|$ymbol->Null,$value->FoldedRule[{},{}]|>,
$christoffel-><|$ymbol->Null,$value->FoldedRule[{},{}]|>,
$riemann-><|$ymbol->Null,$value->FoldedRule[{},{}]|>,
$ricci-><|$ymbol->Null,$value->FoldedRule[{},{}]|>,
$ricciScalar-><|$ymbol->Null,$value->Null|>,
$det-><|$ymbol->Null,$value->Null|>|>,
$flat-><|$tensor-><|$ymbol->Null,$print->Null,$value->Null|>|>,
$internal-><|
$igndet->Null,$covd->Null,$ds2->Null,
$tensor-><|$ymbol->Null,$print->Null,$value->FoldedRule[{},{}]|>,
$epsilon-><|$ymbol->Null,$value->FoldedRule[{},{}]|>,
$christoffel-><|$ymbol->Null,$value->FoldedRule[{},{}]|>,
$riemann-><|$ymbol->Null,$value->FoldedRule[{},{}]|>,
$ricci-><|$ymbol->Null,$value->FoldedRule[{},{}]|>,
$ricciScalar-><|$ymbol->Null,$value->FoldedRule[{},{}]|>,
$det-><|$ymbol->Null,$value->Null|>|>|>,
$frame-><|
$form-><||>,
$vielbein-><|$ymbol->Null,$print->Null,$value->FoldedRule[{},{}]|>,
$spinConnection-><|$ymbol->Null,$print->Null,$value->FoldedRule[{},{}]|>|>,
$gamma-><|$flat-><||>,$curved-><||>,$internal-><||>|>,
$pinor-><||>|>;
System`$Assumptions=True;
Print["Set ",FB@"$solution"," to its default value (i.e. keys pointing to ",FB@Null,") | Set ",FB@"$Assumptions"," = ",FB@True ] ]


(* ::Input::Initialization:: *)
(*Options[LoadSolution ]={SolutionType\[Rule]Final,SetForSusyQ\[Rule]False};
LoadSolution[solutionName_,OptionsPattern[ ] ]:=(
If[TrueQ[OptionValue[SolutionType ]\[Equal]Initial ]==True,
$olution=Get["Initial/"<>solutionName<>".m" ];
Print["Assigned the ", FB@Initial," data of ",FS@solutionName," to ",FB@"$olution" ];
SetSolution[SetForSusyQ\[Rule]OptionValue[SetForSusyQ ],PrintContextQ->True ]; ];
If[TrueQ[OptionValue[SolutionType ]\[Equal]Raw ]==True,
$olution=Get["Initial/"<>solutionName<>".m" ];
Print["Assigned the ", FB@Initial," data of ",FS@solutionName," to ",FB@"$olution" ];
SetSolution[SetForSusyQ\[Rule]OptionValue[SetForSusyQ ],PrintContextQ->False ];
$olution=Get["Raw/"<>solutionName<>".m" ];
Print["Assigned the ", FB@Raw," data of ",FS@solutionName," to ",FB@"$olution" ];
Print["Current context: ",FS@System`$Context ]; ];
If[TrueQ[OptionValue[SolutionType ]\[Equal]Final ]==True,
$olution=Get["Initial/"<>solutionName<>".m" ];
Print["Assigned the ", FB@Initial," data of ",FS@solutionName," to ",FB@"$olution" ];
SetSolution[SetForSusyQ\[Rule]OptionValue[SetForSusyQ ],PrintContextQ->False ];
$olution=Get["Final/"<>solutionName<>".m" ];
Print["Assigned the ", FB@Final," data of ",FS@solutionName," to ",FB@"$olution" ];
If[OptionValue[SetForSusyQ ]\[Equal]False,
TensorValues[$olution[$metric,$curved,$tensor,$ymbol ] ]^=$olution[$metric,$curved,$tensor,$value ];
TensorValues[$olution[$metric,$curved,$epsilon,$ymbol ] ]^=$olution[$metric,$curved,$epsilon,$value ];
TensorValues[$olution[$metric,$curved,$christoffel,$ymbol ] ]^=$olution[$metric,$curved,$christoffel,$value ];
TensorValues[$olution[$metric,$curved,$riemann,$ymbol ] ]^=$olution[$metric,$curved,$riemann,$value ];
TensorValues[$olution[$metric,$curved,$ricci,$ymbol ] ]^=$olution[$metric,$curved,$ricci,$value ];
If[GetKeys[$form,$tensorQ->True ]!={},
Do[TensorValues[$olution[$form,GetKeys[$form,$tensorQ->True ]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],$tensor,$ymbol ] ]^=$olution[$form,GetKeys[$form,$tensorQ->True ]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],$tensor,$value ];,{\[Alpha]\[Alpha],1,Length@GetKeys[$form,$tensorQ->True ]} ]; ];
If[Keys@$olution[$tensor]!={},
Do[TensorValues[$olution[$tensor,(Keys@$olution[$tensor])\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],$ymbol]]^=$olution[$tensor,(Keys@$olution[$tensor])\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],$value];,{\[Alpha]\[Alpha],1,Length@Keys@$olution[$tensor]}];];
Print["Attached the tensor values in ",FB@"$olution"," to the appropriate tensors" ];
Print["Current context: ",FS@System`$Context ]; ];
If[OptionValue[SetForSusyQ ]\[Equal]True,
TensorValues[$olution[$metric,$curved,$tensor,$ymbol ] ]^=$olution[$metric,$curved,$tensor,$value ];
TensorValues[$olution[$metric,$curved,$epsilon,$ymbol ] ]^=$olution[$metric,$curved,$epsilon,$value ];
TensorValues[$olution[$metric,$curved,$christoffel,$ymbol ] ]^=$olution[$metric,$curved,$christoffel,$value ];
TensorValues[$olution[$metric,$curved,$riemann,$ymbol ] ]^=$olution[$metric,$curved,$riemann,$value ];
TensorValues[$olution[$metric,$curved,$ricci,$ymbol ] ]^=$olution[$metric,$curved,$ricci,$value ];
If[GetKeys[$form,$tensorQ->True ]!={},
Do[TensorValues[$olution[$form,GetKeys[$form,$tensorQ->True ]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],$tensor,$ymbol ] ]^=$olution[$form,GetKeys[$form,$tensorQ->True ]\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],$tensor,$value ];,{\[Alpha]\[Alpha],1,Length@GetKeys[$form,$tensorQ->True ]} ]; ];
If[($olution[$metric,$flat,$tensor,$value]===Null )==False,TensorValues[$olution[$metric,$flat,$tensor,$ymbol ] ]^=$olution[$metric,$flat,$tensor,$value ] ];
If[($olution[$frame,$vielbein,$value]===Null )==False,TensorValues[$olution[$frame,$vielbein,$ymbol ] ]^=$olution[$frame,$vielbein,$value ] ];
If[($olution[$frame,$spinConnection,$ymbol]===Null )==False,TensorValues[$olution[$frame,$spinConnection,$ymbol ] ]^=$olution[$frame,$spinConnection,$value ] ];
Do[
If[($olution[$gamma,$flat,(Keys@$olution[$gamma,$flat ])\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],$value ]===Null )==False,
TensorValues[$olution[$gamma,$flat,(Keys@$olution[$gamma,$flat ])\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],$ymbol ] ]^=$olution[$gamma,$flat,(Keys@$olution[$gamma,$flat ])\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],$value ] ],
{\[Alpha]\[Alpha],1,Length@Keys@$olution[$gamma,$flat ]} ];
Do[
If[($olution[$gamma,$curved,(Keys@$olution[$gamma,$curved ])\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],$value ]===Null )==False,
TensorValues[$olution[$gamma,$curved,(Keys@$olution[$gamma,$curved ])\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],$ymbol ] ]^=$olution[$gamma,$curved,(Keys@$olution[$gamma,$curved ])\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],$value ] ],
{\[Alpha]\[Alpha],1,Length@Keys@$olution[$gamma,$curved ]} ];
If[Keys@$olution[$pinor ]!={},
Do[
If[($olution[$pinor,(Keys@$olution[$pinor ])\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],$value ]===Null )==False,
TensorValues[$olution[$pinor,(Keys@$olution[$pinor ])\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],$ymbol ] ]^= $olution[$pinor,(Keys@$olution[$pinor ])\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],$value ] ],{\[Alpha]\[Alpha],1,Length@Keys@$olution[$pinor ]}] ];
If[Keys@$olution[$tensor]!={},
Do[TensorValues[$olution[$tensor,(Keys@$olution[$tensor])\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],$ymbol]]^=$olution[$tensor,(Keys@$olution[$tensor])\[LeftDoubleBracket]\[Alpha]\[Alpha]\[RightDoubleBracket],$value];,{\[Alpha]\[Alpha],1,Length@Keys@$olution[$tensor]}];];
Print["Attached the tensor values in ",FB@"$olution"," to the appropriate tensors" ];
Print["Current context: ",FS@System`$Context ]; ] ])*)


AppendConstantSymbols[solutionNameStr_,constantSymbols_]:=(Set[$Context,"Global`"];
Module[{sn=solutionNameStr,cs=constantSymbols,
initial=GetSolution[solutionNameStr,SolutionType->Initial],
raw=GetSolution[solutionNameStr,SolutionType->Raw],
final=GetSolution[solutionNameStr,SolutionType->Final]},
initial[$constant,$ymbol]=DeleteDuplicates@Flatten@Append[initial[$constant,$ymbol],cs];
Put[initial,"Initial/"<>sn<>".m" ];
raw[$constant,$ymbol]=DeleteDuplicates@Flatten@Append[raw[$constant,$ymbol],cs];
Put[raw,"Raw/"<>sn<>".m" ];
final[$constant,$ymbol]=DeleteDuplicates@Flatten@Append[final[$constant,$ymbol],cs];
Put[final,"Final/"<>sn<>".m" ];
Set[$Context,$olution[$info,$context]];
Print["Current context: ",FS@System`$Context ];
]
)


AppendRules[solutionNameStr_,rules_]:=(Set[$Context,"Global`"];
Module[{sn=solutionNameStr,rs=rules,
raw=GetSolution[solutionNameStr,SolutionType->Raw],
final=GetSolution[solutionNameStr,SolutionType->Final]},
raw[$rule]=Append[raw[$rule],rs];
Put[raw,"Raw/"<>sn<>".m" ];
final[$rule]=Append[final[$rule],rs];
Put[final,"Final/"<>sn<>".m" ];
Set[$Context,$olution[$info,$context]];
Print["Current context: ",FS@System`$Context ];
]
)


AppendTensors[solutionNameStr_,tensors_]:=(Set[$Context,"Global`"];
Module[{sn=solutionNameStr,ts=tensors,
initial=GetSolution[solutionNameStr,SolutionType->Initial],
raw=GetSolution[solutionNameStr,SolutionType->Raw],
final=GetSolution[solutionNameStr,SolutionType->Final]},
initial[$tensor]=Append[initial[$tensor],ts];
Put[initial,"Initial/"<>sn<>".m"];
raw[$tensor]=Append[raw[$tensor],ts];
Put[raw,"Raw/"<>sn<>".m"];
final[$tensor]=Append[final[$tensor],ts];
Put[final,"Final/"<>sn<>".m"];
Set[$Context,$olution[$info,$context]];
Print["Current context: ",FS@System`$Context ];
]
)


(* ::Input::Initialization:: *)
Eom5DN2Spin2[metric_,fieldStrength_,params_,chart_ ]:=Module[{
gg=metric,
FF=fieldStrength,
par=params,
ch=chart,
i=GetIndicesOfVBundle[VBundleOfMetric[metric],26],
cd=CovDOfMetric[metric]
},
 If[TrueQ[FF==0]==True,
Return[
ToBasis[ch]@(Ricci[cd][-i[[1]],-i[[2]]]+4par[[1]]^2 gg[-i[[1]],-i[[2]]])
],
Return[
ToBasis[ch]@(Ricci[cd][-i[[1]],-i[[2]]]+4par[[1]]^2 gg[-i[[1]],-i[[2]]]-par[[2]]^2/2 FF[-i[[1]],i[[-1]]]FF[-i[[2]],-i[[-1]]]+par[[2]]^2/12 gg[-i[[1]],-i[[2]]]FF[i[[-1]],i[[-2]]]FF[-i[[-1]],-i[[-2]]])
]
]
]


Eom5DN2Spin1[metric_,fieldStrength_,params_,chart_ ]:=Module[{
gg=metric,
FF=fieldStrength,
par=params,
curved=chart,
i=GetIndicesOfVBundle[VBundleOfMetric[metric ],26],
cd=CovDOfMetric[metric],
s=(If[$olution[$info,$ignature]==Lorentzian,Return[-1];];If[$olution[$info,$ignature]==Euclidean,Return[I]])
},
Return[
ToBasis[curved]@ToBasis[curved]@CovDToChristoffel@(cd[-i[[-1]]][FF[i[[-1]],-i[[1]]]]+(s par[[2]]par[[3]])/(Sqrt[3]2!2!) epsilon[gg][-i[[1]],-i[[-1]],-i[[-2]],-i[[-3]],-i[[-4]]]FF[i[[-1]],i[[-2]]]FF[i[[-3]],i[[-4]]]/.epsilonToetaDown[gg,curved])
]
]


(* ::Input::Initialization:: *)
Bps5DN2Spin32[{metric_,flatMetric_,spinConnection_},{gaugeField_,fieldStrength_},params_,spinor_,{chart_,flatBasis_,spinBasis_} ]:=Module[{
AA=gaugeField,
FF=fieldStrength,
\[Epsilon]=spinor,
\[Omega]=spinConnection,
curved=chart,
spin=spinBasis,
flat=flatBasis,
par=params,
Gamma\[Eta]\[Eta]1=Symbol@@{"Gamma"<>ToString[flatMetric ]<>"1"},
Gamma\[Eta]\[Eta]2=Symbol@@{"Gamma"<>ToString[flatMetric ]<>"2"},
Gamma\[Eta]\[Eta]3=Symbol@@{"Gamma"<>ToString[flatMetric ]<>"3"},
Gammagg1=Symbol@@{"Gamma"<>ToString[metric ]<>"1"},
Gammagg2=Symbol@@{"Gamma"<>ToString[metric ]<>"2"},
Gammagg3=Symbol@@{"Gamma"<>ToString[metric ]<>"3"},
i=GetIndicesOfVBundle[VBundleOfMetric[metric],26],
fi=GetIndicesOfVBundle[VBundleOfMetric[flatMetric],26],
si=GetIndicesOfVBundle[(-SlotsOfTensor@spinor)[[1]],26]
},
If[TrueQ[{AA,FF}=={0,0}]==True,
Return[
ToBasis[spin ]@ToBasis[spin ]@ToBasis[curved ]@ToBasis[flat ]@
(PD[-i[[1]]][Basis[-si[[1]],si[[-1]]]\[Epsilon][-si[[-1]]]]+1/4 \[Omega][-i[[1]],-fi[[-1]],-fi[[-2]]]Gamma\[Eta]\[Eta]2[fi[[-1]],fi[[-2]],-si[[1]],si[[-1]]]\[Epsilon][-si[[-1]]]-par[[1]]/2 (Gammagg1[-i[[1]],-si[[1]],si[[-1]]])\[Epsilon][-si[[-1]]])
]
];
If[TrueQ[{AA,FF}[[2]]==0]==True,
Return[
ToBasis[spin ]@ToBasis[spin]@ToBasis[curved]@ToBasis[flat]@
(PD[-i[[1]]][Basis[-si[[1]],si[[-1]]]\[Epsilon][-si[[-1]]]]+1/4 \[Omega][-i[[1]],-fi[[-1]],-fi[[-2]]]Gamma\[Eta]\[Eta]2[fi[[-1]],fi[[-2]],-si[[1]],si[[-1]]]\[Epsilon][-si[[-1]]]-par[[1]]/2 (Gammagg1[-i[[1]],-si[[1]],si[[-1]]]+par[[2]]Sqrt[3]I AA[-i[[1]]]Basis[-si[[1]],si[[-1]]])\[Epsilon][-si[[-1]]])
]
];
If[TrueQ[{AA,FF}=={0,0}]==False,
Return[
ToBasis[spin ]@ToBasis[spin]@ToBasis[curved]@ToBasis[flat]@
(PD[-i[[1]]][Basis[-si[[1]],si[[-1]] ]\[Epsilon][-si[[-1]]]]+1/4 \[Omega][-i[[1]],-fi[[-1]],-fi[[-2]]]Gamma\[Eta]\[Eta]2[fi[[-1]],fi[[-2]],-si[[1]],si[[-1]]]\[Epsilon][-si[[-1]]]-par[[1]]/2 (Gammagg1[-i[[1]],-si[[1]],si[[-1]]]+par[[2]]Sqrt[3]I AA[-i[[1]]]Basis[-si[[1]],si[[-1]]])\[Epsilon][-si[[-1]]]-(I par[[2]])/(8Sqrt[3]) (Gammagg3[-i[[1]],-i[[-1]],-i[[-2]],-si[[1]],si[[-1]]]FF[i[[-1]],i[[-2]]]-4FF[-i[[1]],-i[[-2]]]Gammagg1[i[[-2]],-si[[1]],si[[-1]]])\[Epsilon][-si[[-1]]])
]
];
]


Eom4DN0Spin2[metric_,fieldStrength_,params_,chart_]:=Module[{gg=metric,FF=fieldStrength,par=params,ch=chart,ind=GetIndicesOfVBundle[VBundleOfMetric[metric ],26 ],cd=CovDOfMetric[metric ]},
If[TrueQ[FF==0]==True,
Return[ToBasis[ch]@(Ricci[cd][-ind[[1]],-ind[[2]]]+3par[[1]]^2 gg[-ind[[1]],-ind[[2]]])],
Return[ToBasis[ch]@(Ricci[cd][-ind[[1]],-ind[[2]]]+3par[[1]]^2 gg[-ind[[1]],-ind[[2]]]-1/2 FF[-ind[[1]],ind[[-1]]]FF[-ind[[2]],-ind[[-1]]]+1/8 gg[-ind[[1]],-ind[[2]]]FF[ind[[-1]],ind[[-2]]]FF[-ind[[-1]],-ind[[-2]]])]
]
]


Eom4DN0Spin1[metric_,fieldStrength_,params_,chart_ ]:=Module[{gg=metric,FF=fieldStrength,par=params,ch=chart,ind=GetIndicesOfVBundle[VBundleOfMetric[metric ],26 ],cd=CovDOfMetric[metric ]},
Return[ToBasis[ch]@ToBasis[ch]@CovDToChristoffel@cd[-ind[[-1]]][FF[ind[[-1]],ind[[1]]]]]
]


(* ::Input::Initialization:: *)
(****************************** 3. End SolutionsX *****************************)


(* ::Input::Initialization:: *)
Protect/@{
(*get keys and values of internal vairables*)
(*GetValues,
GetKeys,*)
(*set functions*)
(*SetConstantSymbols,
SetScalarFunctions,
SetChart,
SetForms,
SetTensors,
SetupMetric,
SetFrameBundle,
SetSpinStructure,
SetSpinConnection,
SetFrameForms,
SetSpinors,
SetBases,*)
(*set environment: calls the other set functions in the correct order*)
(*SetSolution,*)
(*generate matrices corresponding to various tensors from raw object to be fed in the calculation functions*)

(*calculate functions*)
(*CalculateMetric2,
CalculateFormTensor,
CalculateFrame,
CalculateGamma,
CalculateRank2Tensor,*)
(*save and load function*)
(*PrintSolutions,
GetSolution,
CleanSolution,*)
(*append functions*)
(*AppendConstantSymbols,
AppendRules,
AppendTensors,*)

(*miscellenous*)
(*GenRandomRealRule,
GenContext,
GenChangeContextRule,
GenFunctionRule,
ToValues2,*)
(*options*)
(*SetForSusyQ,
SetSolutionQ,
SimplificationMethod,
CalculateRiemannQ,
AllQ,
ParallelQ,
SolutionType,
$tensorQ,
IncludeCoordinatesQ,
PrintContextQ,*)

ChangeContextQ,
ChangeCoordQ,
ParallelSimplify,

GenFunctionRule,
GenContext,
ToValues2,
GetCNumber,
TTensor,
PrintRule,
ListMap,
ExtractPrefactor,
PlusSimplify,
PlusSeries,

ValidateInfo,
ValidateManifold,
ValidateBasis,
ValidateConstant,
ValidateFunction,
ValidateAssumption,
ValidateScalar,
ValidateForm,
ValidateTensor,
ValidateMetric,
ValidateFrame,
ValidateGamma,
ValidateSpinor,

SetInfo,
SetManifold,
SetBasis,
SetConstant,
SetFunction,
SetAssumption,
SetScalar,
SetForm,
SetTensor,
SetMetric,
SetFrame,
SetGamma,
SetSpinor,

ContextMergeSymbol,
LoadManifold,
LoadChart,
LoadConstant,
LoadFunction,
LoadScalar,
LoadForm,
LoadTensor,
LoadMetric,
LoadFrameBundle,
LoadSpinStructure,
LoadSpinConnection,
LoadFrameForm,
LoadSpinor,
LoadBasis,

LoadAppendConstant,
LoadAppendFunction,
LoadAppendScalar,
LoadAppendForm,
LoadAppendTensor,
LoadAppendSpinor,
LoadAppendRule,
LoadAppendAssumption,

UnloadDeleteConstant,
UnloadDeleteFunction,
UnloadDeleteScalar,
UnloadDeleteForm,
UnloadDeleteTensor,
UnloadDeleteSpinor,
UnloadDeleteRule,
UnloadDeleteAssumption,

ValidateSaveSolution,
SaveSolution,
SaveCoordinateTransformation,
ChangeContext,
LoadSolution,
Load$olution,
ButtonLoadSolution,
ValidateSolution,
DeleteSolution,
ButtonDeleteSolution,
SaveGenerator,
SaveExample,
ToInitial,
AttachTVs,
Solution,
AllSolutions,
Print$olution,
PrintSolution,
ChangeCoord,
ChangeXCoord,

GenerateMetric,
GenerateFormTensor,
GenerateVielbein,
Set$metric,

PrintComputeMetric,
PrintComputeTensor,

Compute,
MapSimplify,
ParallelMapSimplify,
PrintMapSimplify,
PrintParallelMapSimplify,
PrintParallelMapSimplify2,
PlusParallelMapSimplify,

(*PrepareMetric,
PrepareChristoffel,
PrepareRiemann,
PrepareRicci,
PrepareTensor1,
PrepareTensor2,
PrepareTensor3,
PrepareSpinConnection,
PrepareTensor,*)

(*ApplySimplify,
ApplyParallelSimplify,
CalculateMetric,
CalculateChristoffel,
CalculateRiemann,
CalculateRicci,
CalculateTensor1,
CalculateTensor2,
CalculateTensor3,
CalculateVielbein,
CalculateSpinConnection,
CalculateTensor,*)

Eom5DN2Spin2,
Eom5DN2Spin1,
Bps5DN2Spin32,
Eom4DN0Spin2,
Eom4DN0Spin1
};


(* ::Input::Initialization:: *)
End[];
EndPackage[];
